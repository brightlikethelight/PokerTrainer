{"version":3,"file":"static/js/poker-game.1f77de8b.chunk.js","mappings":"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","sources":["game/entities/Deck.js","game/entities/GameState.js","game/utils/HandEvaluator.js","game/engine/GameEngine.js","game/entities/Player.js","hooks/usePokerGame.js","components/game/BettingControls.jsx","components/game/Card.jsx","components/game/PlayerSeat.jsx","components/game/PokerTable.jsx","game/engine/BettingLogic.js","game/engine/strategies/PositionStrategy.js","game/engine/AIPlayer.js"],"sourcesContent":["import { RANKS, SUITS } from '../../constants/game-constants';\n\nimport Card from './Card';\n\nclass Deck {\n  constructor() {\n    this.cards = [];\n    this.dealtCards = [];\n    this.reset();\n  }\n\n  reset() {\n    this.cards = [];\n    this.dealtCards = [];\n\n    for (const suit of Object.values(SUITS)) {\n      for (const rank of Object.values(RANKS)) {\n        this.cards.push(new Card(rank, suit));\n      }\n    }\n\n    this.shuffle();\n  }\n\n  shuffle() {\n    // Use cryptographically secure random for fair card distribution\n    // Falls back to Math.random in environments without crypto support\n    const getRandomIndex = (max) => {\n      if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n        const array = new Uint32Array(1);\n        crypto.getRandomValues(array);\n        return Math.floor((array[0] / (0xffffffff + 1)) * max);\n      }\n      return Math.floor(Math.random() * max);\n    };\n\n    // Fisher-Yates shuffle\n    for (let i = this.cards.length - 1; i > 0; i--) {\n      const j = getRandomIndex(i + 1);\n      [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];\n    }\n  }\n\n  dealCard() {\n    if (this.cards.length === 0) {\n      throw new Error('Not enough cards in deck');\n    }\n\n    const card = this.cards.shift(); // Deal from top (index 0)\n    this.dealtCards.push(card);\n    return card;\n  }\n\n  dealOne() {\n    return this.dealCard();\n  }\n\n  dealCards(count) {\n    if (count < 0) {\n      throw new Error('Cannot deal negative number of cards');\n    }\n\n    if (count > this.cards.length) {\n      throw new Error('Not enough cards in deck');\n    }\n\n    const cards = [];\n    for (let i = 0; i < count; i++) {\n      cards.push(this.dealCard());\n    }\n    return cards;\n  }\n\n  deal(count) {\n    return this.dealCards(count);\n  }\n\n  cardsRemaining() {\n    return this.cards.length;\n  }\n\n  getRemainingCards() {\n    return this.cardsRemaining();\n  }\n\n  getDealtCards() {\n    return [...this.dealtCards];\n  }\n\n  removeSpecificCards(cardsToRemove) {\n    this.cards = this.cards.filter(\n      (card) =>\n        !cardsToRemove.some(\n          (removeCard) => card.rank === removeCard.rank && card.suit === removeCard.suit\n        )\n    );\n  }\n}\n\nexport default Deck;\n","import { GAME_PHASES, PLAYER_STATUS } from '../../constants/game-constants';\n\nclass GameState {\n  constructor() {\n    this.players = [];\n    this.deck = null;\n    this.communityCards = [];\n    this._internalPot = {\n      main: 0,\n      side: [],\n    };\n    this.potHistory = []; // Track pot changes\n    this.currentBet = 0;\n    this._currentBet = 0; // Alias for compatibility\n    this.minimumRaise = 0;\n    this.minRaise = 0; // Alias for compatibility\n    this.dealerPosition = 0;\n    this.smallBlindPosition = 1; // Add missing property\n    this.bigBlindPosition = 2; // Add missing property\n    this.currentPlayerIndex = 0;\n    this.phase = GAME_PHASES.WAITING;\n    this.handNumber = 0;\n    this.blinds = {\n      small: 10,\n      big: 20,\n    };\n    this.lastRaiserIndex = null;\n    this.bettingRoundComplete = false;\n    this.handHistory = [];\n    this.winners = [];\n  }\n\n  initialize(players) {\n    this.players = players;\n    this.dealerPosition = 0;\n\n    // Handle heads-up (2 players) vs multi-player scenarios\n    if (players.length === 2) {\n      this.smallBlindPosition = 0; // Dealer is SB in heads-up\n      this.bigBlindPosition = 1;\n      this.currentPlayerIndex = 0; // SB acts first preflop in heads-up\n    } else {\n      this.smallBlindPosition = 1;\n      this.bigBlindPosition = 2;\n      this.currentPlayerIndex = 3; // First to act after big blind\n    }\n\n    this._internalPot = {\n      main: 0,\n      side: [],\n    };\n    this.potHistory = [];\n    this.currentBet = 0;\n    this._currentBet = 0;\n    this.minimumRaise = 0;\n    this.minRaise = 0;\n    this.phase = GAME_PHASES.PREFLOP;\n  }\n\n  validateState() {\n    // Basic validation checks\n    if (!this.players || this.players.length < 2) {\n      return false;\n    }\n\n    if (this.dealerPosition < 0 || this.dealerPosition >= this.players.length) {\n      return false;\n    }\n\n    if (this.currentPlayerIndex < 0 || this.currentPlayerIndex >= this.players.length) {\n      return false;\n    }\n\n    return true;\n  }\n\n  addPlayer(player) {\n    this.players.push(player);\n    player.position = this.players.length - 1;\n  }\n\n  removePlayer(playerId) {\n    this.players = this.players.filter((p) => p.id !== playerId);\n    this.updatePlayerPositions();\n  }\n\n  updatePlayerPositions() {\n    this.players.forEach((player, index) => {\n      player.position = index;\n    });\n  }\n\n  getActivePlayers() {\n    // Players are \"active\" if they can participate in the hand\n    // This includes players who are WAITING, ACTIVE, CHECKED, CALLED, RAISED, or ALL_IN\n    // but excludes players who are FOLDED or SITTING_OUT\n    // Note: ALL_IN players have chips=0 but are still in the hand\n    return this.players.filter(\n      (p) =>\n        p.isActive &&\n        (p.chips > 0 || p.status === PLAYER_STATUS.ALL_IN) &&\n        p.status !== PLAYER_STATUS.FOLDED &&\n        p.status !== PLAYER_STATUS.SITTING_OUT\n    );\n  }\n\n  getPlayersInHand() {\n    return this.players.filter((p) => p.isInHand());\n  }\n\n  getNextActivePlayerIndex(startIndex) {\n    if (!this.players || this.players.length === 0) {\n      return -1;\n    }\n\n    const numPlayers = this.players.length;\n    let index = (startIndex + 1) % numPlayers;\n\n    // Search through all players starting from the next position\n    for (let i = 0; i < numPlayers; i++) {\n      const player = this.players[index];\n\n      // Check if this player can act\n      if (player && player.canAct()) {\n        return index;\n      }\n\n      // Move to next player (with wrap-around)\n      index = (index + 1) % numPlayers;\n    }\n\n    // No valid players found after checking all positions\n    return -1;\n  }\n\n  moveButton() {\n    this.dealerPosition = (this.dealerPosition + 1) % this.players.length;\n\n    while (this.players[this.dealerPosition].chips === 0) {\n      this.dealerPosition = (this.dealerPosition + 1) % this.players.length;\n    }\n  }\n\n  getSmallBlindPosition() {\n    if (this.players.length === 2) {\n      return this.dealerPosition;\n    }\n\n    let position = (this.dealerPosition + 1) % this.players.length;\n    while (this.players[position].chips === 0) {\n      position = (position + 1) % this.players.length;\n    }\n    return position;\n  }\n\n  getBigBlindPosition() {\n    const sbPosition = this.getSmallBlindPosition();\n    let position = (sbPosition + 1) % this.players.length;\n\n    while (this.players[position].chips === 0) {\n      position = (position + 1) % this.players.length;\n    }\n    return position;\n  }\n\n  getUTGPosition() {\n    const bbPosition = this.getBigBlindPosition();\n    let position = (bbPosition + 1) % this.players.length;\n\n    while (this.players[position].chips === 0) {\n      position = (position + 1) % this.players.length;\n    }\n    return position;\n  }\n\n  resetForNewHand() {\n    this.communityCards = [];\n    this._internalPot = {\n      main: 0,\n      side: [],\n    };\n    this.potHistory = [];\n    this.currentBet = 0;\n    this._currentBet = 0;\n    this.minimumRaise = this.blinds.big;\n    this.minRaise = this.blinds.big;\n    this.phase = GAME_PHASES.PREFLOP;\n    this.lastRaiserIndex = null;\n    this.bettingRoundComplete = false;\n    this.winners = [];\n    this.handNumber++;\n\n    this.players.forEach((player) => {\n      if (player.chips > 0) {\n        player.resetForNewHand();\n      } else {\n        player.status = PLAYER_STATUS.SITTING_OUT;\n      }\n    });\n  }\n\n  calculateSidePots() {\n    const activePlayers = this.getPlayersInHand();\n    if (activePlayers.length === 0) return;\n\n    const contributions = [];\n    activePlayers.forEach((player) => {\n      if (player.totalPotContribution > 0) {\n        contributions.push({\n          player,\n          amount: player.totalPotContribution,\n        });\n      }\n    });\n\n    contributions.sort((a, b) => a.amount - b.amount);\n\n    this._internalPot = { main: 0, side: [] };\n    let previousAmount = 0;\n\n    for (let i = 0; i < contributions.length; i++) {\n      const currentAmount = contributions[i].amount;\n      const potAmount = (currentAmount - previousAmount) * (contributions.length - i);\n\n      if (i === 0) {\n        this._internalPot.main = potAmount;\n      } else {\n        const eligiblePlayers = contributions.slice(i).map((c) => c.player);\n        this._internalPot.side.push({\n          amount: potAmount,\n          eligiblePlayers,\n        });\n      }\n\n      previousAmount = currentAmount;\n    }\n  }\n\n  getTotalPot() {\n    let total = this._internalPot.main;\n    this._internalPot.side.forEach((sidePot) => {\n      total += sidePot.amount;\n    });\n    return total;\n  }\n\n  addToHistory(_action) {\n    this.handHistory.push({\n      handNumber: this.handNumber,\n      phase: this.phase,\n      _action,\n      timestamp: Date.now(),\n    });\n  }\n\n  getPlayerByPosition(position) {\n    return this.players.find((p) => p.position === position);\n  }\n\n  serialize() {\n    return {\n      players: this.players.map((p) => p.serialize()),\n      communityCards: this.communityCards.map((c) => ({\n        rank: c.rank,\n        suit: c.suit,\n      })),\n      pot: this._internalPot,\n      _pot: this._internalPot.main, // Include for test compatibility - return main value\n      currentBet: this.currentBet,\n      minimumRaise: this.minimumRaise,\n      dealerPosition: this.dealerPosition,\n      currentPlayerIndex: this.currentPlayerIndex,\n      phase: this.phase,\n      handNumber: this.handNumber,\n      blinds: this.blinds,\n      totalPot: this.getTotalPot(),\n      playersInHand: this.getPlayersInHand().length,\n      winners: this.winners,\n      // Add missing methods that tests expect\n      getTotalPot: () => this.getTotalPot(),\n      getPlayersInHand: () => this.getPlayersInHand(),\n      getActivePlayers: () => this.getActivePlayers(),\n      getSmallBlindPosition: () => this.getSmallBlindPosition(),\n      getBigBlindPosition: () => this.getBigBlindPosition(),\n      getPlayerByPosition: (position) => this.getPlayerByPosition(position),\n    };\n  }\n\n  get pot() {\n    // Return object that behaves like number but has .main property\n    const self = this;\n    const potValue = this._internalPot.main;\n\n    return {\n      // Make it behave like a number for comparisons\n      valueOf() {\n        return potValue;\n      },\n      toString() {\n        return potValue.toString();\n      },\n\n      // For Jest's .toBe() strict equality\n      [Symbol.toPrimitive](_hint) {\n        return potValue;\n      },\n\n      // Support .main property access\n      get main() {\n        return self._internalPot.main;\n      },\n      set main(value) {\n        self._internalPot.main = value;\n      },\n    };\n  }\n\n  set pot(value) {\n    if (typeof value === 'number') {\n      this._internalPot.main = value;\n    } else {\n      this._internalPot = value;\n    }\n  }\n\n  // Return main pot value as number for test compatibility\n  get _pot() {\n    return this._internalPot.main;\n  }\n\n  set _pot(value) {\n    if (typeof value === 'number') {\n      this._internalPot = { main: value, side: [] };\n    } else {\n      this._internalPot = value;\n    }\n  }\n\n  // Provide access to full pot object when needed by BettingLogic\n  get potObject() {\n    return this._internalPot;\n  }\n\n  nextDealer() {\n    this.dealerPosition = (this.dealerPosition + 1) % this.players.length;\n\n    // Skip players without chips or inactive players (sitting out)\n    while (\n      this.players[this.dealerPosition].chips === 0 ||\n      !this.players[this.dealerPosition].isActive\n    ) {\n      this.dealerPosition = (this.dealerPosition + 1) % this.players.length;\n    }\n\n    // Update blind positions based on new dealer\n    if (this.players.length === 2) {\n      this.smallBlindPosition = this.dealerPosition; // Dealer is SB in heads-up\n      this.bigBlindPosition = (this.dealerPosition + 1) % this.players.length;\n    } else {\n      this.smallBlindPosition = (this.dealerPosition + 1) % this.players.length;\n      this.bigBlindPosition = (this.dealerPosition + 2) % this.players.length;\n    }\n  }\n\n  addToPot(amount) {\n    this._internalPot.main += amount;\n    this.potHistory.push(amount);\n  }\n\n  setCurrentBet(amount, minRaise = 0) {\n    this.currentBet = amount;\n    this._currentBet = amount;\n    this.minimumRaise = minRaise;\n    this.minRaise = minRaise;\n  }\n\n  nextPhase() {\n    const phases = [\n      GAME_PHASES.PREFLOP,\n      GAME_PHASES.FLOP,\n      GAME_PHASES.TURN,\n      GAME_PHASES.RIVER,\n      GAME_PHASES.SHOWDOWN,\n    ];\n    const currentIndex = phases.indexOf(this.phase);\n\n    if (currentIndex < phases.length - 1) {\n      this.phase = phases[currentIndex + 1];\n    }\n\n    // Reset betting for new phase\n    this.currentBet = 0;\n    this._currentBet = 0;\n    this.minimumRaise = 0;\n    this.minRaise = 0;\n  }\n\n  setCommunityCards(cards) {\n    this.communityCards = cards;\n  }\n\n  nextPlayer() {\n    this.currentPlayerIndex = this.getNextActivePlayerIndex(this.currentPlayerIndex);\n  }\n\n  getCurrentPlayer() {\n    return this.players[this.currentPlayerIndex];\n  }\n\n  isHandComplete() {\n    if (this.phase === GAME_PHASES.SHOWDOWN) {\n      return true;\n    }\n\n    const playersInHand = this.getPlayersInHand();\n    return playersInHand.length <= 1;\n  }\n\n  createSidePots() {\n    const playersInHand = this.getPlayersInHand();\n    if (playersInHand.length === 0) return [];\n\n    const contributions = [];\n    playersInHand.forEach((player) => {\n      const contribution = player.currentBet || player._currentBet || 0;\n      if (contribution > 0) {\n        contributions.push({\n          player,\n          amount: contribution,\n        });\n      }\n    });\n\n    contributions.sort((a, b) => a.amount - b.amount);\n\n    const sidePots = [];\n    let previousAmount = 0;\n\n    for (let i = 0; i < contributions.length; i++) {\n      const currentAmount = contributions[i].amount;\n      const potAmount = (currentAmount - previousAmount) * (contributions.length - i);\n\n      if (potAmount > 0) {\n        const eligiblePlayers = contributions.slice(i).map((c) => c.player);\n        sidePots.push({\n          amount: potAmount,\n          eligiblePlayers,\n        });\n      }\n\n      previousAmount = currentAmount;\n    }\n\n    return sidePots;\n  }\n\n  isBettingRoundComplete() {\n    // Import BettingLogic to check if betting round is complete\n    // For now, implement basic logic here to avoid circular imports\n    const activePlayers = this.getActivePlayers().filter((p) => p.canAct());\n    if (activePlayers.length <= 1) {\n      return true;\n    }\n\n    // Check if all players have acted and bets are equal\n    const playersWhoCanAct = activePlayers.filter(\n      (p) => p.status !== PLAYER_STATUS.FOLDED && p.status !== PLAYER_STATUS.ALL_IN\n    );\n\n    if (playersWhoCanAct.length === 0) {\n      return true;\n    }\n\n    // Simple check: if all active players have the same current bet\n    const bets = playersWhoCanAct.map((p) => p._currentBet);\n    const allBetsEqual = bets.every((bet) => bet === bets[0]);\n\n    return allBetsEqual && playersWhoCanAct.every((p) => p.lastAction !== null);\n  }\n\n  toJSON() {\n    return this.serialize();\n  }\n}\n\nexport default GameState;\n","import { HAND_RANKINGS } from '../../constants/game-constants';\n\n/**\n * Static utility class for evaluating poker hands and determining winners.\n * Implements Texas Hold'em hand ranking rules and comparison logic.\n *\n * @class HandEvaluator\n * @example\n * const cards = [card1, card2, card3, card4, card5, card6, card7];\n * const bestHand = HandEvaluator.evaluateHand(cards);\n * console.log(`Best hand: ${bestHand.description}`);\n */\nclass HandEvaluator {\n  /**\n   * Evaluates the best possible 5-card poker hand from 5-7 cards.\n   *\n   * @static\n   * @param {Card[]} cards - Array of 5-7 cards to evaluate\n   * @returns {Object} Hand evaluation result containing rank, cards, description, and tiebreakers\n   * @throws {Error} If fewer than 5 cards provided\n   * @example\n   * const hand = HandEvaluator.evaluateHand([card1, card2, card3, card4, card5]);\n   * // Returns: { rank: 8, rankName: \"Straight\", cards: [...], description: \"Straight, Ten high\" }\n   */\n  static evaluateHand(cards) {\n    if (cards.length < 5) {\n      throw new Error('Need at least 5 cards to evaluate');\n    }\n\n    const allCombinations = this.getCombinations(cards, 5);\n    let bestHand = null;\n    let bestRank = -1;\n    let bestTiebreakers = [];\n\n    for (const combination of allCombinations) {\n      const evaluation = this.evaluateFiveCardHand(combination);\n\n      if (\n        evaluation.rank > bestRank ||\n        (evaluation.rank === bestRank &&\n          this.compareTiebreakers(evaluation.tiebreakers, bestTiebreakers) > 0)\n      ) {\n        bestRank = evaluation.rank;\n        bestTiebreakers = evaluation.tiebreakers;\n        bestHand = {\n          rank: evaluation.rank,\n          rankName: evaluation.rankName,\n          cards: combination,\n          tiebreakers: evaluation.tiebreakers,\n          description: evaluation.description,\n        };\n      }\n    }\n\n    return bestHand;\n  }\n\n  static evaluateFiveCardHand(cards) {\n    const sortedCards = [...cards].sort((a, b) => b.value - a.value);\n\n    const isFlush = this.checkFlush(cards);\n    const straightHighCard = this.checkStraight(sortedCards);\n    const groups = this.groupByRank(cards);\n    const groupSizes = Object.values(groups)\n      .map((group) => group.length)\n      .sort((a, b) => b - a);\n\n    if (isFlush && straightHighCard) {\n      if (straightHighCard === 14) {\n        return {\n          rank: HAND_RANKINGS.ROYAL_FLUSH,\n          rankName: 'Royal Flush',\n          tiebreakers: [],\n          description: 'Royal Flush',\n        };\n      }\n      return {\n        rank: HAND_RANKINGS.STRAIGHT_FLUSH,\n        rankName: 'Straight Flush',\n        tiebreakers: [straightHighCard],\n        description: `Straight Flush, ${this.getCardName(straightHighCard)} high`,\n      };\n    }\n\n    if (groupSizes[0] === 4) {\n      const fourOfAKindRank = this.getRankOfSize(groups, 4);\n      const kicker = this.getRankOfSize(groups, 1);\n      return {\n        rank: HAND_RANKINGS.FOUR_OF_A_KIND,\n        rankName: 'Four of a Kind',\n        tiebreakers: [fourOfAKindRank, kicker],\n        description: `Four of a Kind, ${this.getCardName(fourOfAKindRank)}s`,\n      };\n    }\n\n    if (groupSizes[0] === 3 && groupSizes[1] === 2) {\n      const threeOfAKindRank = this.getRankOfSize(groups, 3);\n      const pairRank = this.getRankOfSize(groups, 2);\n      return {\n        rank: HAND_RANKINGS.FULL_HOUSE,\n        rankName: 'Full House',\n        tiebreakers: [threeOfAKindRank, pairRank],\n        description: `Full House, ${this.getCardName(\n          threeOfAKindRank\n        )}s full of ${this.getCardName(pairRank)}s`,\n      };\n    }\n\n    if (isFlush) {\n      const flushCards = sortedCards.map((c) => c.value);\n      return {\n        rank: HAND_RANKINGS.FLUSH,\n        rankName: 'Flush',\n        tiebreakers: flushCards,\n        description: `Flush, ${this.getCardName(flushCards[0])} high`,\n      };\n    }\n\n    if (straightHighCard) {\n      return {\n        rank: HAND_RANKINGS.STRAIGHT,\n        rankName: 'Straight',\n        tiebreakers: [straightHighCard],\n        description: `Straight, ${this.getCardName(straightHighCard)} high`,\n      };\n    }\n\n    if (groupSizes[0] === 3) {\n      const threeOfAKindRank = this.getRankOfSize(groups, 3);\n      const kickers = this.getKickers(groups, [threeOfAKindRank], 2);\n      return {\n        rank: HAND_RANKINGS.THREE_OF_A_KIND,\n        rankName: 'Three of a Kind',\n        tiebreakers: [threeOfAKindRank, ...kickers],\n        description: `Three of a Kind, ${this.getCardName(threeOfAKindRank)}s`,\n      };\n    }\n\n    if (groupSizes[0] === 2 && groupSizes[1] === 2) {\n      const pairs = this.getRanksOfSize(groups, 2).sort((a, b) => b - a);\n      const kicker = this.getKickers(groups, pairs, 1)[0];\n      return {\n        rank: HAND_RANKINGS.TWO_PAIR,\n        rankName: 'Two Pair',\n        tiebreakers: [...pairs, kicker],\n        description: `Two Pair, ${this.getCardName(pairs[0])}s and ${this.getCardName(pairs[1])}s`,\n      };\n    }\n\n    if (groupSizes[0] === 2) {\n      const pairRank = this.getRankOfSize(groups, 2);\n      const kickers = this.getKickers(groups, [pairRank], 3);\n      return {\n        rank: HAND_RANKINGS.PAIR,\n        rankName: 'Pair',\n        tiebreakers: [pairRank, ...kickers],\n        description: `Pair of ${this.getCardName(pairRank)}s`,\n      };\n    }\n\n    const highCards = sortedCards.map((c) => c.value).slice(0, 5);\n    return {\n      rank: HAND_RANKINGS.HIGH_CARD,\n      rankName: 'High Card',\n      tiebreakers: highCards,\n      description: `High Card, ${this.getCardName(highCards[0])}`,\n    };\n  }\n\n  static checkFlush(cards) {\n    const suits = {};\n    for (const card of cards) {\n      suits[card.suit] = (suits[card.suit] || 0) + 1;\n    }\n    return Object.values(suits).some((count) => count >= 5);\n  }\n\n  static checkStraight(sortedCards) {\n    const values = sortedCards.map((c) => c.value);\n\n    for (let i = 0; i <= values.length - 5; i++) {\n      let isStraight = true;\n      for (let j = 0; j < 4; j++) {\n        if (values[i + j] - values[i + j + 1] !== 1) {\n          isStraight = false;\n          break;\n        }\n      }\n      if (isStraight) {\n        return values[i];\n      }\n    }\n\n    if (\n      values[0] === 14 &&\n      values[values.length - 4] === 5 &&\n      values[values.length - 3] === 4 &&\n      values[values.length - 2] === 3 &&\n      values[values.length - 1] === 2\n    ) {\n      return 5;\n    }\n\n    return null;\n  }\n\n  static groupByRank(cards) {\n    const groups = {};\n    for (const card of cards) {\n      if (!groups[card.value]) {\n        groups[card.value] = [];\n      }\n      groups[card.value].push(card);\n    }\n    return groups;\n  }\n\n  static getRankOfSize(groups, size) {\n    for (const [rank, cards] of Object.entries(groups)) {\n      if (cards.length === size) {\n        return parseInt(rank);\n      }\n    }\n    return null;\n  }\n\n  static getRanksOfSize(groups, size) {\n    const ranks = [];\n    for (const [rank, cards] of Object.entries(groups)) {\n      if (cards.length === size) {\n        ranks.push(parseInt(rank));\n      }\n    }\n    return ranks;\n  }\n\n  static getKickers(groups, usedRanks, count) {\n    const kickers = [];\n    const sortedRanks = Object.keys(groups)\n      .map((r) => parseInt(r))\n      .filter((r) => !usedRanks.includes(r))\n      .sort((a, b) => b - a);\n\n    for (let i = 0; i < count && i < sortedRanks.length; i++) {\n      kickers.push(sortedRanks[i]);\n    }\n\n    return kickers;\n  }\n\n  static compareTiebreakers(a, b) {\n    for (let i = 0; i < Math.min(a.length, b.length); i++) {\n      if (a[i] > b[i]) return 1;\n      if (a[i] < b[i]) return -1;\n    }\n    return 0;\n  }\n\n  static getCardName(value) {\n    const names = {\n      2: 'Two',\n      3: 'Three',\n      4: 'Four',\n      5: 'Five',\n      6: 'Six',\n      7: 'Seven',\n      8: 'Eight',\n      9: 'Nine',\n      10: 'Ten',\n      11: 'Jack',\n      12: 'Queen',\n      13: 'King',\n      14: 'Ace',\n    };\n    return names[value] || value.toString();\n  }\n\n  static getCombinations(arr, size) {\n    const combinations = [];\n\n    function backtrack(start, current) {\n      if (current.length === size) {\n        combinations.push([...current]);\n        return;\n      }\n\n      for (let i = start; i < arr.length; i++) {\n        current.push(arr[i]);\n        backtrack(i + 1, current);\n        current.pop();\n      }\n    }\n\n    backtrack(0, []);\n    return combinations;\n  }\n\n  /**\n   * Compares two evaluated poker hands to determine which is stronger.\n   *\n   * @static\n   * @param {Object} hand1 - First hand evaluation result\n   * @param {Object} hand2 - Second hand evaluation result\n   * @returns {number} 1 if hand1 wins, -1 if hand2 wins, 0 if tie\n   * @example\n   * const result = HandEvaluator.compareHands(straightHand, flushHand);\n   * // Returns: -1 (flush beats straight)\n   */\n  static compareHands(hand1, hand2) {\n    if (hand1.rank > hand2.rank) return 1;\n    if (hand1.rank < hand2.rank) return -1;\n\n    return this.compareTiebreakers(hand1.tiebreakers, hand2.tiebreakers);\n  }\n\n  /**\n   * Determines the winning player(s) from a collection of player hands.\n   * Handles ties by returning multiple winners when hands are equal.\n   *\n   * @static\n   * @param {Object[]} playerHands - Array of {player, cards} objects\n   * @returns {Object[]} Array of {player, hand} objects for winning player(s)\n   * @example\n   * const winners = HandEvaluator.findWinners([\n   *   {player: player1, cards: [...]},\n   *   {player: player2, cards: [...]}\n   * ]);\n   * console.log(`${winners[0].player.name} wins with ${winners[0].hand.description}`);\n   */\n  static findWinners(playerHands) {\n    const evaluatedHands = playerHands.map(({ player, cards }) => ({\n      player,\n      hand: this.evaluateHand(cards),\n    }));\n\n    evaluatedHands.sort((a, b) => this.compareHands(b.hand, a.hand));\n\n    const winners = [evaluatedHands[0]];\n    for (let i = 1; i < evaluatedHands.length; i++) {\n      if (this.compareHands(evaluatedHands[0].hand, evaluatedHands[i].hand) === 0) {\n        winners.push(evaluatedHands[i]);\n      } else {\n        break;\n      }\n    }\n\n    return winners;\n  }\n}\n\nexport default HandEvaluator;\n","import { GAME_PHASES } from '../../constants/game-constants';\nimport Deck from '../entities/Deck';\nimport GameState from '../entities/GameState';\nimport HandEvaluator from '../utils/HandEvaluator';\n\nimport BettingLogic from './BettingLogic';\n\n/**\n * Core poker game engine that orchestrates Texas Hold'em gameplay.\n * Manages game state, player actions, betting rounds, and hand progression.\n *\n * @class GameEngine\n * @example\n * const gameEngine = new GameEngine();\n * gameEngine.addPlayer(new Player('player1', 'Alice', 1000, 0));\n * gameEngine.addPlayer(new Player('player2', 'Bob', 1000, 1));\n * gameEngine.setBlinds(10, 20);\n * gameEngine.startNewHand();\n */\nclass GameEngine {\n  /**\n   * Creates a new GameEngine instance.\n   * Initializes the game state, deck, and event callbacks.\n   *\n   * @constructor\n   */\n  constructor() {\n    this.gameState = new GameState();\n    this.deck = new Deck();\n    this.gameState.deck = this.deck;\n    this._isRestarting = false;\n    this._isInitialized = false;\n    this.callbacks = {\n      onStateChange: null,\n      onHandComplete: null,\n      onPlayerAction: null,\n      onPhaseChange: null,\n      onShowdown: null,\n    };\n  }\n\n  /**\n   * Sets a callback function for a specific game event.\n   *\n   * @param {string} event - The event name ('onStateChange', 'onHandComplete', 'onPlayerAction', 'onPhaseChange', 'onShowdown')\n   * @param {Function} callback - The callback function to execute when the event occurs\n   * @example\n   * gameEngine.setCallback('onStateChange', (gameState) => {\n   *   console.log('Game state updated:', gameState);\n   * });\n   */\n  setCallback(event, callback) {\n    if (Object.prototype.hasOwnProperty.call(this.callbacks, event)) {\n      this.callbacks[event] = callback;\n    }\n  }\n\n  /**\n   * Adds a player to the game.\n   *\n   * @param {Player} player - The player object to add to the game\n   * @throws {Error} If player is invalid or game is full\n   * @example\n   * const player = new Player('player1', 'Alice', 1000, 0);\n   * gameEngine.addPlayer(player);\n   */\n  addPlayer(player) {\n    this.gameState.addPlayer(player);\n    this.notifyStateChange();\n  }\n\n  /**\n   * Removes a player from the game.\n   *\n   * @param {string} playerId - The unique identifier of the player to remove\n   * @example\n   * gameEngine.removePlayer('player1');\n   */\n  removePlayer(playerId) {\n    this.gameState.removePlayer(playerId);\n    this.notifyStateChange();\n  }\n\n  /**\n   * Starts a new poker hand.\n   * Resets players, moves the dealer button, posts blinds, and deals hole cards.\n   *\n   * @throws {Error} If fewer than 2 players are available or deck has insufficient cards\n   * @example\n   * gameEngine.startNewHand();\n   */\n  startNewHand() {\n    try {\n      if (this._isRestarting) {\n        return;\n      }\n\n      // Reset players for new hand first (sets status to ACTIVE)\n      this.gameState.resetForNewHand();\n\n      if (this.gameState.getActivePlayers().length < 2) {\n        throw new Error('Need at least 2 players to start a hand');\n      }\n\n      this.gameState.moveButton();\n\n      // Ensure deck is properly reset and has cards\n      this.deck.reset();\n      if (this.deck.cardsRemaining() < 20) {\n        throw new Error('Deck has insufficient cards');\n      }\n\n      this.postBlinds();\n      this.dealHoleCards();\n\n      this.gameState.currentPlayerIndex = this.gameState.getUTGPosition();\n\n      this.notifyStateChange();\n      this.notifyPhaseChange();\n    } catch (error) {\n      this._isRestarting = false; // Reset the flag on error\n      throw error; // Re-throw to be caught by ErrorBoundary\n    }\n  }\n\n  postBlinds() {\n    const smallBlindPosition = this.gameState.getSmallBlindPosition();\n    const bigBlindPosition = this.gameState.getBigBlindPosition();\n\n    const smallBlindPlayer = this.gameState.getPlayerByPosition(smallBlindPosition);\n    const bigBlindPlayer = this.gameState.getPlayerByPosition(bigBlindPosition);\n\n    if (smallBlindPlayer && smallBlindPlayer.chips > 0) {\n      const sbAmount = Math.min(this.gameState.blinds.small, smallBlindPlayer.chips);\n      smallBlindPlayer.placeBet(sbAmount);\n      this.gameState._internalPot.main += sbAmount;\n\n      this.gameState.addToHistory({\n        playerId: smallBlindPlayer.id,\n        playerName: smallBlindPlayer.name,\n        _action: 'small-blind',\n        amount: sbAmount,\n      });\n    }\n\n    if (bigBlindPlayer && bigBlindPlayer.chips > 0) {\n      const bbAmount = Math.min(this.gameState.blinds.big, bigBlindPlayer.chips);\n      bigBlindPlayer.placeBet(bbAmount);\n      this.gameState._internalPot.main += bbAmount;\n      this.gameState.currentBet = bbAmount;\n\n      this.gameState.addToHistory({\n        playerId: bigBlindPlayer.id,\n        playerName: bigBlindPlayer.name,\n        _action: 'big-blind',\n        amount: bbAmount,\n      });\n    }\n  }\n\n  dealHoleCards() {\n    const activePlayers = this.gameState.getActivePlayers();\n\n    for (let i = 0; i < 2; i++) {\n      for (const player of activePlayers) {\n        const card = this.deck.dealCard();\n        player.holeCards.push(card);\n      }\n    }\n  }\n\n  dealCommunityCards(count) {\n    const cards = this.deck.dealCards(count);\n    this.gameState.communityCards.push(...cards);\n    this.notifyStateChange();\n  }\n\n  /**\n   * Executes a player action (fold, call, raise, check, all-in).\n   * Validates the action, updates game state, and advances the game.\n   *\n   * @param {string} playerId - The unique identifier of the acting player\n   * @param {string} _action - The action to execute ('fold', 'call', 'raise', 'check', 'all-in')\n   * @param {number} [amount=0] - The amount for betting actions (required for 'raise')\n   * @throws {Error} If player not found, cannot act, or action is invalid\n   * @example\n   * gameEngine.executePlayerAction('player1', 'raise', 100);\n   * gameEngine.executePlayerAction('player2', 'fold');\n   * gameEngine.executePlayerAction('player3', 'call');\n   */\n  executePlayerAction(playerId, _action, amount = 0) {\n    try {\n      // Enhanced validation\n      if (!this.gameState || !this.gameState.players) {\n        throw new Error('Game state not initialized');\n      }\n\n      const player = this.gameState.players.find((p) => p && p.id === playerId);\n      if (!player) {\n        // eslint-disable-next-line no-console\n        console.error(\n          'Available players:',\n          this.gameState.players.map((p) => (p ? p.id : 'null'))\n        );\n        throw new Error(`Player with ID '${playerId}' not found in game`);\n      }\n\n      // Check player can act\n      if (!player.canAct()) {\n        throw new Error(`Player '${player.name}' cannot act (status: ${player.status})`);\n      }\n\n      // Enhanced turn validation\n      const currentPlayer = this.gameState.players[this.gameState.currentPlayerIndex];\n      if (!currentPlayer) {\n        throw new Error(`No current player at index ${this.gameState.currentPlayerIndex}`);\n      }\n\n      if (currentPlayer.id !== playerId) {\n        throw new Error(`Not ${player.name}'s turn (current: ${currentPlayer.name})`);\n      }\n\n      BettingLogic.executeAction(this.gameState, player, _action, amount);\n\n      if (this.callbacks.onPlayerAction) {\n        this.callbacks.onPlayerAction(player, _action, amount);\n      }\n\n      // Immediately check for single player wins after any action\n      this.checkAndAdvanceGame();\n\n      // Return success result\n      return {\n        success: true,\n        action: _action,\n        amount,\n        playerId,\n      };\n    } catch (error) {\n      // Enhanced error logging\n      // eslint-disable-next-line no-console\n      console.error('GameEngine executePlayerAction error:', {\n        playerId,\n        _action,\n        amount,\n        gameStateExists: !!this.gameState,\n        playersCount: this.gameState?.players?.length || 0,\n        currentPlayerIndex: this.gameState?.currentPlayerIndex,\n        error: error.message,\n      });\n\n      // Return error result instead of throwing\n      return {\n        success: false,\n        error: error.message,\n        action: _action,\n        amount,\n        playerId,\n      };\n    }\n  }\n\n  checkAndAdvanceGame() {\n    // Get active players (not folded, not sitting out, includes all-in)\n    const activePlayers = this.gameState.getActivePlayers();\n\n    // Single player win: only one active player remaining\n    if (activePlayers.length === 1) {\n      this.handleSinglePlayerWin();\n      return;\n    }\n\n    // Check if all players have folded except one\n    const playersInHand = this.gameState.getPlayersInHand();\n    if (playersInHand.length === 1) {\n      this.handleSinglePlayerWin();\n      return;\n    }\n\n    if (playersInHand.length === 0) {\n      // Edge case: no players in hand (shouldn't happen)\n      this.gameState.phase = 'waiting';\n      this.notifyStateChange();\n      return;\n    }\n\n    // Count players who can still act (not folded, not all-in)\n    const playersWhoCanAct = this.gameState.players.filter((p) => p.canAct());\n\n    // If no one can act but multiple players in hand, all remaining are all-in\n    // Skip directly to showdown\n    if (playersWhoCanAct.length === 0 && playersInHand.length >= 2) {\n      while (this.gameState.phase !== GAME_PHASES.SHOWDOWN) {\n        this.advanceToNextPhase();\n      }\n      return;\n    }\n\n    // Continue normal betting flow\n    if (BettingLogic.isBettingRoundComplete(this.gameState)) {\n      this.advanceToNextPhase();\n    } else {\n      this.moveToNextPlayer();\n    }\n\n    this.notifyStateChange();\n  }\n\n  moveToNextPlayer() {\n    // Count players who can still act (using canAct() method)\n    const activePlayersCount = this.gameState.players.filter((p) => p.canAct()).length;\n\n    // If only 0 or 1 active players remain, everyone else is all-in or folded\n    // We should go directly to showdown\n    if (activePlayersCount <= 1) {\n      // Skip to showdown by advancing through all remaining phases\n      while (this.gameState.phase !== GAME_PHASES.SHOWDOWN) {\n        this.advanceToNextPhase();\n      }\n      return;\n    }\n\n    this.gameState.currentPlayerIndex = this.gameState.getNextActivePlayerIndex(\n      this.gameState.currentPlayerIndex\n    );\n\n    if (this.gameState.currentPlayerIndex === -1) {\n      this.advanceToNextPhase();\n    }\n  }\n\n  advanceToNextPhase() {\n    this.resetBettingRound();\n\n    switch (this.gameState.phase) {\n      case GAME_PHASES.PREFLOP:\n        this.gameState.phase = GAME_PHASES.FLOP;\n        this.dealCommunityCards(3);\n        break;\n\n      case GAME_PHASES.FLOP:\n        this.gameState.phase = GAME_PHASES.TURN;\n        this.dealCommunityCards(1);\n        break;\n\n      case GAME_PHASES.TURN:\n        this.gameState.phase = GAME_PHASES.RIVER;\n        this.dealCommunityCards(1);\n        break;\n\n      case GAME_PHASES.RIVER:\n        this.handleShowdown();\n        return;\n    }\n\n    // Find next player who can act\n    const dealerPosition = this.gameState.dealerPosition;\n    this.gameState.currentPlayerIndex = this.gameState.getNextActivePlayerIndex(dealerPosition);\n\n    // If no one can act (everyone is all-in or folded), advance to next phase\n    // This handles the case where all remaining players are all-in\n    if (this.gameState.currentPlayerIndex === -1) {\n      // Check if we should go to showdown (multiple players in hand but none can act)\n      const playersInHand = this.gameState.getPlayersInHand();\n      if (playersInHand.length >= 2) {\n        // Multiple players but no one can act - skip to showdown\n        this.advanceToNextPhase();\n        return;\n      }\n    }\n\n    this.notifyPhaseChange();\n    this.notifyStateChange();\n  }\n\n  resetBettingRound() {\n    this.gameState.currentBet = 0;\n    this.gameState.minimumRaise = this.gameState.blinds.big;\n    this.gameState.lastRaiserIndex = null;\n\n    this.gameState.players.forEach((player) => {\n      player._currentBet = 0;\n      player.lastAction = null;\n    });\n  }\n\n  handleSinglePlayerWin() {\n    const playersInHand = this.gameState.getPlayersInHand();\n    if (playersInHand.length !== 1) {\n      // Invalid state - multiple players in hand\n      return;\n    }\n\n    const winner = playersInHand[0];\n    this.gameState.calculateSidePots();\n\n    const totalPot = this.gameState.getTotalPot();\n    winner.winPot(totalPot);\n\n    this.gameState.winners = [\n      {\n        player: winner,\n        amount: totalPot,\n        handDescription: 'Won by default (others folded)',\n      },\n    ];\n\n    // eslint-disable-next-line no-console\n    // Winner determined by fold\n    this.completeHand();\n  }\n\n  handleShowdown() {\n    this.gameState.phase = GAME_PHASES.SHOWDOWN;\n    this.gameState.calculateSidePots();\n\n    const playerHands = this.gameState.getPlayersInHand().map((player) => ({\n      player,\n      cards: [...player.holeCards, ...this.gameState.communityCards],\n    }));\n\n    const mainPotWinners = HandEvaluator.findWinners(playerHands);\n    const mainPotAmount = this.gameState._internalPot.main;\n    const mainPotShare = Math.floor(mainPotAmount / mainPotWinners.length);\n\n    this.gameState.winners = [];\n\n    mainPotWinners.forEach(({ player, hand }) => {\n      player.winPot(mainPotShare);\n      this.gameState.winners.push({\n        player,\n        amount: mainPotShare,\n        hand,\n        handDescription: hand.description,\n      });\n    });\n\n    for (const sidePot of this.gameState._internalPot.side) {\n      const eligibleHands = playerHands.filter(({ player }) =>\n        sidePot.eligiblePlayers.includes(player)\n      );\n\n      const sidePotWinners = HandEvaluator.findWinners(eligibleHands);\n      const sidePotShare = Math.floor(sidePot.amount / sidePotWinners.length);\n\n      sidePotWinners.forEach(({ player, hand }) => {\n        player.winPot(sidePotShare);\n\n        const existingWinner = this.gameState.winners.find((w) => w.player === player);\n        if (existingWinner) {\n          existingWinner.amount += sidePotShare;\n        } else {\n          this.gameState.winners.push({\n            player,\n            amount: sidePotShare,\n            hand,\n            handDescription: hand.description,\n          });\n        }\n      });\n    }\n\n    if (this.callbacks.onShowdown) {\n      this.callbacks.onShowdown(this.gameState.winners);\n    }\n\n    this.completeHand();\n  }\n\n  completeHand() {\n    if (this.callbacks.onHandComplete) {\n      this.callbacks.onHandComplete(this.gameState.winners);\n    }\n\n    // Store winners before resetting\n    const winners = this.gameState.winners;\n\n    // Reset phase to waiting after hand completion\n    this.gameState.phase = 'waiting';\n    this.notifyStateChange();\n\n    // Auto-progress to next hand after 3 seconds\n    setTimeout(() => {\n      try {\n        // Check if we still have enough players with chips\n        const playersWithChips = this.gameState.players.filter((p) => p.isActive && p.chips > 0);\n\n        if (playersWithChips.length >= 2 && !this._isRestarting) {\n          this.startNewHand();\n        }\n      } catch (error) {\n        // eslint-disable-next-line no-console\n        console.error('Failed to auto-start new hand:', error);\n        this._isRestarting = false;\n      }\n    }, 3000);\n\n    // Return the winners info\n    return {\n      winners,\n    };\n  }\n\n  /**\n   * Gets the list of valid actions for a specific player.\n   *\n   * @param {string} playerId - The unique identifier of the player\n   * @returns {string[]} Array of valid action names ('fold', 'call', 'raise', 'check', 'all-in')\n   * @example\n   * const actions = gameEngine.getValidActions('player1');\n   * // Returns: ['fold', 'call', 'raise']\n   */\n  getValidActions(playerId) {\n    // Enhanced validation for getting valid actions\n    if (!this.gameState || !this.gameState.players) {\n      // eslint-disable-next-line no-console\n      console.warn('getValidActions: No game state or players');\n      return [];\n    }\n\n    const player = this.gameState.players.find((p) => p && p.id === playerId);\n    if (!player) {\n      // eslint-disable-next-line no-console\n      console.warn(`getValidActions: Player '${playerId}' not found`);\n      return [];\n    }\n\n    const currentPlayer = this.getCurrentPlayer();\n    if (!currentPlayer) {\n      // eslint-disable-next-line no-console\n      console.warn('getValidActions: No current player');\n      return [];\n    }\n\n    if (currentPlayer.id !== playerId) {\n      // This is normal - player is not currently acting\n      return [];\n    }\n\n    // Player can act - get valid actions from betting logic\n    try {\n      return BettingLogic.getValidActions(this.gameState, player);\n    } catch (error) {\n      // eslint-disable-next-line no-console\n      console.error('getValidActions: Error getting valid actions:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Gets the current serialized game state.\n   * Returns a snapshot of the game state suitable for UI rendering.\n   *\n   * @returns {Object} Serialized game state object containing players, pot, cards, phase, etc.\n   * @example\n   * const state = gameEngine.getGameState();\n   * console.log(`Current phase: ${state.phase}, Pot: ${state.pot.main}`);\n   */\n  getGameState() {\n    return this.gameState.serialize();\n  }\n\n  notifyStateChange() {\n    if (this.callbacks.onStateChange) {\n      this.callbacks.onStateChange(this.getGameState());\n    }\n  }\n\n  notifyPhaseChange() {\n    if (this.callbacks.onPhaseChange) {\n      this.callbacks.onPhaseChange(this.gameState.phase);\n    }\n  }\n\n  /**\n   * Sets the blind amounts for the game.\n   *\n   * @param {number} small - The small blind amount\n   * @param {number} big - The big blind amount\n   * @example\n   * gameEngine.setBlinds(10, 20); // Sets small blind to 10, big blind to 20\n   */\n  setBlinds(small, big) {\n    this.gameState.blinds = { small, big };\n    this.gameState.minimumRaise = big;\n  }\n\n  /**\n   * Gets the hole cards for a specific player.\n   *\n   * @param {string} playerId - The unique identifier of the player\n   * @returns {Card[]} Array of the player's hole cards (empty array if player not found)\n   * @example\n   * const cards = gameEngine.getPlayerCards('player1');\n   * // Returns: [Card{rank: 'A', suit: 's'}, Card{rank: 'K', suit: 'h'}]\n   */\n  getPlayerCards(playerId) {\n    const player = this.gameState.players.find((p) => p.id === playerId);\n    return player ? player.holeCards : [];\n  }\n\n  /**\n   * Gets the hole cards for all players in the game.\n   *\n   * @returns {Object[]} Array of objects containing playerId and cards\n   * @example\n   * const allCards = gameEngine.getAllPlayerCards();\n   * // Returns: [{playerId: 'player1', cards: [Card, Card]}, ...]\n   */\n  getAllPlayerCards() {\n    return this.gameState.players.map((player) => ({\n      playerId: player.id,\n      cards: player.holeCards,\n    }));\n  }\n\n  /**\n   * Gets a copy of the community cards currently on the board.\n   *\n   * @returns {Card[]} Array of community cards (0-5 cards depending on game phase)\n   * @example\n   * const board = gameEngine.getCommunityCards();\n   * // Returns: [Card, Card, Card] on the flop\n   */\n  getCommunityCards() {\n    return [...this.gameState.communityCards];\n  }\n\n  /**\n   * Gets the player who is currently acting.\n   *\n   * @returns {Player|undefined} The current player object, or undefined if no current player\n   * @example\n   * const currentPlayer = gameEngine.getCurrentPlayer();\n   * console.log(`${currentPlayer.name} is up to act`);\n   */\n  getCurrentPlayer() {\n    // Enhanced safety checks for current player access\n    if (!this.gameState || !this.gameState.players || this.gameState.players.length === 0) {\n      return undefined;\n    }\n\n    const index = this.gameState.currentPlayerIndex;\n    if (index < 0 || index >= this.gameState.players.length) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `Invalid currentPlayerIndex: ${index}, players length: ${this.gameState.players.length}`\n      );\n      return undefined;\n    }\n\n    const player = this.gameState.players[index];\n    if (!player) {\n      // eslint-disable-next-line no-console\n      console.warn(`No player found at index: ${index}`);\n      return undefined;\n    }\n\n    return player;\n  }\n\n  /**\n   * Calculates pot odds for a specific player's current situation.\n   *\n   * @param {string} playerId - The unique identifier of the player\n   * @returns {number} Pot odds as a percentage (0-100), or 0 if player not found\n   * @example\n   * const odds = gameEngine.getPotOdds('player1');\n   * console.log(`Pot odds: ${odds.toFixed(1)}%`);\n   */\n  getPotOdds(playerId) {\n    const player = this.gameState.players.find((p) => p.id === playerId);\n    if (!player) return 0;\n\n    return BettingLogic.calculatePotOdds(this.gameState, player);\n  }\n}\n\nexport default GameEngine;\n","import { PLAYER_STATUS } from '../../constants/game-constants';\n\nclass Player {\n  constructor(id, name, chips, position = null, isAI = false, aiType = null) {\n    this.id = id;\n    this.name = name;\n    this.chips = chips;\n    this.position = position;\n    this._position = position; // Alias for compatibility\n\n    // Handle AI type parameter - if aiType is passed as 3rd parameter (old style)\n    if (typeof isAI === 'string') {\n      this.aiType = isAI;\n      this.isAI = true;\n    } else {\n      this.isAI = isAI;\n      this.aiType = aiType || undefined;\n    }\n\n    this.holeCards = [];\n    this.cards = this.holeCards; // Alias for compatibility\n    this.status = PLAYER_STATUS.WAITING;\n    this._currentBet = 0;\n    this.totalBetThisRound = 0; // Alias for currentBet\n    this.totalPotContribution = 0;\n    this.lastAction = null;\n\n    // Boolean properties for compatibility\n    this.isActive = true;\n    this.isFolded = false;\n    this.isAllIn = false;\n    this.isDealer = false;\n\n    this.stats = {\n      handsPlayed: 0,\n      handsWon: 0,\n      biggestPotWon: 0,\n      totalWinnings: 0,\n      vpip: 0,\n      pfr: 0,\n      aggression: 0,\n    };\n  }\n\n  setHoleCards(cards) {\n    this.holeCards = cards;\n    this.cards = this.holeCards; // Keep alias in sync\n  }\n\n  receiveCards(cards) {\n    this.setHoleCards(cards);\n  }\n\n  clearHoleCards() {\n    this.holeCards = [];\n    this.cards = this.holeCards; // Keep alias in sync\n  }\n\n  placeBet(amount) {\n    if (amount < 0) {\n      throw new Error('Bet amount cannot be negative');\n    }\n\n    if (amount > this.chips) {\n      throw new Error('Insufficient chips');\n    }\n\n    const betAmount = Math.min(amount, this.chips);\n    this.chips -= betAmount;\n    this._currentBet += betAmount;\n    this.totalBetThisRound += betAmount;\n    this.totalPotContribution += betAmount;\n\n    if (this.chips === 0) {\n      this.status = PLAYER_STATUS.ALL_IN;\n      this.isAllIn = true;\n    }\n\n    return betAmount;\n  }\n\n  fold() {\n    this.status = PLAYER_STATUS.FOLDED;\n    this.lastAction = 'fold';\n    this.isFolded = true;\n    this.clearHoleCards();\n  }\n\n  check() {\n    this.lastAction = 'check';\n    this.status = PLAYER_STATUS.CHECKED;\n  }\n\n  call(amount) {\n    // Handle all-in case - call with all remaining chips if not enough\n    const callAmount = amount > this.chips ? this.chips : amount;\n    const actualAmount = this.placeBet(callAmount);\n    this.lastAction = 'call';\n\n    // If player used all chips, they're all-in, otherwise they called\n    if (this.chips === 0) {\n      this.status = PLAYER_STATUS.ALL_IN;\n    } else {\n      this.status = PLAYER_STATUS.CALLED;\n    }\n\n    return actualAmount;\n  }\n\n  bet(amount) {\n    const betAmount = this.placeBet(amount);\n    this.lastAction = 'bet';\n    return betAmount;\n  }\n\n  raise(amount) {\n    if (amount <= this._currentBet) {\n      throw new Error('Raise amount must be greater than current bet');\n    }\n\n    // Calculate the additional amount to raise to the target\n    const additionalAmount = amount - this._currentBet;\n    const raiseAmount = this.placeBet(additionalAmount);\n    this.lastAction = 'raise';\n    this.status = PLAYER_STATUS.RAISED;\n    return raiseAmount;\n  }\n\n  winPot(amount) {\n    if (amount < 0) {\n      throw new Error('Win amount cannot be negative');\n    }\n\n    this.chips += amount;\n    this.stats.handsWon++;\n    this.stats.totalWinnings += amount;\n\n    if (amount > this.stats.biggestPotWon) {\n      this.stats.biggestPotWon = amount;\n    }\n  }\n\n  resetForNewHand() {\n    this.clearHoleCards();\n    this.status = PLAYER_STATUS.WAITING;\n    this._currentBet = 0;\n    this.totalBetThisRound = 0;\n    this.totalPotContribution = 0;\n    this.lastAction = null;\n    this.isActive = true; // Players should be active and ready to act\n    this.isFolded = false;\n    this.isAllIn = false;\n    this.stats.handsPlayed++;\n  }\n\n  resetBettingRound() {\n    this._currentBet = 0;\n    this.totalBetThisRound = 0;\n\n    // Don't reset folded or all-in status\n    if (this.status !== PLAYER_STATUS.FOLDED && this.status !== PLAYER_STATUS.ALL_IN) {\n      this.status = PLAYER_STATUS.WAITING;\n    }\n  }\n\n  checkIfActive() {\n    return this.status === PLAYER_STATUS.ACTIVE || this.status === PLAYER_STATUS.ALL_IN;\n  }\n\n  canAct() {\n    return (\n      this.isActive &&\n      this.chips > 0 &&\n      this.status !== PLAYER_STATUS.FOLDED &&\n      this.status !== PLAYER_STATUS.ALL_IN\n    );\n  }\n\n  isInHand() {\n    return (\n      this.isActive &&\n      this.status !== PLAYER_STATUS.FOLDED &&\n      this.status !== PLAYER_STATUS.SITTING_OUT\n    );\n  }\n\n  decideAction(gameState) {\n    // This method should only be called for AI players\n    if (!this.isAI) {\n      throw new Error('decideAction can only be called on AI players');\n    }\n\n    // Import AIPlayer service dynamically to avoid circular dependencies\n    const AIPlayer = require('../engine/AIPlayer').default;\n    const BettingLogic = require('../engine/BettingLogic').default;\n\n    // Get valid actions for this player\n    const validActions = BettingLogic.getValidActions(gameState, this);\n\n    // Get AI decision\n    return AIPlayer.getAction(this, gameState, validActions, {\n      getPlayerCards: () => this.holeCards,\n      getCommunityCards: () => gameState.communityCards,\n    });\n  }\n\n  toJSON() {\n    return {\n      id: this.id,\n      name: this.name,\n      chips: this.chips,\n      _currentBet: this._currentBet,\n      _position: this._position,\n      cards: this.cards,\n      isAI: this.isAI,\n      aiType: this.aiType,\n      status: this.status,\n      isActive: this.isActive,\n      isFolded: this.isFolded,\n      isAllIn: this.isAllIn,\n      isDealer: this.isDealer,\n      totalBetThisRound: this.totalBetThisRound,\n    };\n  }\n\n  getNetPosition() {\n    return this.chips - this.totalPotContribution;\n  }\n\n  updateStats(_action, phase) {\n    if (phase === 'preflop' && _action !== 'fold') {\n      this.stats.vpip++;\n    }\n\n    if (phase === 'preflop' && (_action === 'bet' || _action === 'raise')) {\n      this.stats.pfr++;\n    }\n\n    if (_action === 'bet' || _action === 'raise') {\n      this.stats.aggression++;\n    }\n  }\n\n  serialize() {\n    return {\n      id: this.id,\n      name: this.name,\n      chips: this.chips,\n      position: this.position,\n      isAI: this.isAI,\n      aiType: this.aiType,\n      status: this.status,\n      currentBet: this._currentBet,\n      lastAction: this.lastAction,\n      hasCards: this.holeCards.length > 0,\n      holeCards: this.isAI\n        ? null\n        : this.holeCards.map((card) => ({ rank: card.rank, suit: card.suit })),\n    };\n  }\n\n  get currentBet() {\n    return this._currentBet;\n  }\n\n  set currentBet(value) {\n    this._currentBet = value;\n  }\n}\n\nexport default Player;\n","import { useState, useEffect, useCallback, useMemo, useRef } from 'react';\n\nimport { GAME_PHASES } from '../constants/game-constants';\nimport AIPlayer from '../game/engine/AIPlayer';\nimport GameEngine from '../game/engine/GameEngine';\nimport Player from '../game/entities/Player';\n\nimport useHandHistory from './useHandHistory';\n\n/**\n * Custom hook for managing poker game state and logic\n * @param {string} humanPlayerId - ID of the human player\n * @param {Object} options - Configuration options\n * @returns {Object} Game state and control functions\n */\nconst usePokerGame = (humanPlayerId, options = {}) => {\n  const {\n    initialChips = 10000,\n    smallBlind = 50,\n    bigBlind = 100,\n    aiPlayers = [\n      { name: 'Alex (TAG)', type: 'tight-aggressive' },\n      { name: 'Sarah (LAG)', type: 'loose-aggressive' },\n      { name: 'Mike (TP)', type: 'tight-passive' },\n      { name: 'Lisa (LP)', type: 'loose-passive' },\n      { name: 'John (TAG)', type: 'tight-aggressive' },\n    ],\n    onStateChange,\n    onShowdown,\n    onPhaseChange,\n    onPlayerAction,\n  } = options;\n\n  const [gameEngine] = useState(() => new GameEngine());\n  const [gameState, setGameState] = useState(null);\n  const [showControls, setShowControls] = useState(false);\n  const [validActions, setValidActions] = useState([]);\n  const [showdown, setShowdown] = useState(false);\n  const [isProcessingAI, setIsProcessingAI] = useState(false);\n  const [error, setError] = useState(null);\n  const [isGameActive, setIsGameActive] = useState(false);\n\n  // Use ref to track processing state to avoid stale closure issues\n  const isProcessingRef = useRef(false);\n  const gameEngineRef = useRef(gameEngine);\n\n  // Initialize hand history tracking\n  const handHistory = useHandHistory();\n\n  // Process a single AI turn and return whether to continue\n  const processSingleAITurn = useCallback(() => {\n    const engine = gameEngineRef.current;\n\n    // Check game phase - don't process during waiting or showdown\n    const currentGameState = engine.getGameState();\n    if (currentGameState.phase === 'waiting' || currentGameState.phase === 'showdown') {\n      return false;\n    }\n\n    const currentPlayer = engine.getCurrentPlayer();\n\n    // Check if we should process this player\n    if (!currentPlayer || !currentPlayer.isAI) {\n      return false;\n    }\n\n    // Use canAct() method to check if player can act (not folded, not all-in, has chips)\n    if (!currentPlayer.canAct()) {\n      return false;\n    }\n\n    // Get valid actions for this AI\n    const actions = engine.getValidActions(currentPlayer.id);\n\n    // If no valid actions, player can't act\n    if (!actions || actions.length === 0) {\n      return false;\n    }\n\n    const aiAction = AIPlayer.getAction(currentPlayer, currentGameState, actions, engine);\n\n    const result = engine.executePlayerAction(currentPlayer.id, aiAction.action, aiAction.amount);\n\n    if (!result.success) {\n      // eslint-disable-next-line no-console\n      console.error('AI action failed:', result.error);\n      return false;\n    }\n\n    // Check if game ended (e.g., everyone else folded)\n    const updatedState = engine.getGameState();\n    if (updatedState.phase === 'waiting' || updatedState.phase === 'showdown') {\n      return false;\n    }\n\n    // Check if next player is also AI and can act\n    const nextPlayer = engine.getCurrentPlayer();\n    return nextPlayer && nextPlayer.isAI && nextPlayer.canAct();\n  }, []);\n\n  // Process all AI turns in sequence\n  const processAITurns = useCallback(() => {\n    // Strict guard - only one processing chain at a time\n    if (isProcessingRef.current) {\n      return;\n    }\n\n    const engine = gameEngineRef.current;\n\n    // Check game phase - don't process during waiting or showdown\n    const currentGameState = engine.getGameState();\n    if (currentGameState.phase === 'waiting' || currentGameState.phase === 'showdown') {\n      return;\n    }\n\n    const currentPlayer = engine.getCurrentPlayer();\n\n    // Only start if it's actually an AI's turn and they can act\n    if (!currentPlayer || !currentPlayer.isAI || !currentPlayer.canAct()) {\n      return;\n    }\n\n    // Lock processing\n    isProcessingRef.current = true;\n    setIsProcessingAI(true);\n\n    // Process AI turns with delays between each\n    const processNext = () => {\n      try {\n        const shouldContinue = processSingleAITurn();\n\n        if (shouldContinue) {\n          // More AI to process - continue after delay\n          setTimeout(processNext, 800);\n        } else {\n          // Done processing - unlock\n          isProcessingRef.current = false;\n          setIsProcessingAI(false);\n        }\n      } catch (err) {\n        // eslint-disable-next-line no-console\n        console.error('AI processing error:', err);\n        setError(`AI action failed: ${err.message}`);\n        isProcessingRef.current = false;\n        setIsProcessingAI(false);\n      }\n    };\n\n    // Start processing after initial delay\n    setTimeout(processNext, 800);\n  }, [processSingleAITurn]);\n\n  // Initialize game with players\n  const initializeGame = useCallback(() => {\n    try {\n      const engine = gameEngineRef.current;\n\n      // Prevent multiple initializations\n      if (engine._isInitialized) {\n        return;\n      }\n\n      engine._isInitialized = true;\n\n      // Add human player\n      const humanPlayer = new Player(humanPlayerId, 'You', initialChips, 0, false);\n      engine.addPlayer(humanPlayer);\n\n      // Add AI players\n      aiPlayers.forEach((aiConfig, idx) => {\n        const aiPlayer = new Player(\n          `ai-${idx + 1}`,\n          aiConfig.name,\n          initialChips,\n          idx + 1,\n          true,\n          aiConfig.type\n        );\n        engine.addPlayer(aiPlayer);\n      });\n\n      engine.setBlinds(smallBlind, bigBlind);\n\n      // Start first hand after a delay\n      setTimeout(() => {\n        try {\n          setIsGameActive(true);\n          engine.startNewHand();\n        } catch (err) {\n          setError(`Failed to start new hand: ${err.message}`);\n          engine._isInitialized = false;\n          setIsGameActive(false);\n        }\n      }, 1000);\n    } catch (err) {\n      setError(`Failed to initialize game: ${err.message}`);\n      gameEngineRef.current._isInitialized = false;\n    }\n  }, [humanPlayerId, initialChips, smallBlind, bigBlind, aiPlayers]);\n\n  // Initialize game callbacks\n  useEffect(() => {\n    const engine = gameEngineRef.current;\n\n    // Prevent duplicate callback setup\n    if (engine._callbacksInitialized) {\n      return;\n    }\n    engine._callbacksInitialized = true;\n\n    engine.setCallback('onStateChange', (newState) => {\n      // Add timestamp to ensure React sees a new object reference\n      const stateWithTimestamp = {\n        ...newState,\n        _updateTimestamp: Date.now(),\n      };\n      setGameState(stateWithTimestamp);\n      setError(null);\n\n      // Use getCurrentPlayer() from engine for most up-to-date info\n      const currentPlayer = engine.getCurrentPlayer();\n      if (currentPlayer && currentPlayer.id === humanPlayerId) {\n        const actions = engine.getValidActions(humanPlayerId);\n        setValidActions(actions);\n        setShowControls(true);\n      } else {\n        setShowControls(false);\n        setValidActions([]);\n      }\n\n      if (onStateChange) {\n        onStateChange(newState);\n      }\n    });\n\n    engine.setCallback('onShowdown', (winners) => {\n      setShowdown(true);\n      setTimeout(() => setShowdown(false), 5000);\n\n      if (onShowdown) {\n        onShowdown(winners);\n      }\n    });\n\n    engine.setCallback('onPhaseChange', (phase) => {\n      if (phase !== GAME_PHASES.SHOWDOWN) {\n        setShowdown(false);\n      }\n\n      if (onPhaseChange) {\n        onPhaseChange(phase);\n      }\n    });\n\n    engine.setCallback('onPlayerAction', (player, action, amount) => {\n      // Capture action in hand history\n      if (isGameActive && handHistory.isSessionActive) {\n        handHistory.captureAction(player.id, action, amount);\n      }\n\n      if (onPlayerAction) {\n        onPlayerAction(player, action, amount);\n      }\n    });\n\n    initializeGame();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [humanPlayerId, initializeGame]);\n\n  // Handle human player action\n  const executeAction = useCallback(\n    (action, amount) => {\n      try {\n        setError(null);\n        const engine = gameEngineRef.current;\n        const result = engine.executePlayerAction(humanPlayerId, action, amount);\n\n        // Check if action succeeded\n        if (!result.success) {\n          setError(`Action failed: ${result.error}`);\n          return;\n        }\n\n        // Reset processing flag to ensure fresh start for AI turns\n        isProcessingRef.current = false;\n\n        // Process AI turns after human action (with delay)\n        // Using a longer delay to ensure state has propagated\n        setTimeout(() => {\n          // Double-check current player is AI before processing\n          const currentPlayer = engine.getCurrentPlayer();\n          if (currentPlayer && currentPlayer.isAI && currentPlayer.canAct()) {\n            processAITurns();\n          }\n        }, 600);\n      } catch (err) {\n        setError(`Action failed: ${err.message}`);\n      }\n    },\n    [humanPlayerId, processAITurns]\n  );\n\n  // Get current player info (memoized for performance)\n  const getCurrentPlayerInfo = useMemo(() => {\n    if (!gameState || !gameState.players || gameState.players.length === 0) {\n      return { humanPlayer: null, currentPlayer: null, isHumanTurn: false };\n    }\n\n    const humanPlayer = gameState.players.find((p) => p && p.id === humanPlayerId);\n\n    // Safe player access with bounds checking\n    const currentPlayer =\n      gameState.currentPlayerIndex >= 0 && gameState.currentPlayerIndex < gameState.players.length\n        ? gameState.players[gameState.currentPlayerIndex]\n        : null;\n\n    const isHumanTurn = currentPlayer && humanPlayer && currentPlayer.id === humanPlayer.id;\n\n    return {\n      humanPlayer,\n      currentPlayer,\n      isHumanTurn,\n    };\n  }, [gameState, humanPlayerId]);\n\n  // Auto-process AI turns when it's their turn (with debounce)\n  useEffect(() => {\n    if (!gameState) return;\n\n    // Don't start if already processing\n    if (isProcessingRef.current) {\n      return;\n    }\n\n    // Skip if in waiting or showdown phase\n    if (gameState.phase === 'waiting' || gameState.phase === 'showdown') {\n      return;\n    }\n\n    const engine = gameEngineRef.current;\n    const currentPlayer = engine.getCurrentPlayer();\n\n    // Check if current player is AI and can act\n    if (currentPlayer && currentPlayer.isAI && currentPlayer.canAct()) {\n      // Use timeout to debounce and prevent race conditions\n      const timeoutId = setTimeout(() => {\n        // Double-check conditions before processing\n        if (!isProcessingRef.current) {\n          const stillCurrentPlayer = engine.getCurrentPlayer();\n          if (stillCurrentPlayer && stillCurrentPlayer.isAI && stillCurrentPlayer.canAct()) {\n            processAITurns();\n          }\n        }\n      }, 150);\n\n      return () => clearTimeout(timeoutId);\n    }\n  }, [gameState, processAITurns]);\n\n  return {\n    // State\n    gameState,\n    showControls,\n    validActions,\n    showdown,\n    isProcessingAI,\n    error,\n    isGameActive,\n\n    // Functions\n    executeAction,\n    getCurrentPlayerInfo,\n\n    // Engine reference (for advanced features)\n    gameEngine,\n\n    // Human player ID\n    humanPlayerId,\n\n    // Hand history\n    handHistory,\n  };\n};\n\nexport default usePokerGame;\n","import React, { useState, useEffect, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport './BettingControls.css';\n\nconst BettingControls = React.memo(\n  ({ validActions, _currentBet, playerChips, playerBet, _pot, onAction, minBet, minRaise }) => {\n    const callAmount = Math.max(0, (_currentBet || 0) - (playerBet || 0));\n    const [betAmount, setBetAmount] = useState(minBet || minRaise || 0);\n\n    useEffect(() => {\n      if (validActions.includes('bet')) {\n        setBetAmount(minBet);\n      } else if (validActions.includes('raise')) {\n        setBetAmount(minRaise);\n      }\n    }, [validActions, minBet, minRaise]);\n\n    const handleSliderChange = useCallback((e) => {\n      setBetAmount(parseInt(e.target.value));\n    }, []);\n\n    const handleInputChange = useCallback(\n      (e) => {\n        const value = parseInt(e.target.value) || 0;\n        setBetAmount(Math.min(value, playerChips));\n      },\n      [playerChips]\n    );\n\n    const setPresetBet = useCallback(\n      (fraction) => {\n        let amount;\n        if (fraction === 'all') {\n          amount = playerChips || 0;\n        } else {\n          amount = Math.floor((_pot || 0) * fraction);\n        }\n\n        if (validActions.includes('bet')) {\n          amount = Math.max(amount, minBet || 0);\n        } else if (validActions.includes('raise')) {\n          amount = Math.max(amount, minRaise || 0);\n        }\n\n        setBetAmount(Math.min(amount, playerChips || 0));\n      },\n      [_pot, playerChips, minBet, minRaise, validActions]\n    );\n\n    const getPotOdds = () => {\n      if (callAmount === 0) return null;\n      const potAfterCall = (_pot || 0) + callAmount;\n      if (potAfterCall === 0) return null;\n      const odds = ((callAmount / potAfterCall) * 100).toFixed(1);\n      return odds;\n    };\n\n    const potOdds = getPotOdds();\n\n    return (\n      <div\n        className=\"betting-controls\"\n        role=\"region\"\n        aria-label=\"Betting controls\"\n        aria-describedby=\"betting-info pot-odds\"\n      >\n        <div className=\"betting-info\" id=\"betting-info\" role=\"group\" aria-label=\"Game information\">\n          <div className=\"betting-info-item\">\n            <span className=\"betting-info-label\">Pot</span>\n            <span className=\"betting-info-value\">${_pot || 0}</span>\n          </div>\n          <div className=\"betting-info-item\">\n            <span className=\"betting-info-label\">To Call</span>\n            <span className=\"betting-info-value\">${callAmount || 0}</span>\n          </div>\n          <div className=\"betting-info-item\">\n            <span className=\"betting-info-label\">Your Stack</span>\n            <span className=\"betting-info-value\">${playerChips || 0}</span>\n          </div>\n        </div>\n\n        {(validActions.includes('bet') || validActions.includes('raise')) && (\n          <div className=\"betting-slider-container\" role=\"group\" aria-label=\"Bet amount controls\">\n            <div className=\"bet-amount-display\">\n              <label htmlFor=\"bet-amount-input\" className=\"bet-amount-label\">\n                {validActions.includes('bet') ? 'Bet Amount:' : 'Raise To:'}\n              </label>\n              <input\n                id=\"bet-amount-input\"\n                type=\"number\"\n                className=\"bet-amount-input\"\n                value={betAmount}\n                onChange={handleInputChange}\n                min={validActions.includes('bet') ? minBet : minRaise}\n                max={playerChips}\n                aria-describedby=\"bet-range-slider\"\n                aria-label={`${validActions.includes('bet') ? 'Bet' : 'Raise'} amount in dollars`}\n              />\n            </div>\n\n            <input\n              id=\"bet-range-slider\"\n              type=\"range\"\n              className=\"betting-slider\"\n              min={validActions.includes('bet') ? minBet : minRaise}\n              max={playerChips}\n              value={betAmount}\n              onChange={handleSliderChange}\n              aria-label={`Adjust ${validActions.includes('bet') ? 'bet' : 'raise'} amount with slider`}\n              aria-valuemin={validActions.includes('bet') ? minBet : minRaise}\n              aria-valuemax={playerChips}\n              aria-valuenow={betAmount}\n              aria-valuetext={`$${betAmount}`}\n            />\n\n            <div className=\"preset-buttons\" role=\"group\" aria-label=\"Preset bet amounts\">\n              <button\n                className=\"preset-button\"\n                onClick={() => setPresetBet(1 / 3)}\n                aria-label={`Set bet to one third of pot: $${Math.floor((_pot || 0) / 3)}`}\n              >\n                1/3 Pot\n              </button>\n              <button\n                className=\"preset-button\"\n                onClick={() => setPresetBet(1 / 2)}\n                aria-label={`Set bet to half of pot: $${Math.floor((_pot || 0) / 2)}`}\n              >\n                1/2 Pot\n              </button>\n              <button\n                className=\"preset-button\"\n                onClick={() => setPresetBet(1)}\n                aria-label={`Set bet to full pot: $${_pot || 0}`}\n              >\n                Pot\n              </button>\n              <button\n                className=\"preset-button\"\n                onClick={() => setPresetBet('all')}\n                aria-label={`Go all in with all chips: $${playerChips}`}\n              >\n                All In\n              </button>\n            </div>\n          </div>\n        )}\n\n        <div className=\"action-buttons\" role=\"group\" aria-label=\"Poker action buttons\">\n          {validActions.includes('fold') && (\n            <button\n              className=\"action-button fold\"\n              onClick={() => onAction('fold')}\n              aria-label=\"Fold your hand and forfeit this round\"\n              aria-describedby=\"betting-info\"\n            >\n              Fold\n            </button>\n          )}\n\n          {validActions.includes('check') && (\n            <button\n              className=\"action-button check\"\n              onClick={() => onAction('check')}\n              aria-label=\"Check - no bet required\"\n              aria-describedby=\"betting-info\"\n            >\n              Check\n            </button>\n          )}\n\n          {validActions.includes('call') && (\n            <button\n              className=\"action-button call\"\n              onClick={() => onAction('call', callAmount)}\n              aria-label={`Call the current bet of $${callAmount || 0}`}\n              aria-describedby=\"betting-info\"\n            >\n              Call ${callAmount || 0}\n            </button>\n          )}\n\n          {validActions.includes('bet') && (\n            <button\n              className=\"action-button bet\"\n              onClick={() => onAction('bet', betAmount)}\n              disabled={betAmount < minBet || betAmount > playerChips}\n              aria-label={`Bet $${betAmount}`}\n              aria-describedby=\"betting-info bet-amount-input\"\n              aria-disabled={betAmount < minBet || betAmount > playerChips}\n            >\n              Bet ${betAmount}\n            </button>\n          )}\n\n          {validActions.includes('raise') && (\n            <button\n              className=\"action-button raise\"\n              onClick={() => onAction('raise', betAmount)}\n              disabled={betAmount < minRaise || betAmount > playerChips}\n              aria-label={`Raise the bet to $${betAmount}`}\n              aria-describedby=\"betting-info bet-amount-input\"\n              aria-disabled={betAmount < minRaise || betAmount > playerChips}\n            >\n              Raise to ${betAmount}\n            </button>\n          )}\n\n          {validActions.includes('all-in') && (\n            <button\n              className=\"action-button all-in\"\n              onClick={() => onAction('all-in', playerChips)}\n              aria-label={`Go all in with all your chips: $${playerChips}`}\n              aria-describedby=\"betting-info\"\n            >\n              All In ${playerChips}\n            </button>\n          )}\n        </div>\n\n        {potOdds && (\n          <div\n            className=\"pot-odds-display\"\n            id=\"pot-odds\"\n            role=\"status\"\n            aria-live=\"polite\"\n            aria-label={`Pot odds: ${potOdds}% ${parseFloat(potOdds) < 30 ? 'This is a good betting opportunity' : ''}`}\n          >\n            Pot Odds: {potOdds}%\n            {parseFloat(potOdds) < 30 && (\n              <span className=\"pot-odds-good\" aria-label=\"Good betting odds\">\n                {' '}\n                (Good)\n              </span>\n            )}\n          </div>\n        )}\n      </div>\n    );\n  },\n  (prevProps, nextProps) => {\n    // Custom comparison for performance optimization\n    return (\n      JSON.stringify(prevProps.validActions) === JSON.stringify(nextProps.validActions) &&\n      prevProps._currentBet === nextProps._currentBet &&\n      prevProps.playerChips === nextProps.playerChips &&\n      prevProps.playerBet === nextProps.playerBet &&\n      prevProps._pot === nextProps._pot &&\n      prevProps.minBet === nextProps.minBet &&\n      prevProps.minRaise === nextProps.minRaise &&\n      prevProps.onAction === nextProps.onAction\n    );\n  }\n);\n\nBettingControls.displayName = 'BettingControls';\n\nBettingControls.propTypes = {\n  validActions: PropTypes.arrayOf(PropTypes.string).isRequired,\n  _currentBet: PropTypes.number,\n  playerChips: PropTypes.number.isRequired,\n  playerBet: PropTypes.number,\n  _pot: PropTypes.number,\n  onAction: PropTypes.func.isRequired,\n  minBet: PropTypes.number,\n  minRaise: PropTypes.number,\n};\n\nexport default BettingControls;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport './Card.css';\n\nconst Card = React.memo(\n  ({ card, size = 'normal', faceDown = false }) => {\n    if (!card && !faceDown) {\n      return <div className=\"card-placeholder\" aria-label=\"Empty card slot\" role=\"img\" />;\n    }\n\n    const getSuitSymbol = (suit) => {\n      const symbols = {\n        s: '',\n        h: '',\n        d: '',\n        c: '',\n      };\n      return symbols[suit] || '';\n    };\n\n    const getSuitClass = (suit) => {\n      const classes = {\n        s: 'spades',\n        h: 'hearts',\n        d: 'diamonds',\n        c: 'clubs',\n      };\n      return classes[suit] || '';\n    };\n\n    if (faceDown) {\n      return (\n        <div\n          className={`playing-card back ${size}`}\n          role=\"img\"\n          aria-label=\"Face-down playing card\"\n        />\n      );\n    }\n\n    const suitClass = getSuitClass(card.suit);\n    const suitSymbol = getSuitSymbol(card.suit);\n\n    const getSuitName = (suit) => {\n      const names = {\n        s: 'spades',\n        h: 'hearts',\n        d: 'diamonds',\n        c: 'clubs',\n      };\n      return names[suit] || '';\n    };\n\n    const getCardDescription = () => {\n      const suitName = getSuitName(card.suit);\n      return `${card.rank} of ${suitName}`;\n    };\n\n    return (\n      <div\n        className={`playing-card ${suitClass} ${size}`}\n        role=\"img\"\n        aria-label={getCardDescription()}\n      >\n        <div className=\"card-corner top-left\">\n          <span>{card.rank}</span>\n          <span className=\"card-corner-suit\">{suitSymbol}</span>\n        </div>\n\n        <div className=\"card-center\">\n          <div className=\"card-rank\">{card.rank}</div>\n          <div className=\"card-suit\">{suitSymbol}</div>\n        </div>\n\n        <div className=\"card-corner bottom-right\">\n          <span>{card.rank}</span>\n          <span className=\"card-corner-suit\">{suitSymbol}</span>\n        </div>\n      </div>\n    );\n  },\n  (prevProps, nextProps) =>\n    // Custom comparison function for better performance\n    prevProps.size === nextProps.size &&\n    prevProps.faceDown === nextProps.faceDown &&\n    prevProps.card?.rank === nextProps.card?.rank &&\n    prevProps.card?.suit === nextProps.card?.suit\n);\n\nCard.displayName = 'Card';\n\nCard.propTypes = {\n  card: PropTypes.shape({\n    rank: PropTypes.string.isRequired,\n    suit: PropTypes.string.isRequired,\n  }),\n  size: PropTypes.oneOf(['small', 'normal', 'large']),\n  faceDown: PropTypes.bool,\n};\n\nexport default Card;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport Card from './Card';\nimport './PlayerSeat.css';\n\nconst PlayerSeat = React.memo(\n  ({ player, isActive, isDealer, position, showCards }) => {\n    if (!player) {\n      return null;\n    }\n\n    const getPositionLabel = () => {\n      if (isDealer) return 'BTN';\n\n      const labels = {\n        'small-blind': 'SB',\n        'big-blind': 'BB',\n        'under-the-gun': 'UTG',\n        'middle-position': 'MP',\n        'cut-off': 'CO',\n      };\n\n      return labels[position] || '';\n    };\n\n    const formatChips = (amount) => {\n      if (amount >= 1000000) {\n        return `${(amount / 1000000).toFixed(1)}M`;\n      } else if (amount >= 1000) {\n        return `${(amount / 1000).toFixed(1)}K`;\n      }\n      return amount.toString();\n    };\n\n    const positionLabel = getPositionLabel();\n    const seatClasses = [\n      'player-seat',\n      `position-${player.position}`,\n      isActive ? 'active' : '',\n      player.status === 'folded' ? 'folded' : '',\n    ]\n      .filter(Boolean)\n      .join(' ');\n\n    return (\n      <div className={seatClasses}>\n        {positionLabel && <div className=\"position-label\">{positionLabel}</div>}\n\n        {player.status === 'all-in' && <div className=\"player-status-icon\">AI</div>}\n\n        <div className=\"player-info\">\n          <span className=\"player-name\">{player.name}</span>\n          <span className=\"player-chips\">${formatChips(player.chips)}</span>\n        </div>\n\n        <div className=\"player-cards\">\n          {player.holeCards && player.holeCards.length > 0 && player.status !== 'folded' ? (\n            <>\n              {showCards && player.holeCards ? (\n                player.holeCards.map((card, _index) => (\n                  <Card key={_index} card={card} size=\"small\" />\n                ))\n              ) : (\n                <>\n                  <Card faceDown size=\"small\" />\n                  <Card faceDown size=\"small\" />\n                </>\n              )}\n            </>\n          ) : null}\n        </div>\n\n        {player.currentBet > 0 && <div className=\"player-bet\">${player.currentBet}</div>}\n\n        {player.lastAction && (\n          <div className={`player-_action ${player.lastAction}`}>{player.lastAction}</div>\n        )}\n\n        {isActive && (\n          <div className=\"player-timer\">\n            <div className=\"player-timer-bar\" style={{ width: '100%' }} />\n          </div>\n        )}\n      </div>\n    );\n  },\n  (prevProps, nextProps) => {\n    // Custom comparison to prevent unnecessary re-renders\n    const prevPlayer = prevProps.player;\n    const nextPlayer = nextProps.player;\n\n    if (!prevPlayer && !nextPlayer) return true;\n    if (!prevPlayer || !nextPlayer) return false;\n\n    return (\n      prevProps.isActive === nextProps.isActive &&\n      prevProps.isDealer === nextProps.isDealer &&\n      prevProps.position === nextProps.position &&\n      prevProps.showCards === nextProps.showCards &&\n      prevPlayer.id === nextPlayer.id &&\n      prevPlayer.name === nextPlayer.name &&\n      prevPlayer.chips === nextPlayer.chips &&\n      prevPlayer.status === nextPlayer.status &&\n      prevPlayer.currentBet === nextPlayer.currentBet &&\n      prevPlayer.lastAction === nextPlayer.lastAction &&\n      prevPlayer.hasCards === nextPlayer.hasCards &&\n      JSON.stringify(prevPlayer.holeCards) === JSON.stringify(nextPlayer.holeCards)\n    );\n  }\n);\n\nPlayerSeat.displayName = 'PlayerSeat';\n\nPlayerSeat.propTypes = {\n  player: PropTypes.shape({\n    id: PropTypes.string.isRequired,\n    name: PropTypes.string.isRequired,\n    chips: PropTypes.number.isRequired,\n    position: PropTypes.number,\n    status: PropTypes.string,\n    currentBet: PropTypes.number,\n    lastAction: PropTypes.string,\n    holeCards: PropTypes.arrayOf(\n      PropTypes.shape({\n        rank: PropTypes.string,\n        suit: PropTypes.string,\n      })\n    ),\n    hasCards: PropTypes.bool,\n  }),\n  isActive: PropTypes.bool,\n  isDealer: PropTypes.bool,\n  position: PropTypes.string,\n  showCards: PropTypes.bool,\n};\n\nexport default PlayerSeat;\n","import PropTypes from 'prop-types';\nimport { useState, useEffect } from 'react';\n\nimport usePokerGame from '../../hooks/usePokerGame';\n\nimport BettingControls from './BettingControls';\nimport Card from './Card';\nimport PlayerSeat from './PlayerSeat';\nimport './PokerTable.css';\n\n/**\n * Poker Table Component\n * Main poker table component that handles game display and interaction\n */\nconst PokerTable = ({ onGameStateChange, onPlayerAction } = {}) => {\n  const humanPlayerId = 'human-player';\n\n  const {\n    gameState,\n    showControls,\n    validActions,\n    showdown,\n    error,\n    isProcessingAI,\n    executeAction,\n    getCurrentPlayerInfo,\n    gameEngine,\n  } = usePokerGame(humanPlayerId, {\n    onStateChange: onGameStateChange,\n    onPlayerAction,\n  });\n\n  // Countdown for next hand - must be declared before any early returns\n  const [countdown, setCountdown] = useState(3);\n\n  // Determine if waiting phase for countdown effect\n  const isWaitingPhase = gameState?.phase === 'waiting';\n\n  useEffect(() => {\n    if (isWaitingPhase) {\n      setCountdown(3);\n      const timer = setInterval(() => {\n        setCountdown((prev) => {\n          if (prev <= 1) {\n            clearInterval(timer);\n            return 0;\n          }\n          return prev - 1;\n        });\n      }, 1000);\n      return () => clearInterval(timer);\n    }\n  }, [isWaitingPhase]);\n\n  // Handle starting a new hand manually\n  const handleNewHand = () => {\n    try {\n      if (gameEngine) {\n        gameEngine.startNewHand();\n      }\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Failed to start new hand:', err);\n    }\n  };\n\n  if (!gameState) {\n    return (\n      <div className=\"poker-table-container\">\n        <div className=\"loading\">Loading game...</div>\n      </div>\n    );\n  }\n\n  // Debug logging\n  if (process.env.NODE_ENV === 'development') {\n    // eslint-disable-next-line no-console\n    console.log('Game State:', {\n      players: gameState.players?.length,\n      phase: gameState.phase,\n      pot: gameState._pot,\n      currentPlayer: gameState.currentPlayerIndex,\n      communityCards: gameState.communityCards?.length,\n    });\n  }\n\n  const { humanPlayer, isHumanTurn, currentPlayer } = getCurrentPlayerInfo;\n\n  // Determine game status for display\n  const isShowdownPhase = gameState.phase === 'showdown';\n  const canShowControls = showControls && humanPlayer && isHumanTurn && !isWaitingPhase;\n\n  return (\n    <div className=\"poker-table-container\">\n      {error && (\n        <div className=\"error-banner\" role=\"alert\" aria-live=\"assertive\" aria-atomic=\"true\">\n          {error}\n        </div>\n      )}\n\n      <main className=\"poker-table\" role=\"main\" aria-label=\"Poker game table\">\n        <div className=\"table-rail\" />\n\n        <section className=\"player-seats\" aria-label=\"Player seating positions\">\n          {gameState.players &&\n            gameState.players\n              .filter((player) => player != null)\n              .map((player) => (\n                <PlayerSeat\n                  key={player.id}\n                  player={player}\n                  isActive={gameState.currentPlayerIndex === player.position}\n                  isDealer={gameState.dealerPosition === player.position}\n                  showCards={player.id === humanPlayerId || showdown}\n                />\n              ))}\n        </section>\n\n        <section\n          className=\"community-cards\"\n          aria-label=\"Community cards\"\n          aria-describedby=\"game-phase-indicator\"\n        >\n          {gameState.communityCards &&\n            gameState.communityCards.map((card, index) => (\n              <Card key={`card-${card.rank}-${card.suit}-${index}`} card={card} />\n            ))}\n          {(() => {\n            const communityCardCount = gameState.communityCards\n              ? gameState.communityCards.length\n              : 0;\n            const placeholderCount = Math.max(0, 5 - communityCardCount);\n            return [...Array(placeholderCount)].map((_, index) => (\n              <Card key={`placeholder-${index}`} />\n            ));\n          })()}\n        </section>\n\n        <div\n          className=\"pot-display\"\n          role=\"status\"\n          aria-live=\"polite\"\n          aria-label={`Current pot amount: $${gameState._pot || 0}`}\n        >\n          Pot: ${gameState._pot || 0}\n        </div>\n\n        <aside className=\"game-info\" aria-label=\"Game information\">\n          <h3>Game Info</h3>\n          <div className=\"game-info-item\">\n            <span>Hand #</span>\n            <span aria-label={`Hand number ${gameState.handNumber}`}>{gameState.handNumber}</span>\n          </div>\n          <div className=\"game-info-item\">\n            <span>Blinds</span>\n            <span\n              aria-label={`Small blind $${gameState.blinds.small}, big blind $${gameState.blinds.big}`}\n            >\n              ${gameState.blinds.small}/${gameState.blinds.big}\n            </span>\n          </div>\n          <div className=\"game-info-item\">\n            <span>Players</span>\n            <span\n              aria-label={`${gameState.getPlayersInHand ? gameState.getPlayersInHand().length : gameState.players.length} players in game`}\n            >\n              {gameState.getPlayersInHand\n                ? gameState.getPlayersInHand().length\n                : gameState.players.length}\n            </span>\n          </div>\n        </aside>\n\n        <div\n          id=\"game-phase-indicator\"\n          className=\"phase-indicator\"\n          role=\"status\"\n          aria-live=\"polite\"\n          aria-label={`Current game phase: ${gameState.phase}`}\n        >\n          {gameState.phase}\n        </div>\n\n        {showdown && gameState.winners && gameState.winners.length > 0 && (\n          <section\n            className=\"winners-display\"\n            role=\"status\"\n            aria-live=\"assertive\"\n            aria-label=\"Hand results\"\n          >\n            <h2>Winner{gameState.winners.length > 1 ? 's' : ''}!</h2>\n            {gameState.winners.map((winner, _index) => (\n              <div\n                key={_index}\n                className=\"winner-item\"\n                aria-label={`${winner.player.name} wins $${winner.amount} with ${winner.handDescription}`}\n              >\n                <div>\n                  {winner.player.name} wins ${winner.amount}\n                </div>\n                <div className=\"winner-hand\">{winner.handDescription}</div>\n              </div>\n            ))}\n          </section>\n        )}\n\n        <div\n          className=\"dealer-button\"\n          style={{\n            transform: `translate(-50%, -50%)\n                     rotate(${gameState.dealerPosition * (360 / gameState.players.length)}deg)\n                     translateX(200px)`,\n          }}\n          role=\"img\"\n          aria-label={`Dealer button at position ${gameState.dealerPosition + 1}`}\n        >\n          D\n        </div>\n      </main>\n\n      {/* Game Status Panel - Always visible */}\n      <div className=\"game-status-panel\" role=\"status\" aria-live=\"polite\">\n        {isWaitingPhase && (\n          <div className=\"status-waiting\">\n            <p>Hand complete. Next hand in {countdown}...</p>\n            <button className=\"new-hand-button\" onClick={handleNewHand}>\n              Start Now\n            </button>\n          </div>\n        )}\n\n        {isProcessingAI && !isWaitingPhase && !isShowdownPhase && (\n          <div className=\"status-ai-thinking\">\n            <div className=\"thinking-indicator\">\n              <span className=\"dot\"></span>\n              <span className=\"dot\"></span>\n              <span className=\"dot\"></span>\n            </div>\n            <p>{currentPlayer?.name || 'AI'} is thinking...</p>\n          </div>\n        )}\n\n        {!isWaitingPhase &&\n          !isProcessingAI &&\n          !isHumanTurn &&\n          !isShowdownPhase &&\n          currentPlayer && (\n            <div className=\"status-other-turn\">\n              <p>Waiting for {currentPlayer.name}...</p>\n            </div>\n          )}\n\n        {isHumanTurn && !isWaitingPhase && !isShowdownPhase && (\n          <div className=\"status-your-turn\">\n            <p>Your turn to act!</p>\n          </div>\n        )}\n      </div>\n\n      {/* Betting Controls - Show when it's human's turn */}\n      {canShowControls && (\n        <BettingControls\n          validActions={validActions}\n          _currentBet={gameState.currentBet}\n          playerChips={humanPlayer.chips}\n          playerBet={humanPlayer.currentBet}\n          _pot={gameState._pot || 0}\n          minBet={gameState.blinds.big}\n          minRaise={gameState.currentBet + gameState.minimumRaise}\n          onAction={executeAction}\n        />\n      )}\n    </div>\n  );\n};\n\nPokerTable.propTypes = {\n  onGameStateChange: PropTypes.func,\n  onPlayerAction: PropTypes.func,\n};\n\nexport default PokerTable;\n","import { PLAYER_ACTIONS } from '../../constants/game-constants';\n\nclass BettingLogic {\n  static validateAction(gameState, player, _action, amount = 0) {\n    if (!player.canAct()) {\n      return { valid: false, reason: 'Player cannot act' };\n    }\n\n    const callAmount = gameState.currentBet - player.currentBet;\n\n    switch (_action) {\n      case PLAYER_ACTIONS.FOLD:\n        return { valid: true };\n\n      case PLAYER_ACTIONS.CHECK:\n        if (callAmount > 0) {\n          return {\n            valid: false,\n            reason: 'Cannot check when there is a bet to call',\n          };\n        }\n        return { valid: true };\n\n      case PLAYER_ACTIONS.CALL:\n        if (callAmount === 0) {\n          return { valid: false, reason: 'Nothing to call' };\n        }\n        // Allow calling even if player doesn't have enough chips (all-in for less)\n        return { valid: true, amount: Math.min(callAmount, player.chips) };\n\n      case PLAYER_ACTIONS.BET:\n        if (gameState.currentBet > 0) {\n          return {\n            valid: false,\n            reason: 'Cannot bet when there is already a bet',\n          };\n        }\n        if (amount < gameState.blinds.big) {\n          return { valid: false, reason: 'Bet must be at least the big blind' };\n        }\n        if (amount > player.chips) {\n          return { valid: false, reason: 'Not enough chips' };\n        }\n        return { valid: true, amount };\n\n      case PLAYER_ACTIONS.RAISE: {\n        if (gameState.currentBet === 0) {\n          return { valid: false, reason: 'Cannot raise when there is no bet' };\n        }\n        const minRaise = gameState.currentBet + gameState.minimumRaise;\n        if (amount < minRaise && amount < player.chips) {\n          return { valid: false, reason: `Raise must be at least ${minRaise}` };\n        }\n        if (amount > player.chips) {\n          return { valid: false, reason: 'Not enough chips' };\n        }\n        return { valid: true, amount: Math.min(amount, player.chips) };\n      }\n\n      case PLAYER_ACTIONS.ALL_IN:\n        return { valid: true, amount: player.chips };\n\n      default:\n        return { valid: false, reason: 'Invalid _action' };\n    }\n  }\n\n  static getValidActions(gameState, player) {\n    if (!player.canAct()) {\n      return [];\n    }\n\n    const validActions = [];\n    const callAmount = gameState.currentBet - player.currentBet;\n\n    validActions.push(PLAYER_ACTIONS.FOLD);\n\n    if (callAmount === 0) {\n      validActions.push(PLAYER_ACTIONS.CHECK);\n\n      if (player.chips >= gameState.blinds.big) {\n        validActions.push(PLAYER_ACTIONS.BET);\n      }\n    } else {\n      if (player.chips >= callAmount) {\n        validActions.push(PLAYER_ACTIONS.CALL);\n      }\n\n      const minRaise = gameState.currentBet + gameState.minimumRaise;\n      if (player.chips >= minRaise) {\n        validActions.push(PLAYER_ACTIONS.RAISE);\n      }\n    }\n\n    if (\n      player.chips > 0 &&\n      (callAmount > 0 || gameState.currentBet === 0) &&\n      !validActions.includes(PLAYER_ACTIONS.CALL) &&\n      !validActions.includes(PLAYER_ACTIONS.RAISE)\n    ) {\n      validActions.push(PLAYER_ACTIONS.ALL_IN);\n    }\n\n    return validActions;\n  }\n\n  static executeAction(gameState, player, _action, amount = 0) {\n    const validation = this.validateAction(gameState, player, _action, amount);\n    if (!validation.valid) {\n      throw new Error(validation.reason);\n    }\n\n    const previousBet = player.currentBet;\n\n    switch (_action) {\n      case PLAYER_ACTIONS.FOLD:\n        player.fold();\n        break;\n\n      case PLAYER_ACTIONS.CHECK:\n        player.check();\n        break;\n\n      case PLAYER_ACTIONS.CALL: {\n        const callAmount = validation.amount || gameState.currentBet - player.currentBet;\n        const actualCall = Math.min(callAmount, player.chips);\n        player.call(actualCall);\n        gameState.potObject.main += actualCall;\n        break;\n      }\n\n      case PLAYER_ACTIONS.BET:\n        player.bet(validation.amount);\n        gameState.currentBet = validation.amount;\n        gameState.minimumRaise = validation.amount;\n        gameState.potObject.main += validation.amount;\n        gameState.lastRaiserIndex = player.position;\n        break;\n\n      case PLAYER_ACTIONS.RAISE: {\n        const raiseAmount = validation.amount;\n        const actualRaise = raiseAmount - player.currentBet;\n        player.raise(raiseAmount); // Pass total target amount, not additional\n\n        gameState.minimumRaise = raiseAmount - gameState.currentBet;\n        gameState.currentBet = raiseAmount;\n        gameState.potObject.main += actualRaise;\n        gameState.lastRaiserIndex = player.position;\n        break;\n      }\n\n      case PLAYER_ACTIONS.ALL_IN: {\n        const allInAmount = player.chips;\n\n        if (gameState.currentBet === 0) {\n          player.bet(allInAmount);\n          if (allInAmount >= gameState.blinds.big) {\n            gameState.currentBet = allInAmount;\n            gameState.minimumRaise = allInAmount;\n            gameState.lastRaiserIndex = player.position;\n          }\n        } else if (player.currentBet + allInAmount > gameState.currentBet) {\n          player.raise(allInAmount);\n          const totalBet = previousBet + allInAmount;\n\n          if (totalBet >= gameState.currentBet + gameState.minimumRaise) {\n            gameState.minimumRaise = totalBet - gameState.currentBet;\n            gameState.currentBet = totalBet;\n            gameState.lastRaiserIndex = player.position;\n          }\n        } else {\n          player.call(allInAmount);\n        }\n\n        // Ensure all-in players have correct status\n        player.status = 'all-in';\n        player.lastAction = 'all-in';\n        gameState.potObject.main += allInAmount;\n        break;\n      }\n    }\n\n    gameState.handHistory.push({\n      playerId: player.id,\n      playerName: player.name,\n      _action,\n      amount: validation.amount || 0,\n      potAfter: gameState.getTotalPot(),\n      phase: gameState.phase,\n      handNumber: gameState.handNumber,\n      timestamp: Date.now(),\n    });\n  }\n\n  static isBettingRoundComplete(gameState) {\n    const activePlayers = gameState.players.filter((p) => p.canAct());\n\n    if (activePlayers.length <= 1) {\n      return true;\n    }\n\n    // Check if all active players have acted\n    const allPlayersActed = activePlayers.every((p) => p.lastAction !== null);\n\n    // Check if all active players have matched the current bet\n    const allBetsMatched = activePlayers.every((p) => p.currentBet === gameState.currentBet);\n\n    // Special case: Big blind option in preflop\n    if (\n      gameState.phase === 'preflop' &&\n      gameState.lastRaiserIndex === null &&\n      gameState.currentBet === gameState.blinds.big\n    ) {\n      const bigBlindPosition = gameState.getBigBlindPosition();\n      const bigBlindPlayer = gameState.getPlayerByPosition(bigBlindPosition);\n\n      // If big blind hasn't acted yet and all others have called/folded, betting round is not complete\n      if (bigBlindPlayer && bigBlindPlayer.canAct() && !bigBlindPlayer.lastAction) {\n        return false;\n      }\n    }\n\n    // If there was a raise, check if all players have acted since the raise\n    if (gameState.lastRaiserIndex !== null) {\n      for (const player of activePlayers) {\n        if (player.position === gameState.lastRaiserIndex) {\n          continue; // The raiser doesn't need to act again\n        }\n\n        if (!this.hasActedSinceLastRaise(gameState, player)) {\n          return false;\n        }\n      }\n    }\n\n    // Betting round is complete if all players have acted and matched the bet\n    return allPlayersActed && allBetsMatched;\n  }\n\n  static hasActedSinceLastRaise(gameState, player) {\n    const history = gameState.handHistory;\n    // Find last raise index (compatible with all browsers)\n    let lastRaiseIndex = -1;\n    for (let i = history.length - 1; i >= 0; i--) {\n      const actionType = history[i]._action || history[i].action;\n      if (actionType === PLAYER_ACTIONS.RAISE || actionType === PLAYER_ACTIONS.BET) {\n        lastRaiseIndex = i;\n        break;\n      }\n    }\n\n    if (lastRaiseIndex === -1) return true;\n\n    return history.slice(lastRaiseIndex + 1).some((h) => h.playerId === player.id);\n  }\n\n  static calculateMinBet(gameState) {\n    return gameState.blinds.big;\n  }\n\n  static calculateMinRaise(gameState) {\n    return gameState.currentBet + gameState.minimumRaise;\n  }\n\n  static calculatePotOdds(gameState, player) {\n    const callAmount = gameState.currentBet - player.currentBet;\n    if (callAmount <= 0) return 100;\n\n    const potAfterCall = gameState.getTotalPot() + callAmount;\n    return (callAmount / potAfterCall) * 100;\n  }\n\n  static getBettingRoundSummary(gameState) {\n    const activePlayers = gameState.getPlayersInHand();\n    const _pot = gameState.getTotalPot();\n    const toCall = gameState.currentBet;\n\n    return {\n      _pot,\n      toCall,\n      playersRemaining: activePlayers.length,\n      currentPlayer: gameState.players[gameState.currentPlayerIndex]?.name || 'None',\n      phase: gameState.phase,\n    };\n  }\n}\n\nexport default BettingLogic;\n","/**\n * PositionStrategy\n * Position-based hand range adjustments for AI decision making\n */\n\n/**\n * Position-based opening range percentages\n * Represents the top X% of hands that should be played from each position\n */\nconst POSITION_RANGES = {\n  // Early position: Play tight (top 12-15% of hands)\n  early: {\n    openRange: 0.12,\n    threeBetRange: 0.05,\n    callRange: 0.08,\n    premiumThreshold: 0.85,\n    strongThreshold: 0.7,\n    playableThreshold: 0.5,\n  },\n  // Middle position: Slightly looser (top 16-20%)\n  middle: {\n    openRange: 0.18,\n    threeBetRange: 0.07,\n    callRange: 0.12,\n    premiumThreshold: 0.8,\n    strongThreshold: 0.65,\n    playableThreshold: 0.45,\n  },\n  // Late position (cutoff): Much looser (top 25-30%)\n  late: {\n    openRange: 0.28,\n    threeBetRange: 0.1,\n    callRange: 0.18,\n    premiumThreshold: 0.75,\n    strongThreshold: 0.55,\n    playableThreshold: 0.35,\n  },\n  // Button: Widest range (top 35-40%)\n  button: {\n    openRange: 0.38,\n    threeBetRange: 0.12,\n    callRange: 0.25,\n    premiumThreshold: 0.7,\n    strongThreshold: 0.5,\n    playableThreshold: 0.3,\n  },\n  // Blinds: Defensive ranges\n  blinds: {\n    openRange: 0.25,\n    threeBetRange: 0.08,\n    callRange: 0.3, // Wider calling range in blinds due to pot odds\n    premiumThreshold: 0.75,\n    strongThreshold: 0.55,\n    playableThreshold: 0.35,\n    defendRange: 0.4, // Defend against steals with top 40%\n  },\n};\n\n/**\n * Steal and defense percentages\n */\nconst STEAL_FREQUENCIES = {\n  // How often to attempt steals from late position vs blinds\n  button: 0.45, // Steal 45% from button when folded to\n  cutoff: 0.35, // Steal 35% from cutoff\n  hijack: 0.25, // Steal 25% from hijack\n\n  // Defense frequencies against steals\n  bigBlindDefend: 0.4, // Defend BB 40% vs steal attempts\n  smallBlindDefend: 0.25, // Defend SB 25% vs steal attempts\n};\n\nclass PositionStrategy {\n  /**\n   * Get position type for a player\n   * @param {number} position - Player's seat position\n   * @param {number} dealerPosition - Current dealer button position\n   * @param {number} totalPlayers - Total players at table\n   * @returns {string} Position type: 'early', 'middle', 'late', 'button', 'blinds'\n   */\n  static getPosition(position, dealerPosition, totalPlayers) {\n    // Calculate relative position from dealer\n    const relativePosition = (position - dealerPosition + totalPlayers) % totalPlayers;\n\n    // For heads-up, just return 'button' or 'blinds'\n    if (totalPlayers === 2) {\n      return relativePosition === 0 ? 'button' : 'blinds';\n    }\n\n    // Map relative position to position type\n    // Position 0 = dealer (button)\n    // Position 1 = small blind\n    // Position 2 = big blind\n    // Position 3+ = early/middle/late depending on total players\n\n    if (relativePosition === 0) return 'button';\n    if (relativePosition === 1 || relativePosition === 2) return 'blinds';\n\n    // For remaining positions, distribute into early/middle/late\n    const nonBlindPositions = totalPlayers - 3; // Exclude BTN, SB, BB\n\n    if (nonBlindPositions <= 3) {\n      // 5-6 players: mostly late position\n      if (relativePosition === 3) return 'late';\n      return 'middle';\n    }\n\n    // 7+ players: proper distribution\n    const thirdOfPositions = Math.ceil(nonBlindPositions / 3);\n    const adjustedPosition = relativePosition - 3; // Position after BB\n\n    if (adjustedPosition < thirdOfPositions) return 'early';\n    if (adjustedPosition < thirdOfPositions * 2) return 'middle';\n    return 'late';\n  }\n\n  /**\n   * Get range parameters for a position\n   * @param {string} positionType - Position type\n   * @returns {Object} Range parameters\n   */\n  static getRangeForPosition(positionType) {\n    return POSITION_RANGES[positionType] || POSITION_RANGES.middle;\n  }\n\n  /**\n   * Adjust hand strength based on position\n   * @param {number} baseStrength - Base hand strength (0-1)\n   * @param {string} positionType - Position type\n   * @param {boolean} isPreflop - Whether this is preflop\n   * @returns {number} Adjusted hand strength\n   */\n  static adjustStrengthForPosition(baseStrength, positionType, isPreflop = true) {\n    if (!isPreflop) {\n      // Position less important postflop, but still relevant\n      const postflopMultiplier =\n        {\n          early: 0.95,\n          middle: 1.0,\n          late: 1.05,\n          button: 1.1,\n          blinds: 0.95,\n        }[positionType] || 1.0;\n\n      return Math.min(baseStrength * postflopMultiplier, 1.0);\n    }\n\n    // Preflop position adjustments\n    // Better positions allow playing weaker hands more profitably\n    const positionMultiplier =\n      {\n        early: 0.85, // Need stronger hands from early position\n        middle: 0.92,\n        late: 1.05,\n        button: 1.15, // Can play weaker hands profitably from button\n        blinds: 0.95, // Positional disadvantage postflop\n      }[positionType] || 1.0;\n\n    return Math.min(baseStrength * positionMultiplier, 1.0);\n  }\n\n  /**\n   * Check if hand is playable from given position\n   * @param {number} handStrength - Hand strength (0-1)\n   * @param {string} positionType - Position type\n   * @param {boolean} isRaised - Whether there's a raise to call\n   * @returns {boolean} Whether hand should be played\n   */\n  static isPlayableFromPosition(handStrength, positionType, isRaised = false) {\n    const range = this.getRangeForPosition(positionType);\n\n    if (isRaised) {\n      // Need stronger hand to call a raise\n      return handStrength >= range.callRange * 3; // Convert to strength threshold\n    }\n\n    return handStrength >= range.playableThreshold;\n  }\n\n  /**\n   * Check if hand should be opened from position\n   * @param {number} handStrength - Hand strength (0-1)\n   * @param {string} positionType - Position type\n   * @param {string} aiType - AI player type\n   * @returns {boolean} Whether to open raise\n   */\n  static shouldOpenRaise(handStrength, positionType, aiType = 'TAG') {\n    const range = this.getRangeForPosition(positionType);\n\n    // Adjust for AI type\n    const typeMultiplier =\n      {\n        TAG: 1.0, // Standard ranges\n        LAG: 1.3, // 30% wider\n        TP: 0.8, // 20% tighter\n        LP: 1.2, // 20% wider but passive\n      }[aiType] || 1.0;\n\n    const adjustedThreshold = range.strongThreshold / typeMultiplier;\n\n    return handStrength >= adjustedThreshold;\n  }\n\n  /**\n   * Get steal frequency for position\n   * @param {string} positionType - Position type\n   * @returns {number} Steal frequency (0-1)\n   */\n  static getStealFrequency(positionType) {\n    return (\n      {\n        button: STEAL_FREQUENCIES.button,\n        late: STEAL_FREQUENCIES.cutoff,\n        middle: STEAL_FREQUENCIES.hijack,\n      }[positionType] || 0\n    );\n  }\n\n  /**\n   * Get blind defense frequency\n   * @param {boolean} isSmallBlind - Whether player is in small blind\n   * @returns {number} Defense frequency (0-1)\n   */\n  static getBlindDefenseFrequency(isSmallBlind) {\n    return isSmallBlind ? STEAL_FREQUENCIES.smallBlindDefend : STEAL_FREQUENCIES.bigBlindDefend;\n  }\n\n  /**\n   * Calculate bet sizing adjustment based on position\n   * @param {number} baseBetSize - Base bet size\n   * @param {string} positionType - Position type\n   * @returns {number} Adjusted bet size\n   */\n  static adjustBetSizeForPosition(baseBetSize, positionType) {\n    const sizeMultiplier =\n      {\n        early: 1.2, // Larger bets from early position (protection)\n        middle: 1.1,\n        late: 1.0,\n        button: 0.9, // Can bet smaller from position\n        blinds: 1.1, // Larger bets out of position\n      }[positionType] || 1.0;\n\n    return Math.floor(baseBetSize * sizeMultiplier);\n  }\n}\n\nexport default PositionStrategy;\n","import { AI_PLAYER_TYPES } from '../../constants/game-constants';\n\nimport PositionStrategy from './strategies/PositionStrategy';\n\nclass AIPlayer {\n  static getAction(player, gameState, validActions, gameEngine) {\n    const { aiType } = player;\n\n    const holeCards = gameEngine.getPlayerCards(player.id);\n    const communityCards = gameEngine.getCommunityCards();\n    const isPreflop = gameState.phase === 'preflop';\n\n    // Get position information\n    const positionType = PositionStrategy.getPosition(\n      player.position,\n      gameState.dealerPosition,\n      gameState.players.length\n    );\n\n    // Evaluate hand strength with position adjustment\n    const baseStrength = this.evaluateHandStrength(holeCards, communityCards, gameState.phase);\n    const handStrength = PositionStrategy.adjustStrengthForPosition(\n      baseStrength,\n      positionType,\n      isPreflop\n    );\n\n    // Create enhanced context for decision making\n    const context = {\n      handStrength,\n      baseStrength,\n      positionType,\n      isPreflop,\n      isInPosition: positionType === 'button' || positionType === 'late',\n      facingRaise: gameState.currentBet > gameState.blinds.big,\n    };\n\n    switch (aiType) {\n      case AI_PLAYER_TYPES.TAG:\n        return this.getTightAggressiveAction(\n          handStrength,\n          validActions,\n          gameState,\n          player,\n          context\n        );\n      case AI_PLAYER_TYPES.LAG:\n        return this.getLooseAggressiveAction(\n          handStrength,\n          validActions,\n          gameState,\n          player,\n          context\n        );\n      case AI_PLAYER_TYPES.TP:\n        return this.getTightPassiveAction(handStrength, validActions, gameState, player, context);\n      case AI_PLAYER_TYPES.LP:\n        return this.getLoosePassiveAction(handStrength, validActions, gameState, player, context);\n      default:\n        return this.getDefaultAction(validActions, gameState, player);\n    }\n  }\n\n  static evaluateHandStrength(holeCards, communityCards, phase) {\n    if (!holeCards || holeCards.length < 2) return 0;\n\n    const [card1, card2] = holeCards;\n    const isPair = card1.rank === card2.rank;\n    const isSuited = card1.suit === card2.suit;\n    const highCard = Math.max(card1.value, card2.value);\n    const lowCard = Math.min(card1.value, card2.value);\n    const gap = highCard - lowCard;\n\n    if (phase === 'preflop') {\n      if (isPair) {\n        if (highCard >= 12) return 0.9;\n        if (highCard >= 9) return 0.7;\n        return 0.5;\n      }\n\n      if (highCard === 14) {\n        if (lowCard >= 11) return 0.8;\n        if (lowCard >= 9) return 0.6;\n      }\n\n      if (highCard === 13 && lowCard >= 11) return 0.6;\n\n      if (isSuited && gap <= 4) return 0.4;\n\n      if (gap <= 2 && highCard >= 10) return 0.3;\n\n      return 0.2;\n    }\n\n    return this.calculatePostFlopStrength(holeCards, communityCards);\n  }\n\n  static calculatePostFlopStrength(holeCards, communityCards) {\n    if (communityCards.length === 0) return 0.3;\n\n    const allCards = [...holeCards, ...communityCards];\n    const hasTopPair = this.hasTopPair(holeCards, communityCards);\n    const hasTwoPair = this.hasTwoPair(allCards);\n    const hasSet = this.hasSet(holeCards, communityCards);\n    const hasFlushDraw = this.hasFlushDraw(allCards);\n    const hasStraightDraw = this.hasStraightDraw(allCards);\n\n    if (hasSet) return 0.9;\n    if (hasTwoPair) return 0.75;\n    if (hasTopPair) return 0.65;\n    if (hasFlushDraw && hasStraightDraw) return 0.55;\n    if (hasFlushDraw || hasStraightDraw) return 0.45;\n\n    return 0.25;\n  }\n\n  static hasTopPair(holeCards, communityCards) {\n    if (communityCards.length === 0) return false;\n\n    const maxCommunityValue = Math.max(...communityCards.map((c) => c.value));\n    return holeCards.some((card) => card.value === maxCommunityValue);\n  }\n\n  static hasTwoPair(cards) {\n    const ranks = {};\n    cards.forEach((card) => {\n      ranks[card.rank] = (ranks[card.rank] || 0) + 1;\n    });\n\n    const pairs = Object.values(ranks).filter((count) => count >= 2);\n    return pairs.length >= 2;\n  }\n\n  static hasSet(holeCards, communityCards) {\n    if (holeCards[0].rank !== holeCards[1].rank) return false;\n\n    return communityCards.some((card) => card.rank === holeCards[0].rank);\n  }\n\n  static hasFlushDraw(cards) {\n    const suits = {};\n    cards.forEach((card) => {\n      suits[card.suit] = (suits[card.suit] || 0) + 1;\n    });\n\n    return Object.values(suits).some((count) => count >= 4);\n  }\n\n  static hasStraightDraw(cards) {\n    const values = [...new Set(cards.map((c) => c.value))].sort((a, b) => a - b);\n\n    for (let i = 0; i <= values.length - 4; i++) {\n      let consecutive = 1;\n      for (let j = i; j < i + 4 && j < values.length - 1; j++) {\n        if (values[j + 1] - values[j] === 1) {\n          consecutive++;\n        }\n      }\n      if (consecutive >= 4) return true;\n    }\n\n    return false;\n  }\n\n  static getTightAggressiveAction(handStrength, validActions, gameState, player, context = {}) {\n    const callAmount = gameState.currentBet - player.currentBet;\n    const potSize = gameState.totalPot || 0;\n    const stackSize = player.chips;\n    const { positionType = 'middle', isInPosition = false } = context;\n\n    // Position-adjusted thresholds\n    const raiseThreshold = isInPosition ? 0.6 : 0.7;\n    const callThreshold = isInPosition ? 0.35 : 0.4;\n    const callPotRatio = isInPosition ? 0.4 : 0.3;\n\n    // Strong hand: Raise aggressively\n    if (handStrength >= raiseThreshold) {\n      if (validActions.includes('raise')) {\n        const baseBet = gameState.currentBet + gameState.minimumRaise + (potSize || 100) * 0.75;\n        const raiseAmount = PositionStrategy.adjustBetSizeForPosition(\n          Math.min(baseBet, stackSize),\n          positionType\n        );\n        return { action: 'raise', amount: Math.floor(raiseAmount) };\n      }\n      if (validActions.includes('bet')) {\n        const baseBet = Math.max((potSize || 100) * 0.75, gameState.blinds?.big || 20);\n        const betAmount = PositionStrategy.adjustBetSizeForPosition(\n          Math.min(baseBet, stackSize),\n          positionType\n        );\n        return { action: 'bet', amount: Math.floor(betAmount) };\n      }\n    }\n\n    // Medium hand: Call if price is right\n    if (handStrength >= callThreshold) {\n      if (validActions.includes('call') && callAmount <= (potSize || 100) * callPotRatio) {\n        return { action: 'call', amount: callAmount };\n      }\n      if (validActions.includes('check')) {\n        return { action: 'check', amount: 0 };\n      }\n    }\n\n    // Weak hand: Check or fold\n    if (validActions.includes('check')) {\n      return { action: 'check', amount: 0 };\n    }\n\n    return { action: 'fold', amount: 0 };\n  }\n\n  static getLooseAggressiveAction(handStrength, validActions, gameState, player, context = {}) {\n    const callAmount = gameState.currentBet - player.currentBet;\n    const potSize = gameState.totalPot || 0;\n    const stackSize = player.chips;\n    const { positionType = 'middle', isInPosition = false, isPreflop = true } = context;\n\n    // LAG plays more hands from position and bluffs more\n    const baseBluffFrequency = 0.3;\n    const bluffFrequency = isInPosition ? baseBluffFrequency * 1.4 : baseBluffFrequency;\n    const stealFrequency = PositionStrategy.getStealFrequency(positionType);\n\n    // Position-adjusted thresholds - LAG is looser from late position\n    const raiseThreshold = isInPosition ? 0.35 : 0.5;\n    const callThreshold = isInPosition ? 0.15 : 0.25;\n\n    // Steal attempt from late position\n    if (isPreflop && isInPosition && gameState.currentBet === gameState.blinds?.big) {\n      if (Math.random() < stealFrequency && validActions.includes('raise')) {\n        const raiseAmount = Math.min(gameState.currentBet * 3, stackSize);\n        return { action: 'raise', amount: Math.floor(raiseAmount) };\n      }\n    }\n\n    if (handStrength >= raiseThreshold || Math.random() < bluffFrequency) {\n      if (validActions.includes('raise')) {\n        const baseBet = gameState.currentBet + gameState.minimumRaise + (potSize || 100) * 0.5;\n        const raiseAmount = PositionStrategy.adjustBetSizeForPosition(\n          Math.min(baseBet, stackSize),\n          positionType\n        );\n        return { action: 'raise', amount: Math.floor(raiseAmount) };\n      }\n      if (validActions.includes('bet')) {\n        const baseBet = Math.max((potSize || 100) * 0.6, gameState.blinds?.big || 20);\n        const betAmount = PositionStrategy.adjustBetSizeForPosition(\n          Math.min(baseBet, stackSize),\n          positionType\n        );\n        return { action: 'bet', amount: Math.floor(betAmount) };\n      }\n    }\n\n    if (handStrength >= callThreshold) {\n      if (validActions.includes('call') && callAmount <= (potSize || 100) * 0.5) {\n        return { action: 'call', amount: callAmount };\n      }\n      if (validActions.includes('check')) {\n        return { action: 'check', amount: 0 };\n      }\n    }\n\n    if (validActions.includes('check')) {\n      return { action: 'check', amount: 0 };\n    }\n\n    return { action: 'fold', amount: 0 };\n  }\n\n  static getTightPassiveAction(handStrength, validActions, gameState, player, context = {}) {\n    const callAmount = gameState.currentBet - player.currentBet;\n    const potSize = gameState.totalPot || 0;\n    const stackSize = player.chips;\n    const { isInPosition = false } = context;\n\n    // TP plays fewer hands and prefers calling to raising\n    // Position adjustments are smaller for passive players\n    const betThreshold = isInPosition ? 0.75 : 0.8;\n    const callThreshold = isInPosition ? 0.45 : 0.5;\n    const callPotRatio = isInPosition ? 0.25 : 0.2;\n\n    if (handStrength >= betThreshold) {\n      if (validActions.includes('bet')) {\n        // TP bets small with strong hands\n        const betAmount = Math.min(\n          Math.max((potSize || 100) * 0.3, gameState.blinds?.big || 20),\n          stackSize\n        );\n        return { action: 'bet', amount: Math.floor(betAmount) };\n      }\n      if (validActions.includes('call')) {\n        return { action: 'call', amount: callAmount };\n      }\n    }\n\n    if (handStrength >= callThreshold) {\n      if (validActions.includes('call') && callAmount <= (potSize || 100) * callPotRatio) {\n        return { action: 'call', amount: callAmount };\n      }\n      if (validActions.includes('check')) {\n        return { action: 'check', amount: 0 };\n      }\n    }\n\n    if (validActions.includes('check')) {\n      return { action: 'check', amount: 0 };\n    }\n\n    return { action: 'fold', amount: 0 };\n  }\n\n  static getLoosePassiveAction(handStrength, validActions, gameState, player, context = {}) {\n    const callAmount = gameState.currentBet - player.currentBet;\n    const potSize = gameState.totalPot || 0;\n    const stackSize = player.chips;\n    const { isInPosition = false } = context;\n\n    // LP plays many hands but rarely raises - the classic \"calling station\"\n    // Position slightly affects their calling range\n    const betThreshold = isInPosition ? 0.65 : 0.7;\n    const callThreshold = isInPosition ? 0.15 : 0.2;\n    const callPotRatio = isInPosition ? 0.5 : 0.4;\n\n    if (handStrength >= betThreshold) {\n      if (validActions.includes('bet')) {\n        // LP bets small even with strong hands\n        const betAmount = Math.min(\n          Math.max((potSize || 100) * 0.25, gameState.blinds?.big || 20),\n          stackSize\n        );\n        return { action: 'bet', amount: Math.floor(betAmount) };\n      }\n    }\n\n    // LP has wide calling range - they like to see flops and showdowns\n    if (handStrength >= callThreshold) {\n      if (validActions.includes('call') && callAmount <= (potSize || 100) * callPotRatio) {\n        return { action: 'call', amount: callAmount };\n      }\n      if (validActions.includes('check')) {\n        return { action: 'check', amount: 0 };\n      }\n    }\n\n    if (validActions.includes('check')) {\n      return { action: 'check', amount: 0 };\n    }\n\n    return { action: 'fold', amount: 0 };\n  }\n\n  static getDefaultAction(validActions, gameState, player) {\n    if (validActions.includes('check')) {\n      return { action: 'check', amount: 0 };\n    }\n\n    const callAmount = gameState.currentBet - player.currentBet;\n    const _potOdds = gameState.totalPot / callAmount;\n\n    if (validActions.includes('call') && _potOdds > 3) {\n      return { action: 'call', amount: callAmount };\n    }\n\n    return { action: 'fold', amount: 0 };\n  }\n}\n\nexport default AIPlayer;\n"],"names":["constructor","this","cards","dealtCards","reset","suit","Object","values","SUITS","rank","RANKS","push","Card","shuffle","getRandomIndex","max","crypto","getRandomValues","array","Uint32Array","Math","floor","random","i","length","j","dealCard","Error","card","shift","dealOne","dealCards","count","deal","cardsRemaining","getRemainingCards","getDealtCards","removeSpecificCards","cardsToRemove","filter","some","removeCard","players","deck","communityCards","_internalPot","main","side","potHistory","currentBet","_currentBet","minimumRaise","minRaise","dealerPosition","smallBlindPosition","bigBlindPosition","currentPlayerIndex","phase","GAME_PHASES","WAITING","handNumber","blinds","small","big","lastRaiserIndex","bettingRoundComplete","handHistory","winners","initialize","PREFLOP","validateState","addPlayer","player","position","removePlayer","playerId","p","id","updatePlayerPositions","forEach","index","getActivePlayers","isActive","chips","status","PLAYER_STATUS","ALL_IN","FOLDED","SITTING_OUT","getPlayersInHand","isInHand","getNextActivePlayerIndex","startIndex","numPlayers","canAct","moveButton","getSmallBlindPosition","getBigBlindPosition","getUTGPosition","resetForNewHand","calculateSidePots","activePlayers","contributions","totalPotContribution","amount","sort","a","b","previousAmount","currentAmount","potAmount","eligiblePlayers","slice","map","c","getTotalPot","total","sidePot","addToHistory","_action","timestamp","Date","now","getPlayerByPosition","find","serialize","pot","_pot","totalPot","playersInHand","self","potValue","valueOf","toString","Symbol","toPrimitive","_hint","value","potObject","nextDealer","addToPot","setCurrentBet","arguments","undefined","nextPhase","phases","FLOP","TURN","RIVER","SHOWDOWN","currentIndex","indexOf","setCommunityCards","nextPlayer","getCurrentPlayer","isHandComplete","createSidePots","contribution","sidePots","isBettingRoundComplete","playersWhoCanAct","bets","every","bet","lastAction","toJSON","evaluateHand","allCombinations","getCombinations","bestHand","bestRank","bestTiebreakers","combination","evaluation","evaluateFiveCardHand","compareTiebreakers","tiebreakers","rankName","description","sortedCards","isFlush","checkFlush","straightHighCard","checkStraight","groups","groupByRank","groupSizes","group","HAND_RANKINGS","ROYAL_FLUSH","STRAIGHT_FLUSH","concat","getCardName","fourOfAKindRank","getRankOfSize","kicker","FOUR_OF_A_KIND","threeOfAKindRank","pairRank","FULL_HOUSE","flushCards","FLUSH","STRAIGHT","kickers","getKickers","THREE_OF_A_KIND","pairs","getRanksOfSize","TWO_PAIR","PAIR","highCards","HIGH_CARD","suits","isStraight","size","entries","parseInt","ranks","usedRanks","sortedRanks","keys","r","includes","min","arr","combinations","backtrack","start","current","pop","compareHands","hand1","hand2","findWinners","playerHands","evaluatedHands","_ref","hand","gameState","GameState","Deck","_isRestarting","_isInitialized","callbacks","onStateChange","onHandComplete","onPlayerAction","onPhaseChange","onShowdown","setCallback","event","callback","prototype","hasOwnProperty","call","notifyStateChange","startNewHand","postBlinds","dealHoleCards","notifyPhaseChange","error","smallBlindPlayer","bigBlindPlayer","sbAmount","placeBet","playerName","name","bbAmount","holeCards","dealCommunityCards","executePlayerAction","console","currentPlayer","BettingLogic","executeAction","checkAndAdvanceGame","success","action","_this$gameState","_this$gameState$playe","_this$gameState2","gameStateExists","playersCount","message","handleSinglePlayerWin","advanceToNextPhase","moveToNextPlayer","resetBettingRound","handleShowdown","winner","winPot","handDescription","completeHand","mainPotWinners","HandEvaluator","mainPotAmount","mainPotShare","eligibleHands","_ref2","sidePotWinners","sidePotShare","_ref3","existingWinner","w","setTimeout","getValidActions","warn","getGameState","setBlinds","getPlayerCards","getAllPlayerCards","getCommunityCards","getPotOdds","calculatePotOdds","isAI","aiType","_position","totalBetThisRound","isFolded","isAllIn","isDealer","stats","handsPlayed","handsWon","biggestPotWon","totalWinnings","vpip","pfr","aggression","setHoleCards","receiveCards","clearHoleCards","betAmount","fold","check","CHECKED","callAmount","actualAmount","CALLED","raise","additionalAmount","raiseAmount","RAISED","checkIfActive","ACTIVE","decideAction","AIPlayer","require","validActions","getAction","getNetPosition","updateStats","hasCards","humanPlayerId","options","initialChips","smallBlind","bigBlind","aiPlayers","type","gameEngine","useState","GameEngine","setGameState","showControls","setShowControls","setValidActions","showdown","setShowdown","isProcessingAI","setIsProcessingAI","setError","isGameActive","setIsGameActive","isProcessingRef","useRef","gameEngineRef","useHandHistory","processSingleAITurn","useCallback","engine","currentGameState","actions","aiAction","result","updatedState","processAITurns","processNext","err","initializeGame","humanPlayer","Player","aiConfig","idx","aiPlayer","useEffect","_callbacksInitialized","newState","stateWithTimestamp","_objectSpread","_updateTimestamp","isSessionActive","captureAction","getCurrentPlayerInfo","useMemo","isHumanTurn","timeoutId","stillCurrentPlayer","clearTimeout","BettingControls","React","playerChips","playerBet","onAction","minBet","setBetAmount","handleSliderChange","e","target","handleInputChange","setPresetBet","fraction","potOdds","potAfterCall","toFixed","_jsxs","className","role","children","_jsx","htmlFor","onChange","onClick","disabled","parseFloat","prevProps","nextProps","JSON","stringify","displayName","faceDown","suitClass","s","h","d","suitSymbol","getSuitSymbol","getCardDescription","suitName","getSuitName","_prevProps$card","_nextProps$card","_prevProps$card2","_nextProps$card2","PlayerSeat","showCards","positionLabel","getPositionLabel","seatClasses","Boolean","join","_Fragment","_index","style","width","prevPlayer","onGameStateChange","usePokerGame","countdown","setCountdown","isWaitingPhase","timer","setInterval","prev","clearInterval","isShowdownPhase","canShowControls","communityCardCount","placeholderCount","Array","_","transform","handleNewHand","validateAction","valid","reason","PLAYER_ACTIONS","FOLD","CHECK","CALL","BET","RAISE","validation","previousBet","actualCall","actualRaise","allInAmount","totalBet","potAfter","allPlayersActed","allBetsMatched","hasActedSinceLastRaise","history","lastRaiseIndex","actionType","calculateMinBet","calculateMinRaise","getBettingRoundSummary","_gameState$players$ga","toCall","playersRemaining","POSITION_RANGES","early","openRange","threeBetRange","callRange","premiumThreshold","strongThreshold","playableThreshold","middle","late","button","defendRange","STEAL_FREQUENCIES","getPosition","totalPlayers","relativePosition","nonBlindPositions","thirdOfPositions","ceil","adjustedPosition","getRangeForPosition","positionType","adjustStrengthForPosition","baseStrength","postflopMultiplier","positionMultiplier","isPlayableFromPosition","handStrength","isRaised","range","shouldOpenRaise","typeMultiplier","TAG","LAG","TP","LP","getStealFrequency","getBlindDefenseFrequency","isSmallBlind","adjustBetSizeForPosition","baseBetSize","sizeMultiplier","isPreflop","PositionStrategy","evaluateHandStrength","context","isInPosition","facingRaise","AI_PLAYER_TYPES","getTightAggressiveAction","getLooseAggressiveAction","getTightPassiveAction","getLoosePassiveAction","getDefaultAction","card1","card2","isPair","isSuited","highCard","lowCard","gap","calculatePostFlopStrength","allCards","hasTopPair","hasTwoPair","hasSet","hasFlushDraw","hasStraightDraw","maxCommunityValue","Set","consecutive","potSize","stackSize","callThreshold","callPotRatio","baseBet","_gameState$blinds","_gameState$blinds2","bluffFrequency","baseBluffFrequency","stealFrequency","raiseThreshold","_gameState$blinds3","_gameState$blinds4","_gameState$blinds5","_potOdds"],"ignoreList":[],"sourceRoot":""}