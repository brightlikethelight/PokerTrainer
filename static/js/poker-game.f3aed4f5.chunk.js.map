{"version":3,"file":"static/js/poker-game.f3aed4f5.chunk.js","mappings":"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","sources":["game/entities/Deck.js","game/entities/GameState.js","game/utils/HandEvaluator.js","game/engine/GameEngine.js","game/entities/Player.js","hooks/usePokerGame.js","components/game/BettingControls.jsx","components/game/Card.jsx","components/game/PlayerSeat.jsx","components/game/PokerTable.jsx","game/engine/BettingLogic.js","game/engine/strategies/PositionStrategy.js","game/engine/AIPlayer.js"],"sourcesContent":["import { RANKS, SUITS } from '../../constants/game-constants';\n\nimport Card from './Card';\n\nclass Deck {\n  constructor() {\n    this.cards = [];\n    this.dealtCards = [];\n    this.reset();\n  }\n\n  reset() {\n    this.cards = [];\n    this.dealtCards = [];\n\n    for (const suit of Object.values(SUITS)) {\n      for (const rank of Object.values(RANKS)) {\n        this.cards.push(new Card(rank, suit));\n      }\n    }\n\n    this.shuffle();\n  }\n\n  shuffle() {\n    // Use cryptographically secure random for fair card distribution\n    // Falls back to Math.random in environments without crypto support\n    const getRandomIndex = (max) => {\n      if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n        const array = new Uint32Array(1);\n        crypto.getRandomValues(array);\n        return Math.floor((array[0] / (0xffffffff + 1)) * max);\n      }\n      return Math.floor(Math.random() * max);\n    };\n\n    // Fisher-Yates shuffle\n    for (let i = this.cards.length - 1; i > 0; i--) {\n      const j = getRandomIndex(i + 1);\n      [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];\n    }\n  }\n\n  dealCard() {\n    if (this.cards.length === 0) {\n      throw new Error('Not enough cards in deck');\n    }\n\n    const card = this.cards.shift(); // Deal from top (index 0)\n    this.dealtCards.push(card);\n    return card;\n  }\n\n  dealOne() {\n    return this.dealCard();\n  }\n\n  dealCards(count) {\n    if (count < 0) {\n      throw new Error('Cannot deal negative number of cards');\n    }\n\n    if (count > this.cards.length) {\n      throw new Error('Not enough cards in deck');\n    }\n\n    const cards = [];\n    for (let i = 0; i < count; i++) {\n      cards.push(this.dealCard());\n    }\n    return cards;\n  }\n\n  deal(count) {\n    return this.dealCards(count);\n  }\n\n  cardsRemaining() {\n    return this.cards.length;\n  }\n\n  getRemainingCards() {\n    return this.cardsRemaining();\n  }\n\n  getDealtCards() {\n    return [...this.dealtCards];\n  }\n\n  removeSpecificCards(cardsToRemove) {\n    this.cards = this.cards.filter(\n      (card) =>\n        !cardsToRemove.some(\n          (removeCard) => card.rank === removeCard.rank && card.suit === removeCard.suit\n        )\n    );\n  }\n}\n\nexport default Deck;\n","import { GAME_PHASES, PLAYER_STATUS } from '../../constants/game-constants';\n\nclass GameState {\n  constructor() {\n    this.players = [];\n    this.deck = null;\n    this.communityCards = [];\n    this._internalPot = {\n      main: 0,\n      side: [],\n    };\n    this.potHistory = []; // Track pot changes\n    this.currentBet = 0;\n    this._currentBet = 0; // Alias for compatibility\n    this.minimumRaise = 0;\n    this.minRaise = 0; // Alias for compatibility\n    this.dealerPosition = 0;\n    this.smallBlindPosition = 1; // Add missing property\n    this.bigBlindPosition = 2; // Add missing property\n    this.currentPlayerIndex = 0;\n    this.phase = GAME_PHASES.WAITING;\n    this.handNumber = 0;\n    this.blinds = {\n      small: 10,\n      big: 20,\n    };\n    this.lastRaiserIndex = null;\n    this.bettingRoundComplete = false;\n    this.handHistory = [];\n    this.winners = [];\n  }\n\n  initialize(players) {\n    this.players = players;\n    this.dealerPosition = 0;\n\n    // Handle heads-up (2 players) vs multi-player scenarios\n    if (players.length === 2) {\n      this.smallBlindPosition = 0; // Dealer is SB in heads-up\n      this.bigBlindPosition = 1;\n      this.currentPlayerIndex = 0; // SB acts first preflop in heads-up\n    } else {\n      this.smallBlindPosition = 1;\n      this.bigBlindPosition = 2;\n      this.currentPlayerIndex = 3; // First to act after big blind\n    }\n\n    this._internalPot = {\n      main: 0,\n      side: [],\n    };\n    this.potHistory = [];\n    this.currentBet = 0;\n    this._currentBet = 0;\n    this.minimumRaise = 0;\n    this.minRaise = 0;\n    this.phase = GAME_PHASES.PREFLOP;\n  }\n\n  validateState() {\n    // Basic validation checks\n    if (!this.players || this.players.length < 2) {\n      return false;\n    }\n\n    if (this.dealerPosition < 0 || this.dealerPosition >= this.players.length) {\n      return false;\n    }\n\n    if (this.currentPlayerIndex < 0 || this.currentPlayerIndex >= this.players.length) {\n      return false;\n    }\n\n    return true;\n  }\n\n  addPlayer(player) {\n    this.players.push(player);\n    player.position = this.players.length - 1;\n  }\n\n  removePlayer(playerId) {\n    this.players = this.players.filter((p) => p.id !== playerId);\n    this.updatePlayerPositions();\n  }\n\n  updatePlayerPositions() {\n    this.players.forEach((player, index) => {\n      player.position = index;\n    });\n  }\n\n  getActivePlayers() {\n    // Players are \"active\" if they can participate in the hand\n    // This includes players who are WAITING, ACTIVE, CHECKED, CALLED, RAISED, or ALL_IN\n    // but excludes players who are FOLDED or SITTING_OUT\n    // Note: ALL_IN players have chips=0 but are still in the hand\n    return this.players.filter(\n      (p) =>\n        p.isActive &&\n        (p.chips > 0 || p.status === PLAYER_STATUS.ALL_IN) &&\n        p.status !== PLAYER_STATUS.FOLDED &&\n        p.status !== PLAYER_STATUS.SITTING_OUT\n    );\n  }\n\n  getPlayersInHand() {\n    return this.players.filter((p) => p.isInHand());\n  }\n\n  getNextActivePlayerIndex(startIndex) {\n    if (!this.players || this.players.length === 0) {\n      return -1;\n    }\n\n    const numPlayers = this.players.length;\n    let index = (startIndex + 1) % numPlayers;\n\n    // Search through all players starting from the next position\n    for (let i = 0; i < numPlayers; i++) {\n      const player = this.players[index];\n\n      // Check if this player can act\n      if (player && player.canAct()) {\n        return index;\n      }\n\n      // Move to next player (with wrap-around)\n      index = (index + 1) % numPlayers;\n    }\n\n    // No valid players found after checking all positions\n    return -1;\n  }\n\n  moveButton() {\n    this.dealerPosition = (this.dealerPosition + 1) % this.players.length;\n\n    while (this.players[this.dealerPosition].chips === 0) {\n      this.dealerPosition = (this.dealerPosition + 1) % this.players.length;\n    }\n  }\n\n  getSmallBlindPosition() {\n    if (this.players.length === 2) {\n      return this.dealerPosition;\n    }\n\n    let position = (this.dealerPosition + 1) % this.players.length;\n    while (this.players[position].chips === 0) {\n      position = (position + 1) % this.players.length;\n    }\n    return position;\n  }\n\n  getBigBlindPosition() {\n    const sbPosition = this.getSmallBlindPosition();\n    let position = (sbPosition + 1) % this.players.length;\n\n    while (this.players[position].chips === 0) {\n      position = (position + 1) % this.players.length;\n    }\n    return position;\n  }\n\n  getUTGPosition() {\n    const bbPosition = this.getBigBlindPosition();\n    let position = (bbPosition + 1) % this.players.length;\n\n    while (this.players[position].chips === 0) {\n      position = (position + 1) % this.players.length;\n    }\n    return position;\n  }\n\n  resetForNewHand() {\n    this.communityCards = [];\n    this._internalPot = {\n      main: 0,\n      side: [],\n    };\n    this.potHistory = [];\n    this.currentBet = 0;\n    this._currentBet = 0;\n    this.minimumRaise = this.blinds.big;\n    this.minRaise = this.blinds.big;\n    this.phase = GAME_PHASES.PREFLOP;\n    this.lastRaiserIndex = null;\n    this.bettingRoundComplete = false;\n    this.winners = [];\n    this.handNumber++;\n\n    this.players.forEach((player) => {\n      if (player.chips > 0) {\n        player.resetForNewHand();\n      } else {\n        player.status = PLAYER_STATUS.SITTING_OUT;\n      }\n    });\n  }\n\n  calculateSidePots() {\n    const playersInHand = this.getPlayersInHand();\n    if (playersInHand.length === 0) return;\n\n    // Include ALL players' contributions (even folded players)\n    // because their money is still in the pot\n    const allContributions = [];\n    this.players.forEach((player) => {\n      if (player.totalPotContribution > 0) {\n        allContributions.push({\n          player,\n          amount: player.totalPotContribution,\n          isInHand: player.isInHand(), // Track if player can win\n        });\n      }\n    });\n\n    if (allContributions.length === 0) return;\n\n    // Sort by contribution amount\n    allContributions.sort((a, b) => a.amount - b.amount);\n\n    // Calculate total pot from ALL contributions (including folded players)\n    const totalContributions = allContributions.reduce((sum, c) => sum + c.amount, 0);\n\n    // Get only players who are still in hand (can win)\n    const eligibleContributions = allContributions.filter((c) => c.isInHand);\n\n    if (eligibleContributions.length === 0) {\n      // Edge case: no one left in hand (shouldn't happen)\n      this._internalPot = { main: totalContributions, side: [] };\n      return;\n    }\n\n    // If only one player in hand, they win the entire pot (no side pots needed)\n    if (eligibleContributions.length === 1) {\n      this._internalPot = { main: totalContributions, side: [] };\n      return;\n    }\n\n    // For multiple players in hand, calculate proper side pots based on eligible players\n    // But ensure we account for folded players' contributions in the pot\n    eligibleContributions.sort((a, b) => a.amount - b.amount);\n\n    this._internalPot = { main: 0, side: [] };\n    let previousAmount = 0;\n    const foldedContribution = allContributions\n      .filter((c) => !c.isInHand)\n      .reduce((sum, c) => sum + c.amount, 0);\n\n    for (let i = 0; i < eligibleContributions.length; i++) {\n      const currentAmount = eligibleContributions[i].amount;\n      const numEligibleAtThisLevel = eligibleContributions.length - i;\n      let potAmount = (currentAmount - previousAmount) * numEligibleAtThisLevel;\n\n      // Add folded players' contributions to the main pot (first level)\n      if (i === 0) {\n        potAmount += foldedContribution;\n        this._internalPot.main = potAmount;\n      } else {\n        const eligiblePlayers = eligibleContributions.slice(i).map((c) => c.player);\n        this._internalPot.side.push({\n          amount: potAmount,\n          eligiblePlayers,\n        });\n      }\n\n      previousAmount = currentAmount;\n    }\n  }\n\n  getTotalPot() {\n    let total = this._internalPot.main;\n    this._internalPot.side.forEach((sidePot) => {\n      total += sidePot.amount;\n    });\n    return total;\n  }\n\n  addToHistory(_action) {\n    this.handHistory.push({\n      handNumber: this.handNumber,\n      phase: this.phase,\n      _action,\n      timestamp: Date.now(),\n    });\n  }\n\n  getPlayerByPosition(position) {\n    return this.players.find((p) => p.position === position);\n  }\n\n  serialize() {\n    return {\n      players: this.players.map((p) => p.serialize()),\n      communityCards: this.communityCards.map((c) => ({\n        rank: c.rank,\n        suit: c.suit,\n      })),\n      pot: this._internalPot,\n      _pot: this._internalPot.main, // Include for test compatibility - return main value\n      currentBet: this.currentBet,\n      minimumRaise: this.minimumRaise,\n      dealerPosition: this.dealerPosition,\n      currentPlayerIndex: this.currentPlayerIndex,\n      phase: this.phase,\n      handNumber: this.handNumber,\n      blinds: this.blinds,\n      totalPot: this.getTotalPot(),\n      playersInHand: this.getPlayersInHand().length,\n      winners: this.winners,\n      // Add missing methods that tests expect\n      getTotalPot: () => this.getTotalPot(),\n      getPlayersInHand: () => this.getPlayersInHand(),\n      getActivePlayers: () => this.getActivePlayers(),\n      getSmallBlindPosition: () => this.getSmallBlindPosition(),\n      getBigBlindPosition: () => this.getBigBlindPosition(),\n      getPlayerByPosition: (position) => this.getPlayerByPosition(position),\n    };\n  }\n\n  get pot() {\n    // Return object that behaves like number but has .main property\n    const self = this;\n    const potValue = this._internalPot.main;\n\n    return {\n      // Make it behave like a number for comparisons\n      valueOf() {\n        return potValue;\n      },\n      toString() {\n        return potValue.toString();\n      },\n\n      // For Jest's .toBe() strict equality\n      [Symbol.toPrimitive](_hint) {\n        return potValue;\n      },\n\n      // Support .main property access\n      get main() {\n        return self._internalPot.main;\n      },\n      set main(value) {\n        self._internalPot.main = value;\n      },\n    };\n  }\n\n  set pot(value) {\n    if (typeof value === 'number') {\n      this._internalPot.main = value;\n    } else {\n      this._internalPot = value;\n    }\n  }\n\n  // Return main pot value as number for test compatibility\n  get _pot() {\n    return this._internalPot.main;\n  }\n\n  set _pot(value) {\n    if (typeof value === 'number') {\n      this._internalPot = { main: value, side: [] };\n    } else {\n      this._internalPot = value;\n    }\n  }\n\n  // Provide access to full pot object when needed by BettingLogic\n  get potObject() {\n    return this._internalPot;\n  }\n\n  nextDealer() {\n    this.dealerPosition = (this.dealerPosition + 1) % this.players.length;\n\n    // Skip players without chips or inactive players (sitting out)\n    while (\n      this.players[this.dealerPosition].chips === 0 ||\n      !this.players[this.dealerPosition].isActive\n    ) {\n      this.dealerPosition = (this.dealerPosition + 1) % this.players.length;\n    }\n\n    // Update blind positions based on new dealer\n    if (this.players.length === 2) {\n      this.smallBlindPosition = this.dealerPosition; // Dealer is SB in heads-up\n      this.bigBlindPosition = (this.dealerPosition + 1) % this.players.length;\n    } else {\n      this.smallBlindPosition = (this.dealerPosition + 1) % this.players.length;\n      this.bigBlindPosition = (this.dealerPosition + 2) % this.players.length;\n    }\n  }\n\n  addToPot(amount) {\n    this._internalPot.main += amount;\n    this.potHistory.push(amount);\n  }\n\n  setCurrentBet(amount, minRaise = 0) {\n    this.currentBet = amount;\n    this._currentBet = amount;\n    this.minimumRaise = minRaise;\n    this.minRaise = minRaise;\n  }\n\n  nextPhase() {\n    const phases = [\n      GAME_PHASES.PREFLOP,\n      GAME_PHASES.FLOP,\n      GAME_PHASES.TURN,\n      GAME_PHASES.RIVER,\n      GAME_PHASES.SHOWDOWN,\n    ];\n    const currentIndex = phases.indexOf(this.phase);\n\n    if (currentIndex < phases.length - 1) {\n      this.phase = phases[currentIndex + 1];\n    }\n\n    // Reset betting for new phase\n    this.currentBet = 0;\n    this._currentBet = 0;\n    this.minimumRaise = 0;\n    this.minRaise = 0;\n  }\n\n  setCommunityCards(cards) {\n    this.communityCards = cards;\n  }\n\n  nextPlayer() {\n    this.currentPlayerIndex = this.getNextActivePlayerIndex(this.currentPlayerIndex);\n  }\n\n  getCurrentPlayer() {\n    return this.players[this.currentPlayerIndex];\n  }\n\n  isHandComplete() {\n    if (this.phase === GAME_PHASES.SHOWDOWN) {\n      return true;\n    }\n\n    const playersInHand = this.getPlayersInHand();\n    return playersInHand.length <= 1;\n  }\n\n  createSidePots() {\n    const playersInHand = this.getPlayersInHand();\n    if (playersInHand.length === 0) return [];\n\n    const contributions = [];\n    playersInHand.forEach((player) => {\n      const contribution = player.currentBet || player._currentBet || 0;\n      if (contribution > 0) {\n        contributions.push({\n          player,\n          amount: contribution,\n        });\n      }\n    });\n\n    contributions.sort((a, b) => a.amount - b.amount);\n\n    const sidePots = [];\n    let previousAmount = 0;\n\n    for (let i = 0; i < contributions.length; i++) {\n      const currentAmount = contributions[i].amount;\n      const potAmount = (currentAmount - previousAmount) * (contributions.length - i);\n\n      if (potAmount > 0) {\n        const eligiblePlayers = contributions.slice(i).map((c) => c.player);\n        sidePots.push({\n          amount: potAmount,\n          eligiblePlayers,\n        });\n      }\n\n      previousAmount = currentAmount;\n    }\n\n    return sidePots;\n  }\n\n  isBettingRoundComplete() {\n    // Import BettingLogic to check if betting round is complete\n    // For now, implement basic logic here to avoid circular imports\n    const activePlayers = this.getActivePlayers().filter((p) => p.canAct());\n    if (activePlayers.length <= 1) {\n      return true;\n    }\n\n    // Check if all players have acted and bets are equal\n    const playersWhoCanAct = activePlayers.filter(\n      (p) => p.status !== PLAYER_STATUS.FOLDED && p.status !== PLAYER_STATUS.ALL_IN\n    );\n\n    if (playersWhoCanAct.length === 0) {\n      return true;\n    }\n\n    // Simple check: if all active players have the same current bet\n    const bets = playersWhoCanAct.map((p) => p._currentBet);\n    const allBetsEqual = bets.every((bet) => bet === bets[0]);\n\n    return allBetsEqual && playersWhoCanAct.every((p) => p.lastAction !== null);\n  }\n\n  toJSON() {\n    return this.serialize();\n  }\n}\n\nexport default GameState;\n","import { HAND_RANKINGS } from '../../constants/game-constants';\n\n/**\n * Static utility class for evaluating poker hands and determining winners.\n * Implements Texas Hold'em hand ranking rules and comparison logic.\n *\n * @class HandEvaluator\n * @example\n * const cards = [card1, card2, card3, card4, card5, card6, card7];\n * const bestHand = HandEvaluator.evaluateHand(cards);\n * console.log(`Best hand: ${bestHand.description}`);\n */\nclass HandEvaluator {\n  /**\n   * Evaluates the best possible 5-card poker hand from 5-7 cards.\n   *\n   * @static\n   * @param {Card[]} cards - Array of 5-7 cards to evaluate\n   * @returns {Object} Hand evaluation result containing rank, cards, description, and tiebreakers\n   * @throws {Error} If fewer than 5 cards provided\n   * @example\n   * const hand = HandEvaluator.evaluateHand([card1, card2, card3, card4, card5]);\n   * // Returns: { rank: 8, rankName: \"Straight\", cards: [...], description: \"Straight, Ten high\" }\n   */\n  static evaluateHand(cards) {\n    if (cards.length < 5) {\n      throw new Error('Need at least 5 cards to evaluate');\n    }\n\n    const allCombinations = this.getCombinations(cards, 5);\n    let bestHand = null;\n    let bestRank = -1;\n    let bestTiebreakers = [];\n\n    for (const combination of allCombinations) {\n      const evaluation = this.evaluateFiveCardHand(combination);\n\n      if (\n        evaluation.rank > bestRank ||\n        (evaluation.rank === bestRank &&\n          this.compareTiebreakers(evaluation.tiebreakers, bestTiebreakers) > 0)\n      ) {\n        bestRank = evaluation.rank;\n        bestTiebreakers = evaluation.tiebreakers;\n        bestHand = {\n          rank: evaluation.rank,\n          rankName: evaluation.rankName,\n          cards: combination,\n          tiebreakers: evaluation.tiebreakers,\n          description: evaluation.description,\n        };\n      }\n    }\n\n    return bestHand;\n  }\n\n  static evaluateFiveCardHand(cards) {\n    const sortedCards = [...cards].sort((a, b) => b.value - a.value);\n\n    const isFlush = this.checkFlush(cards);\n    const straightHighCard = this.checkStraight(sortedCards);\n    const groups = this.groupByRank(cards);\n    const groupSizes = Object.values(groups)\n      .map((group) => group.length)\n      .sort((a, b) => b - a);\n\n    if (isFlush && straightHighCard) {\n      if (straightHighCard === 14) {\n        return {\n          rank: HAND_RANKINGS.ROYAL_FLUSH,\n          rankName: 'Royal Flush',\n          tiebreakers: [],\n          description: 'Royal Flush',\n        };\n      }\n      return {\n        rank: HAND_RANKINGS.STRAIGHT_FLUSH,\n        rankName: 'Straight Flush',\n        tiebreakers: [straightHighCard],\n        description: `Straight Flush, ${this.getCardName(straightHighCard)} high`,\n      };\n    }\n\n    if (groupSizes[0] === 4) {\n      const fourOfAKindRank = this.getRankOfSize(groups, 4);\n      const kicker = this.getRankOfSize(groups, 1);\n      return {\n        rank: HAND_RANKINGS.FOUR_OF_A_KIND,\n        rankName: 'Four of a Kind',\n        tiebreakers: [fourOfAKindRank, kicker],\n        description: `Four of a Kind, ${this.getCardName(fourOfAKindRank)}s`,\n      };\n    }\n\n    if (groupSizes[0] === 3 && groupSizes[1] === 2) {\n      const threeOfAKindRank = this.getRankOfSize(groups, 3);\n      const pairRank = this.getRankOfSize(groups, 2);\n      return {\n        rank: HAND_RANKINGS.FULL_HOUSE,\n        rankName: 'Full House',\n        tiebreakers: [threeOfAKindRank, pairRank],\n        description: `Full House, ${this.getCardName(\n          threeOfAKindRank\n        )}s full of ${this.getCardName(pairRank)}s`,\n      };\n    }\n\n    if (isFlush) {\n      const flushCards = sortedCards.map((c) => c.value);\n      return {\n        rank: HAND_RANKINGS.FLUSH,\n        rankName: 'Flush',\n        tiebreakers: flushCards,\n        description: `Flush, ${this.getCardName(flushCards[0])} high`,\n      };\n    }\n\n    if (straightHighCard) {\n      return {\n        rank: HAND_RANKINGS.STRAIGHT,\n        rankName: 'Straight',\n        tiebreakers: [straightHighCard],\n        description: `Straight, ${this.getCardName(straightHighCard)} high`,\n      };\n    }\n\n    if (groupSizes[0] === 3) {\n      const threeOfAKindRank = this.getRankOfSize(groups, 3);\n      const kickers = this.getKickers(groups, [threeOfAKindRank], 2);\n      return {\n        rank: HAND_RANKINGS.THREE_OF_A_KIND,\n        rankName: 'Three of a Kind',\n        tiebreakers: [threeOfAKindRank, ...kickers],\n        description: `Three of a Kind, ${this.getCardName(threeOfAKindRank)}s`,\n      };\n    }\n\n    if (groupSizes[0] === 2 && groupSizes[1] === 2) {\n      const pairs = this.getRanksOfSize(groups, 2).sort((a, b) => b - a);\n      const kicker = this.getKickers(groups, pairs, 1)[0];\n      return {\n        rank: HAND_RANKINGS.TWO_PAIR,\n        rankName: 'Two Pair',\n        tiebreakers: [...pairs, kicker],\n        description: `Two Pair, ${this.getCardName(pairs[0])}s and ${this.getCardName(pairs[1])}s`,\n      };\n    }\n\n    if (groupSizes[0] === 2) {\n      const pairRank = this.getRankOfSize(groups, 2);\n      const kickers = this.getKickers(groups, [pairRank], 3);\n      return {\n        rank: HAND_RANKINGS.PAIR,\n        rankName: 'Pair',\n        tiebreakers: [pairRank, ...kickers],\n        description: `Pair of ${this.getCardName(pairRank)}s`,\n      };\n    }\n\n    const highCards = sortedCards.map((c) => c.value).slice(0, 5);\n    return {\n      rank: HAND_RANKINGS.HIGH_CARD,\n      rankName: 'High Card',\n      tiebreakers: highCards,\n      description: `High Card, ${this.getCardName(highCards[0])}`,\n    };\n  }\n\n  static checkFlush(cards) {\n    const suits = {};\n    for (const card of cards) {\n      suits[card.suit] = (suits[card.suit] || 0) + 1;\n    }\n    return Object.values(suits).some((count) => count >= 5);\n  }\n\n  static checkStraight(sortedCards) {\n    const values = sortedCards.map((c) => c.value);\n\n    for (let i = 0; i <= values.length - 5; i++) {\n      let isStraight = true;\n      for (let j = 0; j < 4; j++) {\n        if (values[i + j] - values[i + j + 1] !== 1) {\n          isStraight = false;\n          break;\n        }\n      }\n      if (isStraight) {\n        return values[i];\n      }\n    }\n\n    if (\n      values[0] === 14 &&\n      values[values.length - 4] === 5 &&\n      values[values.length - 3] === 4 &&\n      values[values.length - 2] === 3 &&\n      values[values.length - 1] === 2\n    ) {\n      return 5;\n    }\n\n    return null;\n  }\n\n  static groupByRank(cards) {\n    const groups = {};\n    for (const card of cards) {\n      if (!groups[card.value]) {\n        groups[card.value] = [];\n      }\n      groups[card.value].push(card);\n    }\n    return groups;\n  }\n\n  static getRankOfSize(groups, size) {\n    for (const [rank, cards] of Object.entries(groups)) {\n      if (cards.length === size) {\n        return parseInt(rank);\n      }\n    }\n    return null;\n  }\n\n  static getRanksOfSize(groups, size) {\n    const ranks = [];\n    for (const [rank, cards] of Object.entries(groups)) {\n      if (cards.length === size) {\n        ranks.push(parseInt(rank));\n      }\n    }\n    return ranks;\n  }\n\n  static getKickers(groups, usedRanks, count) {\n    const kickers = [];\n    const sortedRanks = Object.keys(groups)\n      .map((r) => parseInt(r))\n      .filter((r) => !usedRanks.includes(r))\n      .sort((a, b) => b - a);\n\n    for (let i = 0; i < count && i < sortedRanks.length; i++) {\n      kickers.push(sortedRanks[i]);\n    }\n\n    return kickers;\n  }\n\n  static compareTiebreakers(a, b) {\n    for (let i = 0; i < Math.min(a.length, b.length); i++) {\n      if (a[i] > b[i]) return 1;\n      if (a[i] < b[i]) return -1;\n    }\n    return 0;\n  }\n\n  static getCardName(value) {\n    const names = {\n      2: 'Two',\n      3: 'Three',\n      4: 'Four',\n      5: 'Five',\n      6: 'Six',\n      7: 'Seven',\n      8: 'Eight',\n      9: 'Nine',\n      10: 'Ten',\n      11: 'Jack',\n      12: 'Queen',\n      13: 'King',\n      14: 'Ace',\n    };\n    return names[value] || value.toString();\n  }\n\n  static getCombinations(arr, size) {\n    const combinations = [];\n\n    function backtrack(start, current) {\n      if (current.length === size) {\n        combinations.push([...current]);\n        return;\n      }\n\n      for (let i = start; i < arr.length; i++) {\n        current.push(arr[i]);\n        backtrack(i + 1, current);\n        current.pop();\n      }\n    }\n\n    backtrack(0, []);\n    return combinations;\n  }\n\n  /**\n   * Compares two evaluated poker hands to determine which is stronger.\n   *\n   * @static\n   * @param {Object} hand1 - First hand evaluation result\n   * @param {Object} hand2 - Second hand evaluation result\n   * @returns {number} 1 if hand1 wins, -1 if hand2 wins, 0 if tie\n   * @example\n   * const result = HandEvaluator.compareHands(straightHand, flushHand);\n   * // Returns: -1 (flush beats straight)\n   */\n  static compareHands(hand1, hand2) {\n    if (hand1.rank > hand2.rank) return 1;\n    if (hand1.rank < hand2.rank) return -1;\n\n    return this.compareTiebreakers(hand1.tiebreakers, hand2.tiebreakers);\n  }\n\n  /**\n   * Determines the winning player(s) from a collection of player hands.\n   * Handles ties by returning multiple winners when hands are equal.\n   *\n   * @static\n   * @param {Object[]} playerHands - Array of {player, cards} objects\n   * @returns {Object[]} Array of {player, hand} objects for winning player(s)\n   * @example\n   * const winners = HandEvaluator.findWinners([\n   *   {player: player1, cards: [...]},\n   *   {player: player2, cards: [...]}\n   * ]);\n   * console.log(`${winners[0].player.name} wins with ${winners[0].hand.description}`);\n   */\n  static findWinners(playerHands) {\n    const evaluatedHands = playerHands.map(({ player, cards }) => ({\n      player,\n      hand: this.evaluateHand(cards),\n    }));\n\n    evaluatedHands.sort((a, b) => this.compareHands(b.hand, a.hand));\n\n    const winners = [evaluatedHands[0]];\n    for (let i = 1; i < evaluatedHands.length; i++) {\n      if (this.compareHands(evaluatedHands[0].hand, evaluatedHands[i].hand) === 0) {\n        winners.push(evaluatedHands[i]);\n      } else {\n        break;\n      }\n    }\n\n    return winners;\n  }\n}\n\nexport default HandEvaluator;\n","import { GAME_PHASES } from '../../constants/game-constants';\nimport Deck from '../entities/Deck';\nimport GameState from '../entities/GameState';\nimport HandEvaluator from '../utils/HandEvaluator';\n\nimport BettingLogic from './BettingLogic';\n\n/**\n * Core poker game engine that orchestrates Texas Hold'em gameplay.\n * Manages game state, player actions, betting rounds, and hand progression.\n *\n * @class GameEngine\n * @example\n * const gameEngine = new GameEngine();\n * gameEngine.addPlayer(new Player('player1', 'Alice', 1000, 0));\n * gameEngine.addPlayer(new Player('player2', 'Bob', 1000, 1));\n * gameEngine.setBlinds(10, 20);\n * gameEngine.startNewHand();\n */\nclass GameEngine {\n  /**\n   * Creates a new GameEngine instance.\n   * Initializes the game state, deck, and event callbacks.\n   *\n   * @constructor\n   */\n  constructor() {\n    this.gameState = new GameState();\n    this.deck = new Deck();\n    this.gameState.deck = this.deck;\n    this._isRestarting = false;\n    this._isInitialized = false;\n    this.callbacks = {\n      onStateChange: null,\n      onHandComplete: null,\n      onPlayerAction: null,\n      onPhaseChange: null,\n      onShowdown: null,\n    };\n  }\n\n  /**\n   * Sets a callback function for a specific game event.\n   *\n   * @param {string} event - The event name ('onStateChange', 'onHandComplete', 'onPlayerAction', 'onPhaseChange', 'onShowdown')\n   * @param {Function} callback - The callback function to execute when the event occurs\n   * @example\n   * gameEngine.setCallback('onStateChange', (gameState) => {\n   *   console.log('Game state updated:', gameState);\n   * });\n   */\n  setCallback(event, callback) {\n    if (Object.prototype.hasOwnProperty.call(this.callbacks, event)) {\n      this.callbacks[event] = callback;\n    }\n  }\n\n  /**\n   * Adds a player to the game.\n   *\n   * @param {Player} player - The player object to add to the game\n   * @throws {Error} If player is invalid or game is full\n   * @example\n   * const player = new Player('player1', 'Alice', 1000, 0);\n   * gameEngine.addPlayer(player);\n   */\n  addPlayer(player) {\n    this.gameState.addPlayer(player);\n    this.notifyStateChange();\n  }\n\n  /**\n   * Removes a player from the game.\n   *\n   * @param {string} playerId - The unique identifier of the player to remove\n   * @example\n   * gameEngine.removePlayer('player1');\n   */\n  removePlayer(playerId) {\n    this.gameState.removePlayer(playerId);\n    this.notifyStateChange();\n  }\n\n  /**\n   * Starts a new poker hand.\n   * Resets players, moves the dealer button, posts blinds, and deals hole cards.\n   *\n   * @throws {Error} If fewer than 2 players are available or deck has insufficient cards\n   * @example\n   * gameEngine.startNewHand();\n   */\n  startNewHand() {\n    try {\n      if (this._isRestarting) {\n        return;\n      }\n\n      // Reset players for new hand first (sets status to ACTIVE)\n      this.gameState.resetForNewHand();\n\n      if (this.gameState.getActivePlayers().length < 2) {\n        throw new Error('Need at least 2 players to start a hand');\n      }\n\n      this.gameState.moveButton();\n\n      // Ensure deck is properly reset and has cards\n      this.deck.reset();\n      if (this.deck.cardsRemaining() < 20) {\n        throw new Error('Deck has insufficient cards');\n      }\n\n      this.postBlinds();\n      this.dealHoleCards();\n\n      this.gameState.currentPlayerIndex = this.gameState.getUTGPosition();\n\n      this.notifyStateChange();\n      this.notifyPhaseChange();\n    } catch (error) {\n      this._isRestarting = false; // Reset the flag on error\n      throw error; // Re-throw to be caught by ErrorBoundary\n    }\n  }\n\n  postBlinds() {\n    const smallBlindPosition = this.gameState.getSmallBlindPosition();\n    const bigBlindPosition = this.gameState.getBigBlindPosition();\n\n    const smallBlindPlayer = this.gameState.getPlayerByPosition(smallBlindPosition);\n    const bigBlindPlayer = this.gameState.getPlayerByPosition(bigBlindPosition);\n\n    if (smallBlindPlayer && smallBlindPlayer.chips > 0) {\n      const sbAmount = Math.min(this.gameState.blinds.small, smallBlindPlayer.chips);\n      smallBlindPlayer.placeBet(sbAmount);\n      this.gameState._internalPot.main += sbAmount;\n\n      this.gameState.addToHistory({\n        playerId: smallBlindPlayer.id,\n        playerName: smallBlindPlayer.name,\n        _action: 'small-blind',\n        amount: sbAmount,\n      });\n    }\n\n    if (bigBlindPlayer && bigBlindPlayer.chips > 0) {\n      const bbAmount = Math.min(this.gameState.blinds.big, bigBlindPlayer.chips);\n      bigBlindPlayer.placeBet(bbAmount);\n      this.gameState._internalPot.main += bbAmount;\n      this.gameState.currentBet = bbAmount;\n\n      this.gameState.addToHistory({\n        playerId: bigBlindPlayer.id,\n        playerName: bigBlindPlayer.name,\n        _action: 'big-blind',\n        amount: bbAmount,\n      });\n    }\n  }\n\n  dealHoleCards() {\n    const activePlayers = this.gameState.getActivePlayers();\n\n    for (let i = 0; i < 2; i++) {\n      for (const player of activePlayers) {\n        const card = this.deck.dealCard();\n        player.holeCards.push(card);\n      }\n    }\n  }\n\n  dealCommunityCards(count) {\n    const cards = this.deck.dealCards(count);\n    this.gameState.communityCards.push(...cards);\n    this.notifyStateChange();\n  }\n\n  /**\n   * Executes a player action (fold, call, raise, check, all-in).\n   * Validates the action, updates game state, and advances the game.\n   *\n   * @param {string} playerId - The unique identifier of the acting player\n   * @param {string} _action - The action to execute ('fold', 'call', 'raise', 'check', 'all-in')\n   * @param {number} [amount=0] - The amount for betting actions (required for 'raise')\n   * @throws {Error} If player not found, cannot act, or action is invalid\n   * @example\n   * gameEngine.executePlayerAction('player1', 'raise', 100);\n   * gameEngine.executePlayerAction('player2', 'fold');\n   * gameEngine.executePlayerAction('player3', 'call');\n   */\n  executePlayerAction(playerId, _action, amount = 0) {\n    try {\n      // Enhanced validation\n      if (!this.gameState || !this.gameState.players) {\n        throw new Error('Game state not initialized');\n      }\n\n      const player = this.gameState.players.find((p) => p && p.id === playerId);\n      if (!player) {\n        // eslint-disable-next-line no-console\n        console.error(\n          'Available players:',\n          this.gameState.players.map((p) => (p ? p.id : 'null'))\n        );\n        throw new Error(`Player with ID '${playerId}' not found in game`);\n      }\n\n      // Check player can act\n      if (!player.canAct()) {\n        throw new Error(`Player '${player.name}' cannot act (status: ${player.status})`);\n      }\n\n      // Enhanced turn validation\n      const currentPlayer = this.gameState.players[this.gameState.currentPlayerIndex];\n      if (!currentPlayer) {\n        throw new Error(`No current player at index ${this.gameState.currentPlayerIndex}`);\n      }\n\n      if (currentPlayer.id !== playerId) {\n        throw new Error(`Not ${player.name}'s turn (current: ${currentPlayer.name})`);\n      }\n\n      BettingLogic.executeAction(this.gameState, player, _action, amount);\n\n      if (this.callbacks.onPlayerAction) {\n        this.callbacks.onPlayerAction(player, _action, amount);\n      }\n\n      // Immediately check for single player wins after any action\n      this.checkAndAdvanceGame();\n\n      // Return success result\n      return {\n        success: true,\n        action: _action,\n        amount,\n        playerId,\n      };\n    } catch (error) {\n      // Enhanced error logging\n      // eslint-disable-next-line no-console\n      console.error('GameEngine executePlayerAction error:', {\n        playerId,\n        _action,\n        amount,\n        gameStateExists: !!this.gameState,\n        playersCount: this.gameState?.players?.length || 0,\n        currentPlayerIndex: this.gameState?.currentPlayerIndex,\n        error: error.message,\n      });\n\n      // Return error result instead of throwing\n      return {\n        success: false,\n        error: error.message,\n        action: _action,\n        amount,\n        playerId,\n      };\n    }\n  }\n\n  checkAndAdvanceGame() {\n    // Get active players (not folded, not sitting out, includes all-in)\n    const activePlayers = this.gameState.getActivePlayers();\n\n    // Single player win: only one active player remaining\n    if (activePlayers.length === 1) {\n      this.handleSinglePlayerWin();\n      return;\n    }\n\n    // Check if all players have folded except one\n    const playersInHand = this.gameState.getPlayersInHand();\n    if (playersInHand.length === 1) {\n      this.handleSinglePlayerWin();\n      return;\n    }\n\n    if (playersInHand.length === 0) {\n      // Edge case: no players in hand (shouldn't happen)\n      this.gameState.phase = 'waiting';\n      this.notifyStateChange();\n      return;\n    }\n\n    // Count players who can still act (not folded, not all-in)\n    const playersWhoCanAct = this.gameState.players.filter((p) => p.canAct());\n\n    // If no one can act but multiple players in hand, all remaining are all-in\n    // Skip directly to showdown\n    if (playersWhoCanAct.length === 0 && playersInHand.length >= 2) {\n      while (this.gameState.phase !== GAME_PHASES.SHOWDOWN) {\n        this.advanceToNextPhase();\n      }\n      return;\n    }\n\n    // Continue normal betting flow\n    if (BettingLogic.isBettingRoundComplete(this.gameState)) {\n      this.advanceToNextPhase();\n    } else {\n      this.moveToNextPlayer();\n    }\n\n    this.notifyStateChange();\n  }\n\n  moveToNextPlayer() {\n    // Count players who can still act (using canAct() method)\n    const playersWhoCanAct = this.gameState.players.filter((p) => p.canAct());\n\n    // If no one can act, check if we should go to showdown\n    if (playersWhoCanAct.length === 0) {\n      const playersInHand = this.gameState.getPlayersInHand();\n      if (playersInHand.length >= 2) {\n        // Multiple players but no one can act - all are all-in, skip to showdown\n        while (this.gameState.phase !== GAME_PHASES.SHOWDOWN) {\n          this.advanceToNextPhase();\n        }\n      }\n      return;\n    }\n\n    // If only 1 player can act, they might need to check/bet but can't be raised\n    // Continue normal flow but check for betting round completion\n\n    this.gameState.currentPlayerIndex = this.gameState.getNextActivePlayerIndex(\n      this.gameState.currentPlayerIndex\n    );\n\n    // If no active player found, advance to next phase\n    if (this.gameState.currentPlayerIndex === -1) {\n      this.advanceToNextPhase();\n      return;\n    }\n\n    // Safety check: verify the current player can actually act\n    const currentPlayer = this.gameState.players[this.gameState.currentPlayerIndex];\n    if (!currentPlayer || !currentPlayer.canAct()) {\n      // Current player can't act, try to find next one or advance phase\n      const nextIndex = this.gameState.getNextActivePlayerIndex(this.gameState.currentPlayerIndex);\n      if (nextIndex === -1) {\n        this.advanceToNextPhase();\n      } else {\n        this.gameState.currentPlayerIndex = nextIndex;\n      }\n    }\n  }\n\n  advanceToNextPhase() {\n    this.resetBettingRound();\n\n    switch (this.gameState.phase) {\n      case GAME_PHASES.PREFLOP:\n        this.gameState.phase = GAME_PHASES.FLOP;\n        this.dealCommunityCards(3);\n        break;\n\n      case GAME_PHASES.FLOP:\n        this.gameState.phase = GAME_PHASES.TURN;\n        this.dealCommunityCards(1);\n        break;\n\n      case GAME_PHASES.TURN:\n        this.gameState.phase = GAME_PHASES.RIVER;\n        this.dealCommunityCards(1);\n        break;\n\n      case GAME_PHASES.RIVER:\n        this.handleShowdown();\n        return;\n    }\n\n    // Find next player who can act\n    const dealerPosition = this.gameState.dealerPosition;\n    this.gameState.currentPlayerIndex = this.gameState.getNextActivePlayerIndex(dealerPosition);\n\n    // If no one can act (everyone is all-in or folded), advance to next phase\n    // This handles the case where all remaining players are all-in\n    if (this.gameState.currentPlayerIndex === -1) {\n      // Check if we should go to showdown (multiple players in hand but none can act)\n      const playersInHand = this.gameState.getPlayersInHand();\n      if (playersInHand.length >= 2) {\n        // Multiple players but no one can act - skip to showdown\n        this.advanceToNextPhase();\n        return;\n      }\n    }\n\n    this.notifyPhaseChange();\n    this.notifyStateChange();\n  }\n\n  resetBettingRound() {\n    this.gameState.currentBet = 0;\n    this.gameState.minimumRaise = this.gameState.blinds.big;\n    this.gameState.lastRaiserIndex = null;\n\n    this.gameState.players.forEach((player) => {\n      player._currentBet = 0;\n      player.lastAction = null;\n    });\n  }\n\n  handleSinglePlayerWin() {\n    const playersInHand = this.gameState.getPlayersInHand();\n    if (playersInHand.length !== 1) {\n      // Invalid state - multiple players in hand\n      return;\n    }\n\n    const winner = playersInHand[0];\n    this.gameState.calculateSidePots();\n\n    const totalPot = this.gameState.getTotalPot();\n    winner.winPot(totalPot);\n\n    this.gameState.winners = [\n      {\n        player: winner,\n        amount: totalPot,\n        handDescription: 'Won by default (others folded)',\n      },\n    ];\n\n    // eslint-disable-next-line no-console\n    // Winner determined by fold\n    this.completeHand();\n  }\n\n  handleShowdown() {\n    this.gameState.phase = GAME_PHASES.SHOWDOWN;\n    this.gameState.calculateSidePots();\n\n    const playerHands = this.gameState.getPlayersInHand().map((player) => ({\n      player,\n      cards: [...player.holeCards, ...this.gameState.communityCards],\n    }));\n\n    const mainPotWinners = HandEvaluator.findWinners(playerHands);\n    const mainPotAmount = this.gameState._internalPot.main;\n    const mainPotShare = Math.floor(mainPotAmount / mainPotWinners.length);\n\n    this.gameState.winners = [];\n\n    mainPotWinners.forEach(({ player, hand }) => {\n      player.winPot(mainPotShare);\n      this.gameState.winners.push({\n        player,\n        amount: mainPotShare,\n        hand,\n        handDescription: hand.description,\n      });\n    });\n\n    for (const sidePot of this.gameState._internalPot.side) {\n      const eligibleHands = playerHands.filter(({ player }) =>\n        sidePot.eligiblePlayers.includes(player)\n      );\n\n      const sidePotWinners = HandEvaluator.findWinners(eligibleHands);\n      const sidePotShare = Math.floor(sidePot.amount / sidePotWinners.length);\n\n      sidePotWinners.forEach(({ player, hand }) => {\n        player.winPot(sidePotShare);\n\n        const existingWinner = this.gameState.winners.find((w) => w.player === player);\n        if (existingWinner) {\n          existingWinner.amount += sidePotShare;\n        } else {\n          this.gameState.winners.push({\n            player,\n            amount: sidePotShare,\n            hand,\n            handDescription: hand.description,\n          });\n        }\n      });\n    }\n\n    if (this.callbacks.onShowdown) {\n      this.callbacks.onShowdown(this.gameState.winners);\n    }\n\n    this.completeHand();\n  }\n\n  completeHand() {\n    if (this.callbacks.onHandComplete) {\n      this.callbacks.onHandComplete(this.gameState.winners);\n    }\n\n    // Store winners before resetting\n    const winners = this.gameState.winners;\n\n    // Reset phase to waiting after hand completion\n    this.gameState.phase = 'waiting';\n    this.notifyStateChange();\n\n    // Auto-progress to next hand after 3 seconds\n    setTimeout(() => {\n      try {\n        // Check if we still have enough players with chips\n        const playersWithChips = this.gameState.players.filter((p) => p.isActive && p.chips > 0);\n\n        if (playersWithChips.length >= 2 && !this._isRestarting) {\n          this.startNewHand();\n        }\n      } catch (error) {\n        // eslint-disable-next-line no-console\n        console.error('Failed to auto-start new hand:', error);\n        this._isRestarting = false;\n      }\n    }, 3000);\n\n    // Return the winners info\n    return {\n      winners,\n    };\n  }\n\n  /**\n   * Gets the list of valid actions for a specific player.\n   *\n   * @param {string} playerId - The unique identifier of the player\n   * @returns {string[]} Array of valid action names ('fold', 'call', 'raise', 'check', 'all-in')\n   * @example\n   * const actions = gameEngine.getValidActions('player1');\n   * // Returns: ['fold', 'call', 'raise']\n   */\n  getValidActions(playerId) {\n    // Enhanced validation for getting valid actions\n    if (!this.gameState || !this.gameState.players) {\n      // eslint-disable-next-line no-console\n      console.warn('getValidActions: No game state or players');\n      return [];\n    }\n\n    const player = this.gameState.players.find((p) => p && p.id === playerId);\n    if (!player) {\n      // eslint-disable-next-line no-console\n      console.warn(`getValidActions: Player '${playerId}' not found`);\n      return [];\n    }\n\n    const currentPlayer = this.getCurrentPlayer();\n    if (!currentPlayer) {\n      // eslint-disable-next-line no-console\n      console.warn('getValidActions: No current player');\n      return [];\n    }\n\n    if (currentPlayer.id !== playerId) {\n      // This is normal - player is not currently acting\n      return [];\n    }\n\n    // Player can act - get valid actions from betting logic\n    try {\n      return BettingLogic.getValidActions(this.gameState, player);\n    } catch (error) {\n      // eslint-disable-next-line no-console\n      console.error('getValidActions: Error getting valid actions:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Gets the current serialized game state.\n   * Returns a snapshot of the game state suitable for UI rendering.\n   *\n   * @returns {Object} Serialized game state object containing players, pot, cards, phase, etc.\n   * @example\n   * const state = gameEngine.getGameState();\n   * console.log(`Current phase: ${state.phase}, Pot: ${state.pot.main}`);\n   */\n  getGameState() {\n    return this.gameState.serialize();\n  }\n\n  notifyStateChange() {\n    if (this.callbacks.onStateChange) {\n      this.callbacks.onStateChange(this.getGameState());\n    }\n  }\n\n  notifyPhaseChange() {\n    if (this.callbacks.onPhaseChange) {\n      this.callbacks.onPhaseChange(this.gameState.phase);\n    }\n  }\n\n  /**\n   * Sets the blind amounts for the game.\n   *\n   * @param {number} small - The small blind amount\n   * @param {number} big - The big blind amount\n   * @example\n   * gameEngine.setBlinds(10, 20); // Sets small blind to 10, big blind to 20\n   */\n  setBlinds(small, big) {\n    this.gameState.blinds = { small, big };\n    this.gameState.minimumRaise = big;\n  }\n\n  /**\n   * Gets the hole cards for a specific player.\n   *\n   * @param {string} playerId - The unique identifier of the player\n   * @returns {Card[]} Array of the player's hole cards (empty array if player not found)\n   * @example\n   * const cards = gameEngine.getPlayerCards('player1');\n   * // Returns: [Card{rank: 'A', suit: 's'}, Card{rank: 'K', suit: 'h'}]\n   */\n  getPlayerCards(playerId) {\n    const player = this.gameState.players.find((p) => p.id === playerId);\n    return player ? player.holeCards : [];\n  }\n\n  /**\n   * Gets the hole cards for all players in the game.\n   *\n   * @returns {Object[]} Array of objects containing playerId and cards\n   * @example\n   * const allCards = gameEngine.getAllPlayerCards();\n   * // Returns: [{playerId: 'player1', cards: [Card, Card]}, ...]\n   */\n  getAllPlayerCards() {\n    return this.gameState.players.map((player) => ({\n      playerId: player.id,\n      cards: player.holeCards,\n    }));\n  }\n\n  /**\n   * Gets a copy of the community cards currently on the board.\n   *\n   * @returns {Card[]} Array of community cards (0-5 cards depending on game phase)\n   * @example\n   * const board = gameEngine.getCommunityCards();\n   * // Returns: [Card, Card, Card] on the flop\n   */\n  getCommunityCards() {\n    return [...this.gameState.communityCards];\n  }\n\n  /**\n   * Gets the player who is currently acting.\n   *\n   * @returns {Player|undefined} The current player object, or undefined if no current player\n   * @example\n   * const currentPlayer = gameEngine.getCurrentPlayer();\n   * console.log(`${currentPlayer.name} is up to act`);\n   */\n  getCurrentPlayer() {\n    // Enhanced safety checks for current player access\n    if (!this.gameState || !this.gameState.players || this.gameState.players.length === 0) {\n      return undefined;\n    }\n\n    const index = this.gameState.currentPlayerIndex;\n    if (index < 0 || index >= this.gameState.players.length) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `Invalid currentPlayerIndex: ${index}, players length: ${this.gameState.players.length}`\n      );\n      return undefined;\n    }\n\n    const player = this.gameState.players[index];\n    if (!player) {\n      // eslint-disable-next-line no-console\n      console.warn(`No player found at index: ${index}`);\n      return undefined;\n    }\n\n    return player;\n  }\n\n  /**\n   * Calculates pot odds for a specific player's current situation.\n   *\n   * @param {string} playerId - The unique identifier of the player\n   * @returns {number} Pot odds as a percentage (0-100), or 0 if player not found\n   * @example\n   * const odds = gameEngine.getPotOdds('player1');\n   * console.log(`Pot odds: ${odds.toFixed(1)}%`);\n   */\n  getPotOdds(playerId) {\n    const player = this.gameState.players.find((p) => p.id === playerId);\n    if (!player) return 0;\n\n    return BettingLogic.calculatePotOdds(this.gameState, player);\n  }\n}\n\nexport default GameEngine;\n","import { PLAYER_STATUS } from '../../constants/game-constants';\n\nclass Player {\n  constructor(id, name, chips, position = null, isAI = false, aiType = null) {\n    this.id = id;\n    this.name = name;\n    this.chips = chips;\n    this.position = position;\n    this._position = position; // Alias for compatibility\n\n    // Handle AI type parameter - if aiType is passed as 3rd parameter (old style)\n    if (typeof isAI === 'string') {\n      this.aiType = isAI;\n      this.isAI = true;\n    } else {\n      this.isAI = isAI;\n      this.aiType = aiType || undefined;\n    }\n\n    this.holeCards = [];\n    this.cards = this.holeCards; // Alias for compatibility\n    this.status = PLAYER_STATUS.WAITING;\n    this._currentBet = 0;\n    this.totalBetThisRound = 0; // Alias for currentBet\n    this.totalPotContribution = 0;\n    this.lastAction = null;\n\n    // Boolean properties for compatibility\n    this.isActive = true;\n    this.isFolded = false;\n    this.isAllIn = false;\n    this.isDealer = false;\n\n    this.stats = {\n      handsPlayed: 0,\n      handsWon: 0,\n      biggestPotWon: 0,\n      totalWinnings: 0,\n      vpip: 0,\n      pfr: 0,\n      aggression: 0,\n    };\n  }\n\n  setHoleCards(cards) {\n    this.holeCards = cards;\n    this.cards = this.holeCards; // Keep alias in sync\n  }\n\n  receiveCards(cards) {\n    this.setHoleCards(cards);\n  }\n\n  clearHoleCards() {\n    this.holeCards = [];\n    this.cards = this.holeCards; // Keep alias in sync\n  }\n\n  placeBet(amount) {\n    if (amount < 0) {\n      throw new Error('Bet amount cannot be negative');\n    }\n\n    if (amount > this.chips) {\n      throw new Error('Insufficient chips');\n    }\n\n    const betAmount = Math.min(amount, this.chips);\n    this.chips -= betAmount;\n    this._currentBet += betAmount;\n    this.totalBetThisRound += betAmount;\n    this.totalPotContribution += betAmount;\n\n    if (this.chips === 0) {\n      this.status = PLAYER_STATUS.ALL_IN;\n      this.isAllIn = true;\n    }\n\n    return betAmount;\n  }\n\n  fold() {\n    this.status = PLAYER_STATUS.FOLDED;\n    this.lastAction = 'fold';\n    this.isFolded = true;\n    this.clearHoleCards();\n  }\n\n  check() {\n    this.lastAction = 'check';\n    this.status = PLAYER_STATUS.CHECKED;\n  }\n\n  call(amount) {\n    // Handle all-in case - call with all remaining chips if not enough\n    const callAmount = amount > this.chips ? this.chips : amount;\n    const actualAmount = this.placeBet(callAmount);\n    this.lastAction = 'call';\n\n    // If player used all chips, they're all-in, otherwise they called\n    if (this.chips === 0) {\n      this.status = PLAYER_STATUS.ALL_IN;\n    } else {\n      this.status = PLAYER_STATUS.CALLED;\n    }\n\n    return actualAmount;\n  }\n\n  bet(amount) {\n    const betAmount = this.placeBet(amount);\n    this.lastAction = 'bet';\n    return betAmount;\n  }\n\n  raise(amount) {\n    if (amount <= this._currentBet) {\n      throw new Error('Raise amount must be greater than current bet');\n    }\n\n    // Calculate the additional amount to raise to the target\n    const additionalAmount = amount - this._currentBet;\n    const raiseAmount = this.placeBet(additionalAmount);\n    this.lastAction = 'raise';\n    this.status = PLAYER_STATUS.RAISED;\n    return raiseAmount;\n  }\n\n  winPot(amount) {\n    if (amount < 0) {\n      throw new Error('Win amount cannot be negative');\n    }\n\n    this.chips += amount;\n    this.stats.handsWon++;\n    this.stats.totalWinnings += amount;\n\n    if (amount > this.stats.biggestPotWon) {\n      this.stats.biggestPotWon = amount;\n    }\n  }\n\n  resetForNewHand() {\n    this.clearHoleCards();\n    this.status = PLAYER_STATUS.WAITING;\n    this._currentBet = 0;\n    this.totalBetThisRound = 0;\n    this.totalPotContribution = 0;\n    this.lastAction = null;\n    this.isActive = true; // Players should be active and ready to act\n    this.isFolded = false;\n    this.isAllIn = false;\n    this.stats.handsPlayed++;\n  }\n\n  resetBettingRound() {\n    this._currentBet = 0;\n    this.totalBetThisRound = 0;\n\n    // Don't reset folded or all-in status\n    if (this.status !== PLAYER_STATUS.FOLDED && this.status !== PLAYER_STATUS.ALL_IN) {\n      this.status = PLAYER_STATUS.WAITING;\n    }\n  }\n\n  checkIfActive() {\n    return this.status === PLAYER_STATUS.ACTIVE || this.status === PLAYER_STATUS.ALL_IN;\n  }\n\n  canAct() {\n    return (\n      this.isActive &&\n      this.chips > 0 &&\n      this.status !== PLAYER_STATUS.FOLDED &&\n      this.status !== PLAYER_STATUS.ALL_IN\n    );\n  }\n\n  isInHand() {\n    return (\n      this.isActive &&\n      this.status !== PLAYER_STATUS.FOLDED &&\n      this.status !== PLAYER_STATUS.SITTING_OUT\n    );\n  }\n\n  decideAction(gameState) {\n    // This method should only be called for AI players\n    if (!this.isAI) {\n      throw new Error('decideAction can only be called on AI players');\n    }\n\n    // Import AIPlayer service dynamically to avoid circular dependencies\n    const AIPlayer = require('../engine/AIPlayer').default;\n    const BettingLogic = require('../engine/BettingLogic').default;\n\n    // Get valid actions for this player\n    const validActions = BettingLogic.getValidActions(gameState, this);\n\n    // Get AI decision\n    return AIPlayer.getAction(this, gameState, validActions, {\n      getPlayerCards: () => this.holeCards,\n      getCommunityCards: () => gameState.communityCards,\n    });\n  }\n\n  toJSON() {\n    return {\n      id: this.id,\n      name: this.name,\n      chips: this.chips,\n      _currentBet: this._currentBet,\n      _position: this._position,\n      cards: this.cards,\n      isAI: this.isAI,\n      aiType: this.aiType,\n      status: this.status,\n      isActive: this.isActive,\n      isFolded: this.isFolded,\n      isAllIn: this.isAllIn,\n      isDealer: this.isDealer,\n      totalBetThisRound: this.totalBetThisRound,\n    };\n  }\n\n  getNetPosition() {\n    return this.chips - this.totalPotContribution;\n  }\n\n  updateStats(_action, phase) {\n    if (phase === 'preflop' && _action !== 'fold') {\n      this.stats.vpip++;\n    }\n\n    if (phase === 'preflop' && (_action === 'bet' || _action === 'raise')) {\n      this.stats.pfr++;\n    }\n\n    if (_action === 'bet' || _action === 'raise') {\n      this.stats.aggression++;\n    }\n  }\n\n  serialize() {\n    return {\n      id: this.id,\n      name: this.name,\n      chips: this.chips,\n      position: this.position,\n      isAI: this.isAI,\n      aiType: this.aiType,\n      status: this.status,\n      currentBet: this._currentBet,\n      lastAction: this.lastAction,\n      hasCards: this.holeCards.length > 0,\n      holeCards: this.isAI\n        ? null\n        : this.holeCards.map((card) => ({ rank: card.rank, suit: card.suit })),\n    };\n  }\n\n  get currentBet() {\n    return this._currentBet;\n  }\n\n  set currentBet(value) {\n    this._currentBet = value;\n  }\n}\n\nexport default Player;\n","import { useState, useEffect, useCallback, useMemo, useRef } from 'react';\n\nimport { GAME_PHASES } from '../constants/game-constants';\nimport AIPlayer from '../game/engine/AIPlayer';\nimport GameEngine from '../game/engine/GameEngine';\nimport Player from '../game/entities/Player';\n\nimport useHandHistory from './useHandHistory';\n\n/**\n * Custom hook for managing poker game state and logic\n * @param {string} humanPlayerId - ID of the human player\n * @param {Object} options - Configuration options\n * @returns {Object} Game state and control functions\n */\nconst usePokerGame = (humanPlayerId, options = {}) => {\n  const {\n    initialChips = 10000,\n    smallBlind = 50,\n    bigBlind = 100,\n    aiPlayers = [\n      { name: 'Alex (TAG)', type: 'tight-aggressive' },\n      { name: 'Sarah (LAG)', type: 'loose-aggressive' },\n      { name: 'Mike (TP)', type: 'tight-passive' },\n      { name: 'Lisa (LP)', type: 'loose-passive' },\n      { name: 'John (TAG)', type: 'tight-aggressive' },\n    ],\n    onStateChange,\n    onShowdown,\n    onPhaseChange,\n    onPlayerAction,\n  } = options;\n\n  const [gameEngine] = useState(() => new GameEngine());\n  const [gameState, setGameState] = useState(null);\n  const [showControls, setShowControls] = useState(false);\n  const [validActions, setValidActions] = useState([]);\n  const [showdown, setShowdown] = useState(false);\n  const [isProcessingAI, setIsProcessingAI] = useState(false);\n  const [error, setError] = useState(null);\n  const [isGameActive, setIsGameActive] = useState(false);\n\n  // Use ref to track processing state to avoid stale closure issues\n  const isProcessingRef = useRef(false);\n  const gameEngineRef = useRef(gameEngine);\n\n  // Initialize hand history tracking\n  const handHistory = useHandHistory();\n\n  // Process a single AI turn and return whether to continue\n  const processSingleAITurn = useCallback(() => {\n    const engine = gameEngineRef.current;\n\n    // Check game phase - don't process during waiting or showdown\n    const currentGameState = engine.getGameState();\n    if (currentGameState.phase === 'waiting' || currentGameState.phase === 'showdown') {\n      return false;\n    }\n\n    const currentPlayer = engine.getCurrentPlayer();\n\n    // Check if we should process this player\n    if (!currentPlayer || !currentPlayer.isAI) {\n      return false;\n    }\n\n    // Use canAct() method to check if player can act (not folded, not all-in, has chips)\n    if (!currentPlayer.canAct()) {\n      return false;\n    }\n\n    // Get valid actions for this AI\n    const actions = engine.getValidActions(currentPlayer.id);\n\n    // If no valid actions, player can't act\n    if (!actions || actions.length === 0) {\n      return false;\n    }\n\n    const aiAction = AIPlayer.getAction(currentPlayer, currentGameState, actions, engine);\n\n    const result = engine.executePlayerAction(currentPlayer.id, aiAction.action, aiAction.amount);\n\n    if (!result.success) {\n      // eslint-disable-next-line no-console\n      console.error('AI action failed:', result.error);\n      return false;\n    }\n\n    // Check if game ended (e.g., everyone else folded)\n    const updatedState = engine.getGameState();\n    if (updatedState.phase === 'waiting' || updatedState.phase === 'showdown') {\n      return false;\n    }\n\n    // Check if next player is also AI and can act\n    const nextPlayer = engine.getCurrentPlayer();\n    return nextPlayer && nextPlayer.isAI && nextPlayer.canAct();\n  }, []);\n\n  // Process all AI turns in sequence\n  const processAITurns = useCallback(() => {\n    // Strict guard - only one processing chain at a time\n    if (isProcessingRef.current) {\n      return;\n    }\n\n    const engine = gameEngineRef.current;\n\n    // Check game phase - don't process during waiting or showdown\n    const currentGameState = engine.getGameState();\n    if (currentGameState.phase === 'waiting' || currentGameState.phase === 'showdown') {\n      return;\n    }\n\n    const currentPlayer = engine.getCurrentPlayer();\n\n    // Only start if it's actually an AI's turn and they can act\n    if (!currentPlayer || !currentPlayer.isAI || !currentPlayer.canAct()) {\n      return;\n    }\n\n    // Lock processing\n    isProcessingRef.current = true;\n    setIsProcessingAI(true);\n\n    // Process AI turns with delays between each\n    const processNext = () => {\n      try {\n        const shouldContinue = processSingleAITurn();\n\n        if (shouldContinue) {\n          // More AI to process - continue after delay\n          setTimeout(processNext, 800);\n        } else {\n          // Done processing - unlock\n          isProcessingRef.current = false;\n          setIsProcessingAI(false);\n        }\n      } catch (err) {\n        // eslint-disable-next-line no-console\n        console.error('AI processing error:', err);\n        setError(`AI action failed: ${err.message}`);\n        isProcessingRef.current = false;\n        setIsProcessingAI(false);\n      }\n    };\n\n    // Start processing after initial delay\n    setTimeout(processNext, 800);\n  }, [processSingleAITurn]);\n\n  // Initialize game with players\n  const initializeGame = useCallback(() => {\n    try {\n      const engine = gameEngineRef.current;\n\n      // Prevent multiple initializations\n      if (engine._isInitialized) {\n        return;\n      }\n\n      engine._isInitialized = true;\n\n      // Add human player\n      const humanPlayer = new Player(humanPlayerId, 'You', initialChips, 0, false);\n      engine.addPlayer(humanPlayer);\n\n      // Add AI players\n      aiPlayers.forEach((aiConfig, idx) => {\n        const aiPlayer = new Player(\n          `ai-${idx + 1}`,\n          aiConfig.name,\n          initialChips,\n          idx + 1,\n          true,\n          aiConfig.type\n        );\n        engine.addPlayer(aiPlayer);\n      });\n\n      engine.setBlinds(smallBlind, bigBlind);\n\n      // Start first hand after a delay\n      setTimeout(() => {\n        try {\n          setIsGameActive(true);\n          engine.startNewHand();\n        } catch (err) {\n          setError(`Failed to start new hand: ${err.message}`);\n          engine._isInitialized = false;\n          setIsGameActive(false);\n        }\n      }, 1000);\n    } catch (err) {\n      setError(`Failed to initialize game: ${err.message}`);\n      gameEngineRef.current._isInitialized = false;\n    }\n  }, [humanPlayerId, initialChips, smallBlind, bigBlind, aiPlayers]);\n\n  // Initialize game callbacks\n  useEffect(() => {\n    const engine = gameEngineRef.current;\n\n    // Prevent duplicate callback setup\n    if (engine._callbacksInitialized) {\n      return;\n    }\n    engine._callbacksInitialized = true;\n\n    engine.setCallback('onStateChange', (newState) => {\n      // Add timestamp to ensure React sees a new object reference\n      const stateWithTimestamp = {\n        ...newState,\n        _updateTimestamp: Date.now(),\n      };\n      setGameState(stateWithTimestamp);\n      setError(null);\n\n      // Use getCurrentPlayer() from engine for most up-to-date info\n      const currentPlayer = engine.getCurrentPlayer();\n      if (currentPlayer && currentPlayer.id === humanPlayerId) {\n        const actions = engine.getValidActions(humanPlayerId);\n        setValidActions(actions);\n        setShowControls(true);\n      } else {\n        setShowControls(false);\n        setValidActions([]);\n      }\n\n      if (onStateChange) {\n        onStateChange(newState);\n      }\n    });\n\n    engine.setCallback('onShowdown', (winners) => {\n      setShowdown(true);\n      setTimeout(() => setShowdown(false), 5000);\n\n      if (onShowdown) {\n        onShowdown(winners);\n      }\n    });\n\n    engine.setCallback('onPhaseChange', (phase) => {\n      if (phase !== GAME_PHASES.SHOWDOWN) {\n        setShowdown(false);\n      }\n\n      if (onPhaseChange) {\n        onPhaseChange(phase);\n      }\n    });\n\n    engine.setCallback('onPlayerAction', (player, action, amount) => {\n      // Capture action in hand history\n      if (isGameActive && handHistory.isSessionActive) {\n        handHistory.captureAction(player.id, action, amount);\n      }\n\n      if (onPlayerAction) {\n        onPlayerAction(player, action, amount);\n      }\n    });\n\n    initializeGame();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [humanPlayerId, initializeGame]);\n\n  // Handle human player action\n  const executeAction = useCallback(\n    (action, amount) => {\n      try {\n        setError(null);\n        const engine = gameEngineRef.current;\n        const result = engine.executePlayerAction(humanPlayerId, action, amount);\n\n        // Check if action succeeded\n        if (!result.success) {\n          setError(`Action failed: ${result.error}`);\n          return;\n        }\n\n        // Reset processing flag to ensure fresh start for AI turns\n        isProcessingRef.current = false;\n\n        // Process AI turns after human action (with delay)\n        // Using a longer delay to ensure state has propagated\n        setTimeout(() => {\n          // Double-check current player is AI before processing\n          const currentPlayer = engine.getCurrentPlayer();\n          if (currentPlayer && currentPlayer.isAI && currentPlayer.canAct()) {\n            processAITurns();\n          }\n        }, 600);\n      } catch (err) {\n        setError(`Action failed: ${err.message}`);\n      }\n    },\n    [humanPlayerId, processAITurns]\n  );\n\n  // Get current player info (memoized for performance)\n  const getCurrentPlayerInfo = useMemo(() => {\n    if (!gameState || !gameState.players || gameState.players.length === 0) {\n      return { humanPlayer: null, currentPlayer: null, isHumanTurn: false };\n    }\n\n    const humanPlayer = gameState.players.find((p) => p && p.id === humanPlayerId);\n\n    // Safe player access with bounds checking\n    const currentPlayer =\n      gameState.currentPlayerIndex >= 0 && gameState.currentPlayerIndex < gameState.players.length\n        ? gameState.players[gameState.currentPlayerIndex]\n        : null;\n\n    const isHumanTurn = currentPlayer && humanPlayer && currentPlayer.id === humanPlayer.id;\n\n    return {\n      humanPlayer,\n      currentPlayer,\n      isHumanTurn,\n    };\n  }, [gameState, humanPlayerId]);\n\n  // Auto-process AI turns when it's their turn (with debounce)\n  useEffect(() => {\n    if (!gameState) return;\n\n    // Don't start if already processing\n    if (isProcessingRef.current) {\n      return;\n    }\n\n    // Skip if in waiting or showdown phase\n    if (gameState.phase === 'waiting' || gameState.phase === 'showdown') {\n      return;\n    }\n\n    const engine = gameEngineRef.current;\n    const currentPlayer = engine.getCurrentPlayer();\n\n    // If no current player, something is wrong - skip\n    if (!currentPlayer) {\n      return;\n    }\n\n    // Check if current player is AI and can act\n    if (currentPlayer.isAI && currentPlayer.canAct()) {\n      // Use timeout to debounce and prevent race conditions\n      const timeoutId = setTimeout(() => {\n        // Double-check conditions before processing\n        if (!isProcessingRef.current) {\n          const stillCurrentPlayer = engine.getCurrentPlayer();\n          if (stillCurrentPlayer && stillCurrentPlayer.isAI && stillCurrentPlayer.canAct()) {\n            processAITurns();\n          }\n        }\n      }, 150);\n\n      return () => clearTimeout(timeoutId);\n    }\n\n    // DEFENSIVE FIX: If current player can't act (all-in, folded, etc.),\n    // trigger game advancement. This handles edge cases where the game engine\n    // didn't properly advance past a non-acting player.\n    if (!currentPlayer.canAct() && currentPlayer.isAI) {\n      const timeoutId = setTimeout(() => {\n        // Force the game engine to advance to next player or phase\n        const checkEngine = gameEngineRef.current;\n        const checkPlayer = checkEngine.getCurrentPlayer();\n\n        // Only trigger if still stuck on a non-acting player\n        if (checkPlayer && !checkPlayer.canAct()) {\n          // Call checkAndAdvanceGame to force game progression\n          checkEngine.checkAndAdvanceGame();\n        }\n      }, 200);\n\n      return () => clearTimeout(timeoutId);\n    }\n  }, [gameState, processAITurns]);\n\n  return {\n    // State\n    gameState,\n    showControls,\n    validActions,\n    showdown,\n    isProcessingAI,\n    error,\n    isGameActive,\n\n    // Functions\n    executeAction,\n    getCurrentPlayerInfo,\n\n    // Engine reference (for advanced features)\n    gameEngine,\n\n    // Human player ID\n    humanPlayerId,\n\n    // Hand history\n    handHistory,\n  };\n};\n\nexport default usePokerGame;\n","import React, { useState, useEffect, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport './BettingControls.css';\n\nconst BettingControls = React.memo(\n  ({ validActions, _currentBet, playerChips, playerBet, _pot, onAction, minBet, minRaise }) => {\n    const callAmount = Math.max(0, (_currentBet || 0) - (playerBet || 0));\n    const [betAmount, setBetAmount] = useState(minBet || minRaise || 0);\n\n    useEffect(() => {\n      if (validActions.includes('bet')) {\n        setBetAmount(minBet);\n      } else if (validActions.includes('raise')) {\n        setBetAmount(minRaise);\n      }\n    }, [validActions, minBet, minRaise]);\n\n    const handleSliderChange = useCallback((e) => {\n      setBetAmount(parseInt(e.target.value));\n    }, []);\n\n    const handleInputChange = useCallback(\n      (e) => {\n        const value = parseInt(e.target.value) || 0;\n        setBetAmount(Math.min(value, playerChips));\n      },\n      [playerChips]\n    );\n\n    const setPresetBet = useCallback(\n      (fraction) => {\n        let amount;\n        if (fraction === 'all') {\n          amount = playerChips || 0;\n        } else {\n          amount = Math.floor((_pot || 0) * fraction);\n        }\n\n        if (validActions.includes('bet')) {\n          amount = Math.max(amount, minBet || 0);\n        } else if (validActions.includes('raise')) {\n          amount = Math.max(amount, minRaise || 0);\n        }\n\n        setBetAmount(Math.min(amount, playerChips || 0));\n      },\n      [_pot, playerChips, minBet, minRaise, validActions]\n    );\n\n    const getPotOdds = () => {\n      if (callAmount === 0) return null;\n      const potAfterCall = (_pot || 0) + callAmount;\n      if (potAfterCall === 0) return null;\n      const odds = ((callAmount / potAfterCall) * 100).toFixed(1);\n      return odds;\n    };\n\n    const potOdds = getPotOdds();\n\n    return (\n      <div\n        className=\"betting-controls\"\n        role=\"region\"\n        aria-label=\"Betting controls\"\n        aria-describedby=\"betting-info pot-odds\"\n      >\n        <div className=\"betting-info\" id=\"betting-info\" role=\"group\" aria-label=\"Game information\">\n          <div className=\"betting-info-item\">\n            <span className=\"betting-info-label\">Pot</span>\n            <span className=\"betting-info-value\">${_pot || 0}</span>\n          </div>\n          <div className=\"betting-info-item\">\n            <span className=\"betting-info-label\">To Call</span>\n            <span className=\"betting-info-value\">${callAmount || 0}</span>\n          </div>\n          <div className=\"betting-info-item\">\n            <span className=\"betting-info-label\">Your Stack</span>\n            <span className=\"betting-info-value\">${playerChips || 0}</span>\n          </div>\n        </div>\n\n        {(validActions.includes('bet') || validActions.includes('raise')) && (\n          <div className=\"betting-slider-container\" role=\"group\" aria-label=\"Bet amount controls\">\n            <div className=\"bet-amount-display\">\n              <label htmlFor=\"bet-amount-input\" className=\"bet-amount-label\">\n                {validActions.includes('bet') ? 'Bet Amount:' : 'Raise To:'}\n              </label>\n              <input\n                id=\"bet-amount-input\"\n                type=\"number\"\n                className=\"bet-amount-input\"\n                value={betAmount}\n                onChange={handleInputChange}\n                min={validActions.includes('bet') ? minBet : minRaise}\n                max={playerChips}\n                aria-describedby=\"bet-range-slider\"\n                aria-label={`${validActions.includes('bet') ? 'Bet' : 'Raise'} amount in dollars`}\n              />\n            </div>\n\n            <input\n              id=\"bet-range-slider\"\n              type=\"range\"\n              className=\"betting-slider\"\n              min={validActions.includes('bet') ? minBet : minRaise}\n              max={playerChips}\n              value={betAmount}\n              onChange={handleSliderChange}\n              aria-label={`Adjust ${validActions.includes('bet') ? 'bet' : 'raise'} amount with slider`}\n              aria-valuemin={validActions.includes('bet') ? minBet : minRaise}\n              aria-valuemax={playerChips}\n              aria-valuenow={betAmount}\n              aria-valuetext={`$${betAmount}`}\n            />\n\n            <div className=\"preset-buttons\" role=\"group\" aria-label=\"Preset bet amounts\">\n              <button\n                className=\"preset-button\"\n                onClick={() => setPresetBet(1 / 3)}\n                aria-label={`Set bet to one third of pot: $${Math.floor((_pot || 0) / 3)}`}\n              >\n                1/3 Pot\n              </button>\n              <button\n                className=\"preset-button\"\n                onClick={() => setPresetBet(1 / 2)}\n                aria-label={`Set bet to half of pot: $${Math.floor((_pot || 0) / 2)}`}\n              >\n                1/2 Pot\n              </button>\n              <button\n                className=\"preset-button\"\n                onClick={() => setPresetBet(1)}\n                aria-label={`Set bet to full pot: $${_pot || 0}`}\n              >\n                Pot\n              </button>\n              <button\n                className=\"preset-button\"\n                onClick={() => setPresetBet('all')}\n                aria-label={`Go all in with all chips: $${playerChips}`}\n              >\n                All In\n              </button>\n            </div>\n          </div>\n        )}\n\n        <div className=\"action-buttons\" role=\"group\" aria-label=\"Poker action buttons\">\n          {validActions.includes('fold') && (\n            <button\n              className=\"action-button fold\"\n              onClick={() => onAction('fold')}\n              aria-label=\"Fold your hand and forfeit this round\"\n              aria-describedby=\"betting-info\"\n            >\n              Fold\n            </button>\n          )}\n\n          {validActions.includes('check') && (\n            <button\n              className=\"action-button check\"\n              onClick={() => onAction('check')}\n              aria-label=\"Check - no bet required\"\n              aria-describedby=\"betting-info\"\n            >\n              Check\n            </button>\n          )}\n\n          {validActions.includes('call') && (\n            <button\n              className=\"action-button call\"\n              onClick={() => onAction('call', callAmount)}\n              aria-label={`Call the current bet of $${callAmount || 0}`}\n              aria-describedby=\"betting-info\"\n            >\n              Call ${callAmount || 0}\n            </button>\n          )}\n\n          {validActions.includes('bet') && (\n            <button\n              className=\"action-button bet\"\n              onClick={() => onAction('bet', betAmount)}\n              disabled={betAmount < minBet || betAmount > playerChips}\n              aria-label={`Bet $${betAmount}`}\n              aria-describedby=\"betting-info bet-amount-input\"\n              aria-disabled={betAmount < minBet || betAmount > playerChips}\n            >\n              Bet ${betAmount}\n            </button>\n          )}\n\n          {validActions.includes('raise') && (\n            <button\n              className=\"action-button raise\"\n              onClick={() => onAction('raise', betAmount)}\n              disabled={betAmount < minRaise || betAmount > playerChips}\n              aria-label={`Raise the bet to $${betAmount}`}\n              aria-describedby=\"betting-info bet-amount-input\"\n              aria-disabled={betAmount < minRaise || betAmount > playerChips}\n            >\n              Raise to ${betAmount}\n            </button>\n          )}\n\n          {validActions.includes('all-in') && (\n            <button\n              className=\"action-button all-in\"\n              onClick={() => onAction('all-in', playerChips)}\n              aria-label={`Go all in with all your chips: $${playerChips}`}\n              aria-describedby=\"betting-info\"\n            >\n              All In ${playerChips}\n            </button>\n          )}\n        </div>\n\n        {potOdds && (\n          <div\n            className=\"pot-odds-display\"\n            id=\"pot-odds\"\n            role=\"status\"\n            aria-live=\"polite\"\n            aria-label={`Pot odds: ${potOdds}% ${parseFloat(potOdds) < 30 ? 'This is a good betting opportunity' : ''}`}\n          >\n            Pot Odds: {potOdds}%\n            {parseFloat(potOdds) < 30 && (\n              <span className=\"pot-odds-good\" aria-label=\"Good betting odds\">\n                {' '}\n                (Good)\n              </span>\n            )}\n          </div>\n        )}\n      </div>\n    );\n  },\n  (prevProps, nextProps) => {\n    // Custom comparison for performance optimization\n    return (\n      JSON.stringify(prevProps.validActions) === JSON.stringify(nextProps.validActions) &&\n      prevProps._currentBet === nextProps._currentBet &&\n      prevProps.playerChips === nextProps.playerChips &&\n      prevProps.playerBet === nextProps.playerBet &&\n      prevProps._pot === nextProps._pot &&\n      prevProps.minBet === nextProps.minBet &&\n      prevProps.minRaise === nextProps.minRaise &&\n      prevProps.onAction === nextProps.onAction\n    );\n  }\n);\n\nBettingControls.displayName = 'BettingControls';\n\nBettingControls.propTypes = {\n  validActions: PropTypes.arrayOf(PropTypes.string).isRequired,\n  _currentBet: PropTypes.number,\n  playerChips: PropTypes.number.isRequired,\n  playerBet: PropTypes.number,\n  _pot: PropTypes.number,\n  onAction: PropTypes.func.isRequired,\n  minBet: PropTypes.number,\n  minRaise: PropTypes.number,\n};\n\nexport default BettingControls;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport './Card.css';\n\nconst Card = React.memo(\n  ({ card, size = 'normal', faceDown = false }) => {\n    if (!card && !faceDown) {\n      return <div className=\"card-placeholder\" aria-label=\"Empty card slot\" role=\"img\" />;\n    }\n\n    const getSuitSymbol = (suit) => {\n      const symbols = {\n        s: '',\n        h: '',\n        d: '',\n        c: '',\n      };\n      return symbols[suit] || '';\n    };\n\n    const getSuitClass = (suit) => {\n      const classes = {\n        s: 'spades',\n        h: 'hearts',\n        d: 'diamonds',\n        c: 'clubs',\n      };\n      return classes[suit] || '';\n    };\n\n    if (faceDown) {\n      return (\n        <div\n          className={`playing-card back ${size}`}\n          role=\"img\"\n          aria-label=\"Face-down playing card\"\n        />\n      );\n    }\n\n    const suitClass = getSuitClass(card.suit);\n    const suitSymbol = getSuitSymbol(card.suit);\n\n    const getSuitName = (suit) => {\n      const names = {\n        s: 'spades',\n        h: 'hearts',\n        d: 'diamonds',\n        c: 'clubs',\n      };\n      return names[suit] || '';\n    };\n\n    const getCardDescription = () => {\n      const suitName = getSuitName(card.suit);\n      return `${card.rank} of ${suitName}`;\n    };\n\n    return (\n      <div\n        className={`playing-card ${suitClass} ${size}`}\n        role=\"img\"\n        aria-label={getCardDescription()}\n      >\n        <div className=\"card-corner top-left\">\n          <span>{card.rank}</span>\n          <span className=\"card-corner-suit\">{suitSymbol}</span>\n        </div>\n\n        <div className=\"card-center\">\n          <div className=\"card-rank\">{card.rank}</div>\n          <div className=\"card-suit\">{suitSymbol}</div>\n        </div>\n\n        <div className=\"card-corner bottom-right\">\n          <span>{card.rank}</span>\n          <span className=\"card-corner-suit\">{suitSymbol}</span>\n        </div>\n      </div>\n    );\n  },\n  (prevProps, nextProps) =>\n    // Custom comparison function for better performance\n    prevProps.size === nextProps.size &&\n    prevProps.faceDown === nextProps.faceDown &&\n    prevProps.card?.rank === nextProps.card?.rank &&\n    prevProps.card?.suit === nextProps.card?.suit\n);\n\nCard.displayName = 'Card';\n\nCard.propTypes = {\n  card: PropTypes.shape({\n    rank: PropTypes.string.isRequired,\n    suit: PropTypes.string.isRequired,\n  }),\n  size: PropTypes.oneOf(['small', 'normal', 'large']),\n  faceDown: PropTypes.bool,\n};\n\nexport default Card;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport Card from './Card';\nimport './PlayerSeat.css';\n\nconst PlayerSeat = React.memo(\n  ({ player, isActive, isDealer, position, showCards }) => {\n    if (!player) {\n      return null;\n    }\n\n    const getPositionLabel = () => {\n      if (isDealer) return 'BTN';\n\n      const labels = {\n        'small-blind': 'SB',\n        'big-blind': 'BB',\n        'under-the-gun': 'UTG',\n        'middle-position': 'MP',\n        'cut-off': 'CO',\n      };\n\n      return labels[position] || '';\n    };\n\n    const formatChips = (amount) => {\n      if (amount >= 1000000) {\n        return `${(amount / 1000000).toFixed(1)}M`;\n      } else if (amount >= 1000) {\n        return `${(amount / 1000).toFixed(1)}K`;\n      }\n      return amount.toString();\n    };\n\n    const positionLabel = getPositionLabel();\n    const seatClasses = [\n      'player-seat',\n      `position-${player.position}`,\n      isActive ? 'active' : '',\n      player.status === 'folded' ? 'folded' : '',\n    ]\n      .filter(Boolean)\n      .join(' ');\n\n    return (\n      <div className={seatClasses}>\n        {positionLabel && <div className=\"position-label\">{positionLabel}</div>}\n\n        {player.status === 'all-in' && <div className=\"player-status-icon\">AI</div>}\n\n        <div className=\"player-info\">\n          <span className=\"player-name\">{player.name}</span>\n          <span className=\"player-chips\">${formatChips(player.chips)}</span>\n        </div>\n\n        <div className=\"player-cards\">\n          {player.holeCards && player.holeCards.length > 0 && player.status !== 'folded' ? (\n            <>\n              {showCards && player.holeCards ? (\n                player.holeCards.map((card, _index) => (\n                  <Card key={_index} card={card} size=\"small\" />\n                ))\n              ) : (\n                <>\n                  <Card faceDown size=\"small\" />\n                  <Card faceDown size=\"small\" />\n                </>\n              )}\n            </>\n          ) : null}\n        </div>\n\n        {player.currentBet > 0 && <div className=\"player-bet\">${player.currentBet}</div>}\n\n        {player.lastAction && (\n          <div className={`player-_action ${player.lastAction}`}>{player.lastAction}</div>\n        )}\n\n        {isActive && (\n          <div className=\"player-timer\">\n            <div className=\"player-timer-bar\" style={{ width: '100%' }} />\n          </div>\n        )}\n      </div>\n    );\n  },\n  (prevProps, nextProps) => {\n    // Custom comparison to prevent unnecessary re-renders\n    const prevPlayer = prevProps.player;\n    const nextPlayer = nextProps.player;\n\n    if (!prevPlayer && !nextPlayer) return true;\n    if (!prevPlayer || !nextPlayer) return false;\n\n    return (\n      prevProps.isActive === nextProps.isActive &&\n      prevProps.isDealer === nextProps.isDealer &&\n      prevProps.position === nextProps.position &&\n      prevProps.showCards === nextProps.showCards &&\n      prevPlayer.id === nextPlayer.id &&\n      prevPlayer.name === nextPlayer.name &&\n      prevPlayer.chips === nextPlayer.chips &&\n      prevPlayer.status === nextPlayer.status &&\n      prevPlayer.currentBet === nextPlayer.currentBet &&\n      prevPlayer.lastAction === nextPlayer.lastAction &&\n      prevPlayer.hasCards === nextPlayer.hasCards &&\n      JSON.stringify(prevPlayer.holeCards) === JSON.stringify(nextPlayer.holeCards)\n    );\n  }\n);\n\nPlayerSeat.displayName = 'PlayerSeat';\n\nPlayerSeat.propTypes = {\n  player: PropTypes.shape({\n    id: PropTypes.string.isRequired,\n    name: PropTypes.string.isRequired,\n    chips: PropTypes.number.isRequired,\n    position: PropTypes.number,\n    status: PropTypes.string,\n    currentBet: PropTypes.number,\n    lastAction: PropTypes.string,\n    holeCards: PropTypes.arrayOf(\n      PropTypes.shape({\n        rank: PropTypes.string,\n        suit: PropTypes.string,\n      })\n    ),\n    hasCards: PropTypes.bool,\n  }),\n  isActive: PropTypes.bool,\n  isDealer: PropTypes.bool,\n  position: PropTypes.string,\n  showCards: PropTypes.bool,\n};\n\nexport default PlayerSeat;\n","import PropTypes from 'prop-types';\nimport { useState, useEffect } from 'react';\n\nimport usePokerGame from '../../hooks/usePokerGame';\n\nimport BettingControls from './BettingControls';\nimport Card from './Card';\nimport PlayerSeat from './PlayerSeat';\nimport './PokerTable.css';\n\n/**\n * Poker Table Component\n * Main poker table component that handles game display and interaction\n */\nconst PokerTable = ({ onGameStateChange, onPlayerAction } = {}) => {\n  const humanPlayerId = 'human-player';\n\n  const {\n    gameState,\n    showControls,\n    validActions,\n    showdown,\n    error,\n    isProcessingAI,\n    executeAction,\n    getCurrentPlayerInfo,\n    gameEngine,\n  } = usePokerGame(humanPlayerId, {\n    onStateChange: onGameStateChange,\n    onPlayerAction,\n  });\n\n  // Countdown for next hand - must be declared before any early returns\n  const [countdown, setCountdown] = useState(3);\n\n  // Determine if waiting phase for countdown effect\n  const isWaitingPhase = gameState?.phase === 'waiting';\n\n  useEffect(() => {\n    if (isWaitingPhase) {\n      setCountdown(3);\n      const timer = setInterval(() => {\n        setCountdown((prev) => {\n          if (prev <= 1) {\n            clearInterval(timer);\n            return 0;\n          }\n          return prev - 1;\n        });\n      }, 1000);\n      return () => clearInterval(timer);\n    }\n  }, [isWaitingPhase]);\n\n  // Handle starting a new hand manually\n  const handleNewHand = () => {\n    try {\n      if (gameEngine) {\n        gameEngine.startNewHand();\n      }\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Failed to start new hand:', err);\n    }\n  };\n\n  if (!gameState) {\n    return (\n      <div className=\"poker-table-container\">\n        <div className=\"loading\">Loading game...</div>\n      </div>\n    );\n  }\n\n  // Debug logging\n  if (process.env.NODE_ENV === 'development') {\n    // eslint-disable-next-line no-console\n    console.log('Game State:', {\n      players: gameState.players?.length,\n      phase: gameState.phase,\n      pot: gameState._pot,\n      currentPlayer: gameState.currentPlayerIndex,\n      communityCards: gameState.communityCards?.length,\n    });\n  }\n\n  const { humanPlayer, isHumanTurn, currentPlayer } = getCurrentPlayerInfo;\n\n  // Determine game status for display\n  const isShowdownPhase = gameState.phase === 'showdown';\n  const canShowControls = showControls && humanPlayer && isHumanTurn && !isWaitingPhase;\n\n  return (\n    <div className=\"poker-table-container\">\n      {error && (\n        <div className=\"error-banner\" role=\"alert\" aria-live=\"assertive\" aria-atomic=\"true\">\n          {error}\n        </div>\n      )}\n\n      <main className=\"poker-table\" role=\"main\" aria-label=\"Poker game table\">\n        <div className=\"table-rail\" />\n\n        <section className=\"player-seats\" aria-label=\"Player seating positions\">\n          {gameState.players &&\n            gameState.players\n              .filter((player) => player != null)\n              .map((player) => (\n                <PlayerSeat\n                  key={player.id}\n                  player={player}\n                  isActive={gameState.currentPlayerIndex === player.position}\n                  isDealer={gameState.dealerPosition === player.position}\n                  showCards={player.id === humanPlayerId || showdown}\n                />\n              ))}\n        </section>\n\n        <section\n          className=\"community-cards\"\n          aria-label=\"Community cards\"\n          aria-describedby=\"game-phase-indicator\"\n        >\n          {gameState.communityCards &&\n            gameState.communityCards.map((card, index) => (\n              <Card key={`card-${card.rank}-${card.suit}-${index}`} card={card} />\n            ))}\n          {(() => {\n            const communityCardCount = gameState.communityCards\n              ? gameState.communityCards.length\n              : 0;\n            const placeholderCount = Math.max(0, 5 - communityCardCount);\n            return [...Array(placeholderCount)].map((_, index) => (\n              <Card key={`placeholder-${index}`} />\n            ));\n          })()}\n        </section>\n\n        <div\n          className=\"pot-display\"\n          role=\"status\"\n          aria-live=\"polite\"\n          aria-label={`Current pot amount: $${gameState._pot || 0}`}\n        >\n          Pot: ${gameState._pot || 0}\n        </div>\n\n        <aside className=\"game-info\" aria-label=\"Game information\">\n          <h3>Game Info</h3>\n          <div className=\"game-info-item\">\n            <span>Hand #</span>\n            <span aria-label={`Hand number ${gameState.handNumber}`}>{gameState.handNumber}</span>\n          </div>\n          <div className=\"game-info-item\">\n            <span>Blinds</span>\n            <span\n              aria-label={`Small blind $${gameState.blinds.small}, big blind $${gameState.blinds.big}`}\n            >\n              ${gameState.blinds.small}/${gameState.blinds.big}\n            </span>\n          </div>\n          <div className=\"game-info-item\">\n            <span>Players</span>\n            <span\n              aria-label={`${gameState.getPlayersInHand ? gameState.getPlayersInHand().length : gameState.players.length} players in game`}\n            >\n              {gameState.getPlayersInHand\n                ? gameState.getPlayersInHand().length\n                : gameState.players.length}\n            </span>\n          </div>\n        </aside>\n\n        <div\n          id=\"game-phase-indicator\"\n          className=\"phase-indicator\"\n          role=\"status\"\n          aria-live=\"polite\"\n          aria-label={`Current game phase: ${gameState.phase}`}\n        >\n          {gameState.phase}\n        </div>\n\n        {showdown && gameState.winners && gameState.winners.length > 0 && (\n          <section\n            className=\"winners-display\"\n            role=\"status\"\n            aria-live=\"assertive\"\n            aria-label=\"Hand results\"\n          >\n            <h2>Winner{gameState.winners.length > 1 ? 's' : ''}!</h2>\n            {gameState.winners.map((winner, _index) => (\n              <div\n                key={_index}\n                className=\"winner-item\"\n                aria-label={`${winner.player.name} wins $${winner.amount} with ${winner.handDescription}`}\n              >\n                <div>\n                  {winner.player.name} wins ${winner.amount}\n                </div>\n                <div className=\"winner-hand\">{winner.handDescription}</div>\n              </div>\n            ))}\n          </section>\n        )}\n\n        <div\n          className=\"dealer-button\"\n          style={{\n            transform: `translate(-50%, -50%)\n                     rotate(${gameState.dealerPosition * (360 / gameState.players.length)}deg)\n                     translateX(200px)`,\n          }}\n          role=\"img\"\n          aria-label={`Dealer button at position ${gameState.dealerPosition + 1}`}\n        >\n          D\n        </div>\n      </main>\n\n      {/* Game Status Panel - Always visible */}\n      <div className=\"game-status-panel\" role=\"status\" aria-live=\"polite\">\n        {isWaitingPhase && (\n          <div className=\"status-waiting\">\n            <p>Hand complete. Next hand in {countdown}...</p>\n            <button className=\"new-hand-button\" onClick={handleNewHand}>\n              Start Now\n            </button>\n          </div>\n        )}\n\n        {isProcessingAI && !isWaitingPhase && !isShowdownPhase && (\n          <div className=\"status-ai-thinking\">\n            <div className=\"thinking-indicator\">\n              <span className=\"dot\"></span>\n              <span className=\"dot\"></span>\n              <span className=\"dot\"></span>\n            </div>\n            <p>{currentPlayer?.name || 'AI'} is thinking...</p>\n          </div>\n        )}\n\n        {!isWaitingPhase &&\n          !isProcessingAI &&\n          !isHumanTurn &&\n          !isShowdownPhase &&\n          currentPlayer && (\n            <div className=\"status-other-turn\">\n              <p>Waiting for {currentPlayer.name}...</p>\n            </div>\n          )}\n\n        {isHumanTurn && !isWaitingPhase && !isShowdownPhase && (\n          <div className=\"status-your-turn\">\n            <p>Your turn to act!</p>\n          </div>\n        )}\n      </div>\n\n      {/* Betting Controls - Show when it's human's turn */}\n      {canShowControls && (\n        <BettingControls\n          validActions={validActions}\n          _currentBet={gameState.currentBet}\n          playerChips={humanPlayer.chips}\n          playerBet={humanPlayer.currentBet}\n          _pot={gameState._pot || 0}\n          minBet={gameState.blinds.big}\n          minRaise={gameState.currentBet + gameState.minimumRaise}\n          onAction={executeAction}\n        />\n      )}\n    </div>\n  );\n};\n\nPokerTable.propTypes = {\n  onGameStateChange: PropTypes.func,\n  onPlayerAction: PropTypes.func,\n};\n\nexport default PokerTable;\n","import { PLAYER_ACTIONS } from '../../constants/game-constants';\n\nclass BettingLogic {\n  static validateAction(gameState, player, _action, amount = 0) {\n    if (!player.canAct()) {\n      return { valid: false, reason: 'Player cannot act' };\n    }\n\n    const callAmount = gameState.currentBet - player.currentBet;\n\n    switch (_action) {\n      case PLAYER_ACTIONS.FOLD:\n        return { valid: true };\n\n      case PLAYER_ACTIONS.CHECK:\n        if (callAmount > 0) {\n          return {\n            valid: false,\n            reason: 'Cannot check when there is a bet to call',\n          };\n        }\n        return { valid: true };\n\n      case PLAYER_ACTIONS.CALL:\n        if (callAmount === 0) {\n          return { valid: false, reason: 'Nothing to call' };\n        }\n        // Allow calling even if player doesn't have enough chips (all-in for less)\n        return { valid: true, amount: Math.min(callAmount, player.chips) };\n\n      case PLAYER_ACTIONS.BET:\n        if (gameState.currentBet > 0) {\n          return {\n            valid: false,\n            reason: 'Cannot bet when there is already a bet',\n          };\n        }\n        if (amount < gameState.blinds.big) {\n          return { valid: false, reason: 'Bet must be at least the big blind' };\n        }\n        if (amount > player.chips) {\n          return { valid: false, reason: 'Not enough chips' };\n        }\n        return { valid: true, amount };\n\n      case PLAYER_ACTIONS.RAISE: {\n        if (gameState.currentBet === 0) {\n          return { valid: false, reason: 'Cannot raise when there is no bet' };\n        }\n        const minRaise = gameState.currentBet + gameState.minimumRaise;\n        if (amount < minRaise && amount < player.chips) {\n          return { valid: false, reason: `Raise must be at least ${minRaise}` };\n        }\n        if (amount > player.chips) {\n          return { valid: false, reason: 'Not enough chips' };\n        }\n        return { valid: true, amount: Math.min(amount, player.chips) };\n      }\n\n      case PLAYER_ACTIONS.ALL_IN:\n        return { valid: true, amount: player.chips };\n\n      default:\n        return { valid: false, reason: 'Invalid _action' };\n    }\n  }\n\n  static getValidActions(gameState, player) {\n    if (!player.canAct()) {\n      return [];\n    }\n\n    const validActions = [];\n    const callAmount = gameState.currentBet - player.currentBet;\n\n    validActions.push(PLAYER_ACTIONS.FOLD);\n\n    if (callAmount === 0) {\n      validActions.push(PLAYER_ACTIONS.CHECK);\n\n      if (player.chips >= gameState.blinds.big) {\n        validActions.push(PLAYER_ACTIONS.BET);\n      }\n    } else {\n      if (player.chips >= callAmount) {\n        validActions.push(PLAYER_ACTIONS.CALL);\n      }\n\n      const minRaise = gameState.currentBet + gameState.minimumRaise;\n      if (player.chips >= minRaise) {\n        validActions.push(PLAYER_ACTIONS.RAISE);\n      }\n    }\n\n    if (\n      player.chips > 0 &&\n      (callAmount > 0 || gameState.currentBet === 0) &&\n      !validActions.includes(PLAYER_ACTIONS.CALL) &&\n      !validActions.includes(PLAYER_ACTIONS.RAISE)\n    ) {\n      validActions.push(PLAYER_ACTIONS.ALL_IN);\n    }\n\n    return validActions;\n  }\n\n  static executeAction(gameState, player, _action, amount = 0) {\n    const validation = this.validateAction(gameState, player, _action, amount);\n    if (!validation.valid) {\n      throw new Error(validation.reason);\n    }\n\n    const previousBet = player.currentBet;\n\n    switch (_action) {\n      case PLAYER_ACTIONS.FOLD:\n        player.fold();\n        break;\n\n      case PLAYER_ACTIONS.CHECK:\n        player.check();\n        break;\n\n      case PLAYER_ACTIONS.CALL: {\n        const callAmount = validation.amount || gameState.currentBet - player.currentBet;\n        const actualCall = Math.min(callAmount, player.chips);\n        player.call(actualCall);\n        gameState.potObject.main += actualCall;\n        break;\n      }\n\n      case PLAYER_ACTIONS.BET:\n        player.bet(validation.amount);\n        gameState.currentBet = validation.amount;\n        gameState.minimumRaise = validation.amount;\n        gameState.potObject.main += validation.amount;\n        gameState.lastRaiserIndex = player.position;\n        break;\n\n      case PLAYER_ACTIONS.RAISE: {\n        const raiseAmount = validation.amount;\n        const actualRaise = raiseAmount - player.currentBet;\n        player.raise(raiseAmount); // Pass total target amount, not additional\n\n        gameState.minimumRaise = raiseAmount - gameState.currentBet;\n        gameState.currentBet = raiseAmount;\n        gameState.potObject.main += actualRaise;\n        gameState.lastRaiserIndex = player.position;\n        break;\n      }\n\n      case PLAYER_ACTIONS.ALL_IN: {\n        const allInAmount = player.chips;\n\n        if (gameState.currentBet === 0) {\n          player.bet(allInAmount);\n          if (allInAmount >= gameState.blinds.big) {\n            gameState.currentBet = allInAmount;\n            gameState.minimumRaise = allInAmount;\n            gameState.lastRaiserIndex = player.position;\n          }\n        } else if (player.currentBet + allInAmount > gameState.currentBet) {\n          player.raise(allInAmount);\n          const totalBet = previousBet + allInAmount;\n\n          if (totalBet >= gameState.currentBet + gameState.minimumRaise) {\n            gameState.minimumRaise = totalBet - gameState.currentBet;\n            gameState.currentBet = totalBet;\n            gameState.lastRaiserIndex = player.position;\n          }\n        } else {\n          player.call(allInAmount);\n        }\n\n        // Ensure all-in players have correct status\n        player.status = 'all-in';\n        player.lastAction = 'all-in';\n        gameState.potObject.main += allInAmount;\n        break;\n      }\n    }\n\n    gameState.handHistory.push({\n      playerId: player.id,\n      playerName: player.name,\n      _action,\n      amount: validation.amount || 0,\n      potAfter: gameState.getTotalPot(),\n      phase: gameState.phase,\n      handNumber: gameState.handNumber,\n      timestamp: Date.now(),\n    });\n  }\n\n  static isBettingRoundComplete(gameState) {\n    const activePlayers = gameState.players.filter((p) => p.canAct());\n\n    if (activePlayers.length <= 1) {\n      return true;\n    }\n\n    // Check if all active players have acted\n    const allPlayersActed = activePlayers.every((p) => p.lastAction !== null);\n\n    // Check if all active players have matched the current bet\n    const allBetsMatched = activePlayers.every((p) => p.currentBet === gameState.currentBet);\n\n    // Special case: Big blind option in preflop\n    if (\n      gameState.phase === 'preflop' &&\n      gameState.lastRaiserIndex === null &&\n      gameState.currentBet === gameState.blinds.big\n    ) {\n      const bigBlindPosition = gameState.getBigBlindPosition();\n      const bigBlindPlayer = gameState.getPlayerByPosition(bigBlindPosition);\n\n      // If big blind hasn't acted yet and all others have called/folded, betting round is not complete\n      if (bigBlindPlayer && bigBlindPlayer.canAct() && !bigBlindPlayer.lastAction) {\n        return false;\n      }\n    }\n\n    // If there was a raise, check if all players have acted since the raise\n    if (gameState.lastRaiserIndex !== null) {\n      for (const player of activePlayers) {\n        if (player.position === gameState.lastRaiserIndex) {\n          continue; // The raiser doesn't need to act again\n        }\n\n        if (!this.hasActedSinceLastRaise(gameState, player)) {\n          return false;\n        }\n      }\n    }\n\n    // Betting round is complete if all players have acted and matched the bet\n    return allPlayersActed && allBetsMatched;\n  }\n\n  static hasActedSinceLastRaise(gameState, player) {\n    const history = gameState.handHistory;\n    // Find last raise index (compatible with all browsers)\n    let lastRaiseIndex = -1;\n    for (let i = history.length - 1; i >= 0; i--) {\n      const actionType = history[i]._action || history[i].action;\n      if (actionType === PLAYER_ACTIONS.RAISE || actionType === PLAYER_ACTIONS.BET) {\n        lastRaiseIndex = i;\n        break;\n      }\n    }\n\n    if (lastRaiseIndex === -1) return true;\n\n    return history.slice(lastRaiseIndex + 1).some((h) => h.playerId === player.id);\n  }\n\n  static calculateMinBet(gameState) {\n    return gameState.blinds.big;\n  }\n\n  static calculateMinRaise(gameState) {\n    return gameState.currentBet + gameState.minimumRaise;\n  }\n\n  static calculatePotOdds(gameState, player) {\n    const callAmount = gameState.currentBet - player.currentBet;\n    if (callAmount <= 0) return 100;\n\n    const potAfterCall = gameState.getTotalPot() + callAmount;\n    return (callAmount / potAfterCall) * 100;\n  }\n\n  static getBettingRoundSummary(gameState) {\n    const activePlayers = gameState.getPlayersInHand();\n    const _pot = gameState.getTotalPot();\n    const toCall = gameState.currentBet;\n\n    return {\n      _pot,\n      toCall,\n      playersRemaining: activePlayers.length,\n      currentPlayer: gameState.players[gameState.currentPlayerIndex]?.name || 'None',\n      phase: gameState.phase,\n    };\n  }\n}\n\nexport default BettingLogic;\n","/**\n * PositionStrategy\n * Position-based hand range adjustments for AI decision making\n */\n\n/**\n * Position-based opening range percentages\n * Represents the top X% of hands that should be played from each position\n */\nconst POSITION_RANGES = {\n  // Early position: Play tight (top 12-15% of hands)\n  early: {\n    openRange: 0.12,\n    threeBetRange: 0.05,\n    callRange: 0.08,\n    premiumThreshold: 0.85,\n    strongThreshold: 0.7,\n    playableThreshold: 0.5,\n  },\n  // Middle position: Slightly looser (top 16-20%)\n  middle: {\n    openRange: 0.18,\n    threeBetRange: 0.07,\n    callRange: 0.12,\n    premiumThreshold: 0.8,\n    strongThreshold: 0.65,\n    playableThreshold: 0.45,\n  },\n  // Late position (cutoff): Much looser (top 25-30%)\n  late: {\n    openRange: 0.28,\n    threeBetRange: 0.1,\n    callRange: 0.18,\n    premiumThreshold: 0.75,\n    strongThreshold: 0.55,\n    playableThreshold: 0.35,\n  },\n  // Button: Widest range (top 35-40%)\n  button: {\n    openRange: 0.38,\n    threeBetRange: 0.12,\n    callRange: 0.25,\n    premiumThreshold: 0.7,\n    strongThreshold: 0.5,\n    playableThreshold: 0.3,\n  },\n  // Blinds: Defensive ranges\n  blinds: {\n    openRange: 0.25,\n    threeBetRange: 0.08,\n    callRange: 0.3, // Wider calling range in blinds due to pot odds\n    premiumThreshold: 0.75,\n    strongThreshold: 0.55,\n    playableThreshold: 0.35,\n    defendRange: 0.4, // Defend against steals with top 40%\n  },\n};\n\n/**\n * Steal and defense percentages\n */\nconst STEAL_FREQUENCIES = {\n  // How often to attempt steals from late position vs blinds\n  button: 0.45, // Steal 45% from button when folded to\n  cutoff: 0.35, // Steal 35% from cutoff\n  hijack: 0.25, // Steal 25% from hijack\n\n  // Defense frequencies against steals\n  bigBlindDefend: 0.4, // Defend BB 40% vs steal attempts\n  smallBlindDefend: 0.25, // Defend SB 25% vs steal attempts\n};\n\nclass PositionStrategy {\n  /**\n   * Get position type for a player\n   * @param {number} position - Player's seat position\n   * @param {number} dealerPosition - Current dealer button position\n   * @param {number} totalPlayers - Total players at table\n   * @returns {string} Position type: 'early', 'middle', 'late', 'button', 'blinds'\n   */\n  static getPosition(position, dealerPosition, totalPlayers) {\n    // Calculate relative position from dealer\n    const relativePosition = (position - dealerPosition + totalPlayers) % totalPlayers;\n\n    // For heads-up, just return 'button' or 'blinds'\n    if (totalPlayers === 2) {\n      return relativePosition === 0 ? 'button' : 'blinds';\n    }\n\n    // Map relative position to position type\n    // Position 0 = dealer (button)\n    // Position 1 = small blind\n    // Position 2 = big blind\n    // Position 3+ = early/middle/late depending on total players\n\n    if (relativePosition === 0) return 'button';\n    if (relativePosition === 1 || relativePosition === 2) return 'blinds';\n\n    // For remaining positions, distribute into early/middle/late\n    const nonBlindPositions = totalPlayers - 3; // Exclude BTN, SB, BB\n\n    if (nonBlindPositions <= 3) {\n      // 5-6 players: mostly late position\n      if (relativePosition === 3) return 'late';\n      return 'middle';\n    }\n\n    // 7+ players: proper distribution\n    const thirdOfPositions = Math.ceil(nonBlindPositions / 3);\n    const adjustedPosition = relativePosition - 3; // Position after BB\n\n    if (adjustedPosition < thirdOfPositions) return 'early';\n    if (adjustedPosition < thirdOfPositions * 2) return 'middle';\n    return 'late';\n  }\n\n  /**\n   * Get range parameters for a position\n   * @param {string} positionType - Position type\n   * @returns {Object} Range parameters\n   */\n  static getRangeForPosition(positionType) {\n    return POSITION_RANGES[positionType] || POSITION_RANGES.middle;\n  }\n\n  /**\n   * Adjust hand strength based on position\n   * @param {number} baseStrength - Base hand strength (0-1)\n   * @param {string} positionType - Position type\n   * @param {boolean} isPreflop - Whether this is preflop\n   * @returns {number} Adjusted hand strength\n   */\n  static adjustStrengthForPosition(baseStrength, positionType, isPreflop = true) {\n    if (!isPreflop) {\n      // Position less important postflop, but still relevant\n      const postflopMultiplier =\n        {\n          early: 0.95,\n          middle: 1.0,\n          late: 1.05,\n          button: 1.1,\n          blinds: 0.95,\n        }[positionType] || 1.0;\n\n      return Math.min(baseStrength * postflopMultiplier, 1.0);\n    }\n\n    // Preflop position adjustments\n    // Better positions allow playing weaker hands more profitably\n    const positionMultiplier =\n      {\n        early: 0.85, // Need stronger hands from early position\n        middle: 0.92,\n        late: 1.05,\n        button: 1.15, // Can play weaker hands profitably from button\n        blinds: 0.95, // Positional disadvantage postflop\n      }[positionType] || 1.0;\n\n    return Math.min(baseStrength * positionMultiplier, 1.0);\n  }\n\n  /**\n   * Check if hand is playable from given position\n   * @param {number} handStrength - Hand strength (0-1)\n   * @param {string} positionType - Position type\n   * @param {boolean} isRaised - Whether there's a raise to call\n   * @returns {boolean} Whether hand should be played\n   */\n  static isPlayableFromPosition(handStrength, positionType, isRaised = false) {\n    const range = this.getRangeForPosition(positionType);\n\n    if (isRaised) {\n      // Need stronger hand to call a raise\n      return handStrength >= range.callRange * 3; // Convert to strength threshold\n    }\n\n    return handStrength >= range.playableThreshold;\n  }\n\n  /**\n   * Check if hand should be opened from position\n   * @param {number} handStrength - Hand strength (0-1)\n   * @param {string} positionType - Position type\n   * @param {string} aiType - AI player type\n   * @returns {boolean} Whether to open raise\n   */\n  static shouldOpenRaise(handStrength, positionType, aiType = 'TAG') {\n    const range = this.getRangeForPosition(positionType);\n\n    // Adjust for AI type\n    const typeMultiplier =\n      {\n        TAG: 1.0, // Standard ranges\n        LAG: 1.3, // 30% wider\n        TP: 0.8, // 20% tighter\n        LP: 1.2, // 20% wider but passive\n      }[aiType] || 1.0;\n\n    const adjustedThreshold = range.strongThreshold / typeMultiplier;\n\n    return handStrength >= adjustedThreshold;\n  }\n\n  /**\n   * Get steal frequency for position\n   * @param {string} positionType - Position type\n   * @returns {number} Steal frequency (0-1)\n   */\n  static getStealFrequency(positionType) {\n    return (\n      {\n        button: STEAL_FREQUENCIES.button,\n        late: STEAL_FREQUENCIES.cutoff,\n        middle: STEAL_FREQUENCIES.hijack,\n      }[positionType] || 0\n    );\n  }\n\n  /**\n   * Get blind defense frequency\n   * @param {boolean} isSmallBlind - Whether player is in small blind\n   * @returns {number} Defense frequency (0-1)\n   */\n  static getBlindDefenseFrequency(isSmallBlind) {\n    return isSmallBlind ? STEAL_FREQUENCIES.smallBlindDefend : STEAL_FREQUENCIES.bigBlindDefend;\n  }\n\n  /**\n   * Calculate bet sizing adjustment based on position\n   * @param {number} baseBetSize - Base bet size\n   * @param {string} positionType - Position type\n   * @returns {number} Adjusted bet size\n   */\n  static adjustBetSizeForPosition(baseBetSize, positionType) {\n    const sizeMultiplier =\n      {\n        early: 1.2, // Larger bets from early position (protection)\n        middle: 1.1,\n        late: 1.0,\n        button: 0.9, // Can bet smaller from position\n        blinds: 1.1, // Larger bets out of position\n      }[positionType] || 1.0;\n\n    return Math.floor(baseBetSize * sizeMultiplier);\n  }\n}\n\nexport default PositionStrategy;\n","import { AI_PLAYER_TYPES } from '../../constants/game-constants';\n\nimport PositionStrategy from './strategies/PositionStrategy';\n\nclass AIPlayer {\n  static getAction(player, gameState, validActions, gameEngine) {\n    const { aiType } = player;\n\n    const holeCards = gameEngine.getPlayerCards(player.id);\n    const communityCards = gameEngine.getCommunityCards();\n    const isPreflop = gameState.phase === 'preflop';\n\n    // Get position information\n    const positionType = PositionStrategy.getPosition(\n      player.position,\n      gameState.dealerPosition,\n      gameState.players.length\n    );\n\n    // Evaluate hand strength with position adjustment\n    const baseStrength = this.evaluateHandStrength(holeCards, communityCards, gameState.phase);\n    const handStrength = PositionStrategy.adjustStrengthForPosition(\n      baseStrength,\n      positionType,\n      isPreflop\n    );\n\n    // Create enhanced context for decision making\n    const context = {\n      handStrength,\n      baseStrength,\n      positionType,\n      isPreflop,\n      isInPosition: positionType === 'button' || positionType === 'late',\n      facingRaise: gameState.currentBet > gameState.blinds.big,\n    };\n\n    switch (aiType) {\n      case AI_PLAYER_TYPES.TAG:\n        return this.getTightAggressiveAction(\n          handStrength,\n          validActions,\n          gameState,\n          player,\n          context\n        );\n      case AI_PLAYER_TYPES.LAG:\n        return this.getLooseAggressiveAction(\n          handStrength,\n          validActions,\n          gameState,\n          player,\n          context\n        );\n      case AI_PLAYER_TYPES.TP:\n        return this.getTightPassiveAction(handStrength, validActions, gameState, player, context);\n      case AI_PLAYER_TYPES.LP:\n        return this.getLoosePassiveAction(handStrength, validActions, gameState, player, context);\n      default:\n        return this.getDefaultAction(validActions, gameState, player);\n    }\n  }\n\n  static evaluateHandStrength(holeCards, communityCards, phase) {\n    if (!holeCards || holeCards.length < 2) return 0;\n\n    const [card1, card2] = holeCards;\n    const isPair = card1.rank === card2.rank;\n    const isSuited = card1.suit === card2.suit;\n    const highCard = Math.max(card1.value, card2.value);\n    const lowCard = Math.min(card1.value, card2.value);\n    const gap = highCard - lowCard;\n\n    if (phase === 'preflop') {\n      if (isPair) {\n        if (highCard >= 12) return 0.9;\n        if (highCard >= 9) return 0.7;\n        return 0.5;\n      }\n\n      if (highCard === 14) {\n        if (lowCard >= 11) return 0.8;\n        if (lowCard >= 9) return 0.6;\n      }\n\n      if (highCard === 13 && lowCard >= 11) return 0.6;\n\n      if (isSuited && gap <= 4) return 0.4;\n\n      if (gap <= 2 && highCard >= 10) return 0.3;\n\n      return 0.2;\n    }\n\n    return this.calculatePostFlopStrength(holeCards, communityCards);\n  }\n\n  static calculatePostFlopStrength(holeCards, communityCards) {\n    if (communityCards.length === 0) return 0.3;\n\n    const allCards = [...holeCards, ...communityCards];\n    const hasTopPair = this.hasTopPair(holeCards, communityCards);\n    const hasTwoPair = this.hasTwoPair(allCards);\n    const hasSet = this.hasSet(holeCards, communityCards);\n    const hasFlushDraw = this.hasFlushDraw(allCards);\n    const hasStraightDraw = this.hasStraightDraw(allCards);\n\n    if (hasSet) return 0.9;\n    if (hasTwoPair) return 0.75;\n    if (hasTopPair) return 0.65;\n    if (hasFlushDraw && hasStraightDraw) return 0.55;\n    if (hasFlushDraw || hasStraightDraw) return 0.45;\n\n    return 0.25;\n  }\n\n  static hasTopPair(holeCards, communityCards) {\n    if (communityCards.length === 0) return false;\n\n    const maxCommunityValue = Math.max(...communityCards.map((c) => c.value));\n    return holeCards.some((card) => card.value === maxCommunityValue);\n  }\n\n  static hasTwoPair(cards) {\n    const ranks = {};\n    cards.forEach((card) => {\n      ranks[card.rank] = (ranks[card.rank] || 0) + 1;\n    });\n\n    const pairs = Object.values(ranks).filter((count) => count >= 2);\n    return pairs.length >= 2;\n  }\n\n  static hasSet(holeCards, communityCards) {\n    if (holeCards[0].rank !== holeCards[1].rank) return false;\n\n    return communityCards.some((card) => card.rank === holeCards[0].rank);\n  }\n\n  static hasFlushDraw(cards) {\n    const suits = {};\n    cards.forEach((card) => {\n      suits[card.suit] = (suits[card.suit] || 0) + 1;\n    });\n\n    return Object.values(suits).some((count) => count >= 4);\n  }\n\n  static hasStraightDraw(cards) {\n    const values = [...new Set(cards.map((c) => c.value))].sort((a, b) => a - b);\n\n    for (let i = 0; i <= values.length - 4; i++) {\n      let consecutive = 1;\n      for (let j = i; j < i + 4 && j < values.length - 1; j++) {\n        if (values[j + 1] - values[j] === 1) {\n          consecutive++;\n        }\n      }\n      if (consecutive >= 4) return true;\n    }\n\n    return false;\n  }\n\n  static getTightAggressiveAction(handStrength, validActions, gameState, player, context = {}) {\n    const callAmount = gameState.currentBet - player.currentBet;\n    const potSize = gameState.totalPot || 0;\n    const stackSize = player.chips;\n    const { positionType = 'middle', isInPosition = false } = context;\n\n    // Position-adjusted thresholds\n    const raiseThreshold = isInPosition ? 0.6 : 0.7;\n    const callThreshold = isInPosition ? 0.35 : 0.4;\n    const callPotRatio = isInPosition ? 0.4 : 0.3;\n\n    // Strong hand: Raise aggressively\n    if (handStrength >= raiseThreshold) {\n      if (validActions.includes('raise')) {\n        const baseBet = gameState.currentBet + gameState.minimumRaise + (potSize || 100) * 0.75;\n        const raiseAmount = PositionStrategy.adjustBetSizeForPosition(\n          Math.min(baseBet, stackSize),\n          positionType\n        );\n        return { action: 'raise', amount: Math.floor(raiseAmount) };\n      }\n      if (validActions.includes('bet')) {\n        const baseBet = Math.max((potSize || 100) * 0.75, gameState.blinds?.big || 20);\n        const betAmount = PositionStrategy.adjustBetSizeForPosition(\n          Math.min(baseBet, stackSize),\n          positionType\n        );\n        return { action: 'bet', amount: Math.floor(betAmount) };\n      }\n    }\n\n    // Medium hand: Call if price is right\n    if (handStrength >= callThreshold) {\n      if (validActions.includes('call') && callAmount <= (potSize || 100) * callPotRatio) {\n        return { action: 'call', amount: callAmount };\n      }\n      if (validActions.includes('check')) {\n        return { action: 'check', amount: 0 };\n      }\n    }\n\n    // Weak hand: Check or fold\n    if (validActions.includes('check')) {\n      return { action: 'check', amount: 0 };\n    }\n\n    return { action: 'fold', amount: 0 };\n  }\n\n  static getLooseAggressiveAction(handStrength, validActions, gameState, player, context = {}) {\n    const callAmount = gameState.currentBet - player.currentBet;\n    const potSize = gameState.totalPot || 0;\n    const stackSize = player.chips;\n    const { positionType = 'middle', isInPosition = false, isPreflop = true } = context;\n\n    // LAG plays more hands from position and bluffs more\n    const baseBluffFrequency = 0.3;\n    const bluffFrequency = isInPosition ? baseBluffFrequency * 1.4 : baseBluffFrequency;\n    const stealFrequency = PositionStrategy.getStealFrequency(positionType);\n\n    // Position-adjusted thresholds - LAG is looser from late position\n    const raiseThreshold = isInPosition ? 0.35 : 0.5;\n    const callThreshold = isInPosition ? 0.15 : 0.25;\n\n    // Steal attempt from late position\n    if (isPreflop && isInPosition && gameState.currentBet === gameState.blinds?.big) {\n      if (Math.random() < stealFrequency && validActions.includes('raise')) {\n        const raiseAmount = Math.min(gameState.currentBet * 3, stackSize);\n        return { action: 'raise', amount: Math.floor(raiseAmount) };\n      }\n    }\n\n    if (handStrength >= raiseThreshold || Math.random() < bluffFrequency) {\n      if (validActions.includes('raise')) {\n        const baseBet = gameState.currentBet + gameState.minimumRaise + (potSize || 100) * 0.5;\n        const raiseAmount = PositionStrategy.adjustBetSizeForPosition(\n          Math.min(baseBet, stackSize),\n          positionType\n        );\n        return { action: 'raise', amount: Math.floor(raiseAmount) };\n      }\n      if (validActions.includes('bet')) {\n        const baseBet = Math.max((potSize || 100) * 0.6, gameState.blinds?.big || 20);\n        const betAmount = PositionStrategy.adjustBetSizeForPosition(\n          Math.min(baseBet, stackSize),\n          positionType\n        );\n        return { action: 'bet', amount: Math.floor(betAmount) };\n      }\n    }\n\n    if (handStrength >= callThreshold) {\n      if (validActions.includes('call') && callAmount <= (potSize || 100) * 0.5) {\n        return { action: 'call', amount: callAmount };\n      }\n      if (validActions.includes('check')) {\n        return { action: 'check', amount: 0 };\n      }\n    }\n\n    if (validActions.includes('check')) {\n      return { action: 'check', amount: 0 };\n    }\n\n    return { action: 'fold', amount: 0 };\n  }\n\n  static getTightPassiveAction(handStrength, validActions, gameState, player, context = {}) {\n    const callAmount = gameState.currentBet - player.currentBet;\n    const potSize = gameState.totalPot || 0;\n    const stackSize = player.chips;\n    const { isInPosition = false } = context;\n\n    // TP plays fewer hands and prefers calling to raising\n    // Position adjustments are smaller for passive players\n    const betThreshold = isInPosition ? 0.75 : 0.8;\n    const callThreshold = isInPosition ? 0.45 : 0.5;\n    const callPotRatio = isInPosition ? 0.25 : 0.2;\n\n    if (handStrength >= betThreshold) {\n      if (validActions.includes('bet')) {\n        // TP bets small with strong hands\n        const betAmount = Math.min(\n          Math.max((potSize || 100) * 0.3, gameState.blinds?.big || 20),\n          stackSize\n        );\n        return { action: 'bet', amount: Math.floor(betAmount) };\n      }\n      if (validActions.includes('call')) {\n        return { action: 'call', amount: callAmount };\n      }\n    }\n\n    if (handStrength >= callThreshold) {\n      if (validActions.includes('call') && callAmount <= (potSize || 100) * callPotRatio) {\n        return { action: 'call', amount: callAmount };\n      }\n      if (validActions.includes('check')) {\n        return { action: 'check', amount: 0 };\n      }\n    }\n\n    if (validActions.includes('check')) {\n      return { action: 'check', amount: 0 };\n    }\n\n    return { action: 'fold', amount: 0 };\n  }\n\n  static getLoosePassiveAction(handStrength, validActions, gameState, player, context = {}) {\n    const callAmount = gameState.currentBet - player.currentBet;\n    const potSize = gameState.totalPot || 0;\n    const stackSize = player.chips;\n    const { isInPosition = false } = context;\n\n    // LP plays many hands but rarely raises - the classic \"calling station\"\n    // Position slightly affects their calling range\n    const betThreshold = isInPosition ? 0.65 : 0.7;\n    const callThreshold = isInPosition ? 0.15 : 0.2;\n    const callPotRatio = isInPosition ? 0.5 : 0.4;\n\n    if (handStrength >= betThreshold) {\n      if (validActions.includes('bet')) {\n        // LP bets small even with strong hands\n        const betAmount = Math.min(\n          Math.max((potSize || 100) * 0.25, gameState.blinds?.big || 20),\n          stackSize\n        );\n        return { action: 'bet', amount: Math.floor(betAmount) };\n      }\n    }\n\n    // LP has wide calling range - they like to see flops and showdowns\n    if (handStrength >= callThreshold) {\n      if (validActions.includes('call') && callAmount <= (potSize || 100) * callPotRatio) {\n        return { action: 'call', amount: callAmount };\n      }\n      if (validActions.includes('check')) {\n        return { action: 'check', amount: 0 };\n      }\n    }\n\n    if (validActions.includes('check')) {\n      return { action: 'check', amount: 0 };\n    }\n\n    return { action: 'fold', amount: 0 };\n  }\n\n  static getDefaultAction(validActions, gameState, player) {\n    if (validActions.includes('check')) {\n      return { action: 'check', amount: 0 };\n    }\n\n    const callAmount = gameState.currentBet - player.currentBet;\n    const _potOdds = gameState.totalPot / callAmount;\n\n    if (validActions.includes('call') && _potOdds > 3) {\n      return { action: 'call', amount: callAmount };\n    }\n\n    return { action: 'fold', amount: 0 };\n  }\n}\n\nexport default AIPlayer;\n"],"names":["constructor","this","cards","dealtCards","reset","suit","Object","values","SUITS","rank","RANKS","push","Card","shuffle","getRandomIndex","max","crypto","getRandomValues","array","Uint32Array","Math","floor","random","i","length","j","dealCard","Error","card","shift","dealOne","dealCards","count","deal","cardsRemaining","getRemainingCards","getDealtCards","removeSpecificCards","cardsToRemove","filter","some","removeCard","players","deck","communityCards","_internalPot","main","side","potHistory","currentBet","_currentBet","minimumRaise","minRaise","dealerPosition","smallBlindPosition","bigBlindPosition","currentPlayerIndex","phase","GAME_PHASES","WAITING","handNumber","blinds","small","big","lastRaiserIndex","bettingRoundComplete","handHistory","winners","initialize","PREFLOP","validateState","addPlayer","player","position","removePlayer","playerId","p","id","updatePlayerPositions","forEach","index","getActivePlayers","isActive","chips","status","PLAYER_STATUS","ALL_IN","FOLDED","SITTING_OUT","getPlayersInHand","isInHand","getNextActivePlayerIndex","startIndex","numPlayers","canAct","moveButton","getSmallBlindPosition","getBigBlindPosition","getUTGPosition","resetForNewHand","calculateSidePots","allContributions","totalPotContribution","amount","sort","a","b","totalContributions","reduce","sum","c","eligibleContributions","previousAmount","foldedContribution","currentAmount","potAmount","eligiblePlayers","slice","map","getTotalPot","total","sidePot","addToHistory","_action","timestamp","Date","now","getPlayerByPosition","find","serialize","pot","_pot","totalPot","playersInHand","self","potValue","valueOf","toString","Symbol","toPrimitive","_hint","value","potObject","nextDealer","addToPot","setCurrentBet","arguments","undefined","nextPhase","phases","FLOP","TURN","RIVER","SHOWDOWN","currentIndex","indexOf","setCommunityCards","nextPlayer","getCurrentPlayer","isHandComplete","createSidePots","contributions","contribution","sidePots","isBettingRoundComplete","activePlayers","playersWhoCanAct","bets","every","bet","lastAction","toJSON","evaluateHand","allCombinations","getCombinations","bestHand","bestRank","bestTiebreakers","combination","evaluation","evaluateFiveCardHand","compareTiebreakers","tiebreakers","rankName","description","sortedCards","isFlush","checkFlush","straightHighCard","checkStraight","groups","groupByRank","groupSizes","group","HAND_RANKINGS","ROYAL_FLUSH","STRAIGHT_FLUSH","concat","getCardName","fourOfAKindRank","getRankOfSize","kicker","FOUR_OF_A_KIND","threeOfAKindRank","pairRank","FULL_HOUSE","flushCards","FLUSH","STRAIGHT","kickers","getKickers","THREE_OF_A_KIND","pairs","getRanksOfSize","TWO_PAIR","PAIR","highCards","HIGH_CARD","suits","isStraight","size","entries","parseInt","ranks","usedRanks","sortedRanks","keys","r","includes","min","arr","combinations","backtrack","start","current","pop","compareHands","hand1","hand2","findWinners","playerHands","evaluatedHands","_ref","hand","gameState","GameState","Deck","_isRestarting","_isInitialized","callbacks","onStateChange","onHandComplete","onPlayerAction","onPhaseChange","onShowdown","setCallback","event","callback","prototype","hasOwnProperty","call","notifyStateChange","startNewHand","postBlinds","dealHoleCards","notifyPhaseChange","error","smallBlindPlayer","bigBlindPlayer","sbAmount","placeBet","playerName","name","bbAmount","holeCards","dealCommunityCards","executePlayerAction","console","currentPlayer","BettingLogic","executeAction","checkAndAdvanceGame","success","action","_this$gameState","_this$gameState$playe","_this$gameState2","gameStateExists","playersCount","message","handleSinglePlayerWin","advanceToNextPhase","moveToNextPlayer","nextIndex","resetBettingRound","handleShowdown","winner","winPot","handDescription","completeHand","mainPotWinners","HandEvaluator","mainPotAmount","mainPotShare","eligibleHands","_ref2","sidePotWinners","sidePotShare","_ref3","existingWinner","w","setTimeout","getValidActions","warn","getGameState","setBlinds","getPlayerCards","getAllPlayerCards","getCommunityCards","getPotOdds","calculatePotOdds","isAI","aiType","_position","totalBetThisRound","isFolded","isAllIn","isDealer","stats","handsPlayed","handsWon","biggestPotWon","totalWinnings","vpip","pfr","aggression","setHoleCards","receiveCards","clearHoleCards","betAmount","fold","check","CHECKED","callAmount","actualAmount","CALLED","raise","additionalAmount","raiseAmount","RAISED","checkIfActive","ACTIVE","decideAction","AIPlayer","require","validActions","getAction","getNetPosition","updateStats","hasCards","humanPlayerId","options","initialChips","smallBlind","bigBlind","aiPlayers","type","gameEngine","useState","GameEngine","setGameState","showControls","setShowControls","setValidActions","showdown","setShowdown","isProcessingAI","setIsProcessingAI","setError","isGameActive","setIsGameActive","isProcessingRef","useRef","gameEngineRef","useHandHistory","processSingleAITurn","useCallback","engine","currentGameState","actions","aiAction","result","updatedState","processAITurns","processNext","err","initializeGame","humanPlayer","Player","aiConfig","idx","aiPlayer","useEffect","_callbacksInitialized","newState","stateWithTimestamp","_objectSpread","_updateTimestamp","isSessionActive","captureAction","getCurrentPlayerInfo","useMemo","isHumanTurn","timeoutId","stillCurrentPlayer","clearTimeout","checkEngine","checkPlayer","BettingControls","React","playerChips","playerBet","onAction","minBet","setBetAmount","handleSliderChange","e","target","handleInputChange","setPresetBet","fraction","potOdds","potAfterCall","toFixed","_jsxs","className","role","children","_jsx","htmlFor","onChange","onClick","disabled","parseFloat","prevProps","nextProps","JSON","stringify","displayName","faceDown","suitClass","s","h","d","suitSymbol","getSuitSymbol","getCardDescription","suitName","getSuitName","_prevProps$card","_nextProps$card","_prevProps$card2","_nextProps$card2","PlayerSeat","showCards","positionLabel","getPositionLabel","seatClasses","Boolean","join","_Fragment","_index","style","width","prevPlayer","onGameStateChange","usePokerGame","countdown","setCountdown","isWaitingPhase","timer","setInterval","prev","clearInterval","isShowdownPhase","canShowControls","communityCardCount","placeholderCount","Array","_","transform","handleNewHand","validateAction","valid","reason","PLAYER_ACTIONS","FOLD","CHECK","CALL","BET","RAISE","validation","previousBet","actualCall","actualRaise","allInAmount","totalBet","potAfter","allPlayersActed","allBetsMatched","hasActedSinceLastRaise","history","lastRaiseIndex","actionType","calculateMinBet","calculateMinRaise","getBettingRoundSummary","_gameState$players$ga","toCall","playersRemaining","POSITION_RANGES","early","openRange","threeBetRange","callRange","premiumThreshold","strongThreshold","playableThreshold","middle","late","button","defendRange","STEAL_FREQUENCIES","getPosition","totalPlayers","relativePosition","nonBlindPositions","thirdOfPositions","ceil","adjustedPosition","getRangeForPosition","positionType","adjustStrengthForPosition","baseStrength","postflopMultiplier","positionMultiplier","isPlayableFromPosition","handStrength","isRaised","range","shouldOpenRaise","typeMultiplier","TAG","LAG","TP","LP","getStealFrequency","getBlindDefenseFrequency","isSmallBlind","adjustBetSizeForPosition","baseBetSize","sizeMultiplier","isPreflop","PositionStrategy","evaluateHandStrength","context","isInPosition","facingRaise","AI_PLAYER_TYPES","getTightAggressiveAction","getLooseAggressiveAction","getTightPassiveAction","getLoosePassiveAction","getDefaultAction","card1","card2","isPair","isSuited","highCard","lowCard","gap","calculatePostFlopStrength","allCards","hasTopPair","hasTwoPair","hasSet","hasFlushDraw","hasStraightDraw","maxCommunityValue","Set","consecutive","potSize","stackSize","callThreshold","callPotRatio","baseBet","_gameState$blinds","_gameState$blinds2","bluffFrequency","baseBluffFrequency","stealFrequency","raiseThreshold","_gameState$blinds3","_gameState$blinds4","_gameState$blinds5","_potOdds"],"ignoreList":[],"sourceRoot":""}