{"version":3,"file":"static/js/poker-game.7790c44b.chunk.js","mappings":"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","sources":["game/entities/Deck.js","game/entities/GameState.js","game/utils/HandEvaluator.js","game/engine/GameEngine.js","game/entities/Player.js","hooks/usePokerGame.js","components/game/BettingControls.jsx","components/game/Card.jsx","components/game/PlayerSeat.jsx","components/game/PokerTable.jsx","game/engine/BettingLogic.js","game/engine/strategies/PositionStrategy.js","game/engine/AIPlayer.js"],"sourcesContent":["import { RANKS, SUITS } from '../../constants/game-constants';\n\nimport Card from './Card';\n\nclass Deck {\n  constructor() {\n    this.cards = [];\n    this.dealtCards = [];\n    this.reset();\n  }\n\n  reset() {\n    this.cards = [];\n    this.dealtCards = [];\n\n    for (const suit of Object.values(SUITS)) {\n      for (const rank of Object.values(RANKS)) {\n        this.cards.push(new Card(rank, suit));\n      }\n    }\n\n    this.shuffle();\n  }\n\n  shuffle() {\n    // Use cryptographically secure random for fair card distribution\n    // Falls back to Math.random in environments without crypto support\n    const getRandomIndex = (max) => {\n      if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n        const array = new Uint32Array(1);\n        crypto.getRandomValues(array);\n        return Math.floor((array[0] / (0xffffffff + 1)) * max);\n      }\n      return Math.floor(Math.random() * max);\n    };\n\n    // Fisher-Yates shuffle\n    for (let i = this.cards.length - 1; i > 0; i--) {\n      const j = getRandomIndex(i + 1);\n      [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];\n    }\n  }\n\n  dealCard() {\n    if (this.cards.length === 0) {\n      throw new Error('Not enough cards in deck');\n    }\n\n    const card = this.cards.shift(); // Deal from top (index 0)\n    this.dealtCards.push(card);\n    return card;\n  }\n\n  dealOne() {\n    return this.dealCard();\n  }\n\n  dealCards(count) {\n    if (count < 0) {\n      throw new Error('Cannot deal negative number of cards');\n    }\n\n    if (count > this.cards.length) {\n      throw new Error('Not enough cards in deck');\n    }\n\n    const cards = [];\n    for (let i = 0; i < count; i++) {\n      cards.push(this.dealCard());\n    }\n    return cards;\n  }\n\n  deal(count) {\n    return this.dealCards(count);\n  }\n\n  cardsRemaining() {\n    return this.cards.length;\n  }\n\n  getRemainingCards() {\n    return this.cardsRemaining();\n  }\n\n  getDealtCards() {\n    return [...this.dealtCards];\n  }\n\n  removeSpecificCards(cardsToRemove) {\n    this.cards = this.cards.filter(\n      (card) =>\n        !cardsToRemove.some(\n          (removeCard) => card.rank === removeCard.rank && card.suit === removeCard.suit\n        )\n    );\n  }\n}\n\nexport default Deck;\n","import { GAME_PHASES, PLAYER_STATUS } from '../../constants/game-constants';\n\nclass GameState {\n  constructor() {\n    this.players = [];\n    this.deck = null;\n    this.communityCards = [];\n    this._internalPot = {\n      main: 0,\n      side: [],\n    };\n    this.potHistory = []; // Track pot changes\n    this.currentBet = 0;\n    this._currentBet = 0; // Alias for compatibility\n    this.minimumRaise = 0;\n    this.minRaise = 0; // Alias for compatibility\n    this.dealerPosition = 0;\n    this.smallBlindPosition = 1; // Add missing property\n    this.bigBlindPosition = 2; // Add missing property\n    this.currentPlayerIndex = 0;\n    this.phase = GAME_PHASES.WAITING;\n    this.handNumber = 0;\n    this.blinds = {\n      small: 10,\n      big: 20,\n    };\n    this.lastRaiserIndex = null;\n    this.bettingRoundComplete = false;\n    this.handHistory = [];\n    this.winners = [];\n  }\n\n  initialize(players) {\n    this.players = players;\n    this.dealerPosition = 0;\n\n    // Handle heads-up (2 players) vs multi-player scenarios\n    if (players.length === 2) {\n      this.smallBlindPosition = 0; // Dealer is SB in heads-up\n      this.bigBlindPosition = 1;\n      this.currentPlayerIndex = 0; // SB acts first preflop in heads-up\n    } else {\n      this.smallBlindPosition = 1;\n      this.bigBlindPosition = 2;\n      this.currentPlayerIndex = 3; // First to act after big blind\n    }\n\n    this._internalPot = {\n      main: 0,\n      side: [],\n    };\n    this.potHistory = [];\n    this.currentBet = 0;\n    this._currentBet = 0;\n    this.minimumRaise = 0;\n    this.minRaise = 0;\n    this.phase = GAME_PHASES.PREFLOP;\n  }\n\n  validateState() {\n    // Basic validation checks\n    if (!this.players || this.players.length < 2) {\n      return false;\n    }\n\n    if (this.dealerPosition < 0 || this.dealerPosition >= this.players.length) {\n      return false;\n    }\n\n    if (this.currentPlayerIndex < 0 || this.currentPlayerIndex >= this.players.length) {\n      return false;\n    }\n\n    return true;\n  }\n\n  addPlayer(player) {\n    this.players.push(player);\n    player.position = this.players.length - 1;\n  }\n\n  removePlayer(playerId) {\n    this.players = this.players.filter((p) => p.id !== playerId);\n    this.updatePlayerPositions();\n  }\n\n  updatePlayerPositions() {\n    this.players.forEach((player, index) => {\n      player.position = index;\n    });\n  }\n\n  getActivePlayers() {\n    // Players are \"active\" if they can participate in the hand\n    // This includes players who are WAITING, ACTIVE, CHECKED, CALLED, RAISED, or ALL_IN\n    // but excludes players who are FOLDED or SITTING_OUT\n    // Note: ALL_IN players have chips=0 but are still in the hand\n    return this.players.filter(\n      (p) =>\n        p.isActive &&\n        (p.chips > 0 || p.status === PLAYER_STATUS.ALL_IN) &&\n        p.status !== PLAYER_STATUS.FOLDED &&\n        p.status !== PLAYER_STATUS.SITTING_OUT\n    );\n  }\n\n  getPlayersInHand() {\n    return this.players.filter((p) => p.isInHand());\n  }\n\n  getNextActivePlayerIndex(startIndex) {\n    if (!this.players || this.players.length === 0) {\n      return -1;\n    }\n\n    const numPlayers = this.players.length;\n    let index = (startIndex + 1) % numPlayers;\n\n    // Search through all players starting from the next position\n    for (let i = 0; i < numPlayers; i++) {\n      const player = this.players[index];\n\n      // Check if this player can act\n      if (player && player.canAct()) {\n        return index;\n      }\n\n      // Move to next player (with wrap-around)\n      index = (index + 1) % numPlayers;\n    }\n\n    // No valid players found after checking all positions\n    return -1;\n  }\n\n  moveButton() {\n    this.dealerPosition = (this.dealerPosition + 1) % this.players.length;\n\n    while (this.players[this.dealerPosition].chips === 0) {\n      this.dealerPosition = (this.dealerPosition + 1) % this.players.length;\n    }\n  }\n\n  getSmallBlindPosition() {\n    if (this.players.length === 2) {\n      return this.dealerPosition;\n    }\n\n    let position = (this.dealerPosition + 1) % this.players.length;\n    while (this.players[position].chips === 0) {\n      position = (position + 1) % this.players.length;\n    }\n    return position;\n  }\n\n  getBigBlindPosition() {\n    const sbPosition = this.getSmallBlindPosition();\n    let position = (sbPosition + 1) % this.players.length;\n\n    while (this.players[position].chips === 0) {\n      position = (position + 1) % this.players.length;\n    }\n    return position;\n  }\n\n  getUTGPosition() {\n    const bbPosition = this.getBigBlindPosition();\n    let position = (bbPosition + 1) % this.players.length;\n\n    while (this.players[position].chips === 0) {\n      position = (position + 1) % this.players.length;\n    }\n    return position;\n  }\n\n  resetForNewHand() {\n    this.communityCards = [];\n    this._internalPot = {\n      main: 0,\n      side: [],\n    };\n    this.potHistory = [];\n    this.currentBet = 0;\n    this._currentBet = 0;\n    this.minimumRaise = this.blinds.big;\n    this.minRaise = this.blinds.big;\n    this.phase = GAME_PHASES.PREFLOP;\n    this.lastRaiserIndex = null;\n    this.bettingRoundComplete = false;\n    this.winners = [];\n    this.handNumber++;\n\n    this.players.forEach((player) => {\n      if (player.chips > 0) {\n        player.resetForNewHand();\n      } else {\n        player.status = PLAYER_STATUS.SITTING_OUT;\n      }\n    });\n  }\n\n  calculateSidePots() {\n    const activePlayers = this.getPlayersInHand();\n    if (activePlayers.length === 0) return;\n\n    const contributions = [];\n    activePlayers.forEach((player) => {\n      if (player.totalPotContribution > 0) {\n        contributions.push({\n          player,\n          amount: player.totalPotContribution,\n        });\n      }\n    });\n\n    contributions.sort((a, b) => a.amount - b.amount);\n\n    this._internalPot = { main: 0, side: [] };\n    let previousAmount = 0;\n\n    for (let i = 0; i < contributions.length; i++) {\n      const currentAmount = contributions[i].amount;\n      const potAmount = (currentAmount - previousAmount) * (contributions.length - i);\n\n      if (i === 0) {\n        this._internalPot.main = potAmount;\n      } else {\n        const eligiblePlayers = contributions.slice(i).map((c) => c.player);\n        this._internalPot.side.push({\n          amount: potAmount,\n          eligiblePlayers,\n        });\n      }\n\n      previousAmount = currentAmount;\n    }\n  }\n\n  getTotalPot() {\n    let total = this._internalPot.main;\n    this._internalPot.side.forEach((sidePot) => {\n      total += sidePot.amount;\n    });\n    return total;\n  }\n\n  addToHistory(_action) {\n    this.handHistory.push({\n      handNumber: this.handNumber,\n      phase: this.phase,\n      _action,\n      timestamp: Date.now(),\n    });\n  }\n\n  getPlayerByPosition(position) {\n    return this.players.find((p) => p.position === position);\n  }\n\n  serialize() {\n    return {\n      players: this.players.map((p) => p.serialize()),\n      communityCards: this.communityCards.map((c) => ({\n        rank: c.rank,\n        suit: c.suit,\n      })),\n      pot: this._internalPot,\n      _pot: this._internalPot.main, // Include for test compatibility - return main value\n      currentBet: this.currentBet,\n      minimumRaise: this.minimumRaise,\n      dealerPosition: this.dealerPosition,\n      currentPlayerIndex: this.currentPlayerIndex,\n      phase: this.phase,\n      handNumber: this.handNumber,\n      blinds: this.blinds,\n      totalPot: this.getTotalPot(),\n      playersInHand: this.getPlayersInHand().length,\n      winners: this.winners,\n      // Add missing methods that tests expect\n      getTotalPot: () => this.getTotalPot(),\n      getPlayersInHand: () => this.getPlayersInHand(),\n      getActivePlayers: () => this.getActivePlayers(),\n      getSmallBlindPosition: () => this.getSmallBlindPosition(),\n      getBigBlindPosition: () => this.getBigBlindPosition(),\n      getPlayerByPosition: (position) => this.getPlayerByPosition(position),\n    };\n  }\n\n  get pot() {\n    // Return object that behaves like number but has .main property\n    const self = this;\n    const potValue = this._internalPot.main;\n\n    return {\n      // Make it behave like a number for comparisons\n      valueOf() {\n        return potValue;\n      },\n      toString() {\n        return potValue.toString();\n      },\n\n      // For Jest's .toBe() strict equality\n      [Symbol.toPrimitive](_hint) {\n        return potValue;\n      },\n\n      // Support .main property access\n      get main() {\n        return self._internalPot.main;\n      },\n      set main(value) {\n        self._internalPot.main = value;\n      },\n    };\n  }\n\n  set pot(value) {\n    if (typeof value === 'number') {\n      this._internalPot.main = value;\n    } else {\n      this._internalPot = value;\n    }\n  }\n\n  // Return main pot value as number for test compatibility\n  get _pot() {\n    return this._internalPot.main;\n  }\n\n  set _pot(value) {\n    if (typeof value === 'number') {\n      this._internalPot = { main: value, side: [] };\n    } else {\n      this._internalPot = value;\n    }\n  }\n\n  // Provide access to full pot object when needed by BettingLogic\n  get potObject() {\n    return this._internalPot;\n  }\n\n  nextDealer() {\n    this.dealerPosition = (this.dealerPosition + 1) % this.players.length;\n\n    // Skip players without chips or inactive players (sitting out)\n    while (\n      this.players[this.dealerPosition].chips === 0 ||\n      !this.players[this.dealerPosition].isActive\n    ) {\n      this.dealerPosition = (this.dealerPosition + 1) % this.players.length;\n    }\n\n    // Update blind positions based on new dealer\n    if (this.players.length === 2) {\n      this.smallBlindPosition = this.dealerPosition; // Dealer is SB in heads-up\n      this.bigBlindPosition = (this.dealerPosition + 1) % this.players.length;\n    } else {\n      this.smallBlindPosition = (this.dealerPosition + 1) % this.players.length;\n      this.bigBlindPosition = (this.dealerPosition + 2) % this.players.length;\n    }\n  }\n\n  addToPot(amount) {\n    this._internalPot.main += amount;\n    this.potHistory.push(amount);\n  }\n\n  setCurrentBet(amount, minRaise = 0) {\n    this.currentBet = amount;\n    this._currentBet = amount;\n    this.minimumRaise = minRaise;\n    this.minRaise = minRaise;\n  }\n\n  nextPhase() {\n    const phases = [\n      GAME_PHASES.PREFLOP,\n      GAME_PHASES.FLOP,\n      GAME_PHASES.TURN,\n      GAME_PHASES.RIVER,\n      GAME_PHASES.SHOWDOWN,\n    ];\n    const currentIndex = phases.indexOf(this.phase);\n\n    if (currentIndex < phases.length - 1) {\n      this.phase = phases[currentIndex + 1];\n    }\n\n    // Reset betting for new phase\n    this.currentBet = 0;\n    this._currentBet = 0;\n    this.minimumRaise = 0;\n    this.minRaise = 0;\n  }\n\n  setCommunityCards(cards) {\n    this.communityCards = cards;\n  }\n\n  nextPlayer() {\n    this.currentPlayerIndex = this.getNextActivePlayerIndex(this.currentPlayerIndex);\n  }\n\n  getCurrentPlayer() {\n    return this.players[this.currentPlayerIndex];\n  }\n\n  isHandComplete() {\n    if (this.phase === GAME_PHASES.SHOWDOWN) {\n      return true;\n    }\n\n    const playersInHand = this.getPlayersInHand();\n    return playersInHand.length <= 1;\n  }\n\n  createSidePots() {\n    const playersInHand = this.getPlayersInHand();\n    if (playersInHand.length === 0) return [];\n\n    const contributions = [];\n    playersInHand.forEach((player) => {\n      const contribution = player.currentBet || player._currentBet || 0;\n      if (contribution > 0) {\n        contributions.push({\n          player,\n          amount: contribution,\n        });\n      }\n    });\n\n    contributions.sort((a, b) => a.amount - b.amount);\n\n    const sidePots = [];\n    let previousAmount = 0;\n\n    for (let i = 0; i < contributions.length; i++) {\n      const currentAmount = contributions[i].amount;\n      const potAmount = (currentAmount - previousAmount) * (contributions.length - i);\n\n      if (potAmount > 0) {\n        const eligiblePlayers = contributions.slice(i).map((c) => c.player);\n        sidePots.push({\n          amount: potAmount,\n          eligiblePlayers,\n        });\n      }\n\n      previousAmount = currentAmount;\n    }\n\n    return sidePots;\n  }\n\n  isBettingRoundComplete() {\n    // Import BettingLogic to check if betting round is complete\n    // For now, implement basic logic here to avoid circular imports\n    const activePlayers = this.getActivePlayers().filter((p) => p.canAct());\n    if (activePlayers.length <= 1) {\n      return true;\n    }\n\n    // Check if all players have acted and bets are equal\n    const playersWhoCanAct = activePlayers.filter(\n      (p) => p.status !== PLAYER_STATUS.FOLDED && p.status !== PLAYER_STATUS.ALL_IN\n    );\n\n    if (playersWhoCanAct.length === 0) {\n      return true;\n    }\n\n    // Simple check: if all active players have the same current bet\n    const bets = playersWhoCanAct.map((p) => p._currentBet);\n    const allBetsEqual = bets.every((bet) => bet === bets[0]);\n\n    return allBetsEqual && playersWhoCanAct.every((p) => p.lastAction !== null);\n  }\n\n  toJSON() {\n    return this.serialize();\n  }\n}\n\nexport default GameState;\n","import { HAND_RANKINGS } from '../../constants/game-constants';\n\n/**\n * Static utility class for evaluating poker hands and determining winners.\n * Implements Texas Hold'em hand ranking rules and comparison logic.\n *\n * @class HandEvaluator\n * @example\n * const cards = [card1, card2, card3, card4, card5, card6, card7];\n * const bestHand = HandEvaluator.evaluateHand(cards);\n * console.log(`Best hand: ${bestHand.description}`);\n */\nclass HandEvaluator {\n  /**\n   * Evaluates the best possible 5-card poker hand from 5-7 cards.\n   *\n   * @static\n   * @param {Card[]} cards - Array of 5-7 cards to evaluate\n   * @returns {Object} Hand evaluation result containing rank, cards, description, and tiebreakers\n   * @throws {Error} If fewer than 5 cards provided\n   * @example\n   * const hand = HandEvaluator.evaluateHand([card1, card2, card3, card4, card5]);\n   * // Returns: { rank: 8, rankName: \"Straight\", cards: [...], description: \"Straight, Ten high\" }\n   */\n  static evaluateHand(cards) {\n    if (cards.length < 5) {\n      throw new Error('Need at least 5 cards to evaluate');\n    }\n\n    const allCombinations = this.getCombinations(cards, 5);\n    let bestHand = null;\n    let bestRank = -1;\n    let bestTiebreakers = [];\n\n    for (const combination of allCombinations) {\n      const evaluation = this.evaluateFiveCardHand(combination);\n\n      if (\n        evaluation.rank > bestRank ||\n        (evaluation.rank === bestRank &&\n          this.compareTiebreakers(evaluation.tiebreakers, bestTiebreakers) > 0)\n      ) {\n        bestRank = evaluation.rank;\n        bestTiebreakers = evaluation.tiebreakers;\n        bestHand = {\n          rank: evaluation.rank,\n          rankName: evaluation.rankName,\n          cards: combination,\n          tiebreakers: evaluation.tiebreakers,\n          description: evaluation.description,\n        };\n      }\n    }\n\n    return bestHand;\n  }\n\n  static evaluateFiveCardHand(cards) {\n    const sortedCards = [...cards].sort((a, b) => b.value - a.value);\n\n    const isFlush = this.checkFlush(cards);\n    const straightHighCard = this.checkStraight(sortedCards);\n    const groups = this.groupByRank(cards);\n    const groupSizes = Object.values(groups)\n      .map((group) => group.length)\n      .sort((a, b) => b - a);\n\n    if (isFlush && straightHighCard) {\n      if (straightHighCard === 14) {\n        return {\n          rank: HAND_RANKINGS.ROYAL_FLUSH,\n          rankName: 'Royal Flush',\n          tiebreakers: [],\n          description: 'Royal Flush',\n        };\n      }\n      return {\n        rank: HAND_RANKINGS.STRAIGHT_FLUSH,\n        rankName: 'Straight Flush',\n        tiebreakers: [straightHighCard],\n        description: `Straight Flush, ${this.getCardName(straightHighCard)} high`,\n      };\n    }\n\n    if (groupSizes[0] === 4) {\n      const fourOfAKindRank = this.getRankOfSize(groups, 4);\n      const kicker = this.getRankOfSize(groups, 1);\n      return {\n        rank: HAND_RANKINGS.FOUR_OF_A_KIND,\n        rankName: 'Four of a Kind',\n        tiebreakers: [fourOfAKindRank, kicker],\n        description: `Four of a Kind, ${this.getCardName(fourOfAKindRank)}s`,\n      };\n    }\n\n    if (groupSizes[0] === 3 && groupSizes[1] === 2) {\n      const threeOfAKindRank = this.getRankOfSize(groups, 3);\n      const pairRank = this.getRankOfSize(groups, 2);\n      return {\n        rank: HAND_RANKINGS.FULL_HOUSE,\n        rankName: 'Full House',\n        tiebreakers: [threeOfAKindRank, pairRank],\n        description: `Full House, ${this.getCardName(\n          threeOfAKindRank\n        )}s full of ${this.getCardName(pairRank)}s`,\n      };\n    }\n\n    if (isFlush) {\n      const flushCards = sortedCards.map((c) => c.value);\n      return {\n        rank: HAND_RANKINGS.FLUSH,\n        rankName: 'Flush',\n        tiebreakers: flushCards,\n        description: `Flush, ${this.getCardName(flushCards[0])} high`,\n      };\n    }\n\n    if (straightHighCard) {\n      return {\n        rank: HAND_RANKINGS.STRAIGHT,\n        rankName: 'Straight',\n        tiebreakers: [straightHighCard],\n        description: `Straight, ${this.getCardName(straightHighCard)} high`,\n      };\n    }\n\n    if (groupSizes[0] === 3) {\n      const threeOfAKindRank = this.getRankOfSize(groups, 3);\n      const kickers = this.getKickers(groups, [threeOfAKindRank], 2);\n      return {\n        rank: HAND_RANKINGS.THREE_OF_A_KIND,\n        rankName: 'Three of a Kind',\n        tiebreakers: [threeOfAKindRank, ...kickers],\n        description: `Three of a Kind, ${this.getCardName(threeOfAKindRank)}s`,\n      };\n    }\n\n    if (groupSizes[0] === 2 && groupSizes[1] === 2) {\n      const pairs = this.getRanksOfSize(groups, 2).sort((a, b) => b - a);\n      const kicker = this.getKickers(groups, pairs, 1)[0];\n      return {\n        rank: HAND_RANKINGS.TWO_PAIR,\n        rankName: 'Two Pair',\n        tiebreakers: [...pairs, kicker],\n        description: `Two Pair, ${this.getCardName(pairs[0])}s and ${this.getCardName(pairs[1])}s`,\n      };\n    }\n\n    if (groupSizes[0] === 2) {\n      const pairRank = this.getRankOfSize(groups, 2);\n      const kickers = this.getKickers(groups, [pairRank], 3);\n      return {\n        rank: HAND_RANKINGS.PAIR,\n        rankName: 'Pair',\n        tiebreakers: [pairRank, ...kickers],\n        description: `Pair of ${this.getCardName(pairRank)}s`,\n      };\n    }\n\n    const highCards = sortedCards.map((c) => c.value).slice(0, 5);\n    return {\n      rank: HAND_RANKINGS.HIGH_CARD,\n      rankName: 'High Card',\n      tiebreakers: highCards,\n      description: `High Card, ${this.getCardName(highCards[0])}`,\n    };\n  }\n\n  static checkFlush(cards) {\n    const suits = {};\n    for (const card of cards) {\n      suits[card.suit] = (suits[card.suit] || 0) + 1;\n    }\n    return Object.values(suits).some((count) => count >= 5);\n  }\n\n  static checkStraight(sortedCards) {\n    const values = sortedCards.map((c) => c.value);\n\n    for (let i = 0; i <= values.length - 5; i++) {\n      let isStraight = true;\n      for (let j = 0; j < 4; j++) {\n        if (values[i + j] - values[i + j + 1] !== 1) {\n          isStraight = false;\n          break;\n        }\n      }\n      if (isStraight) {\n        return values[i];\n      }\n    }\n\n    if (\n      values[0] === 14 &&\n      values[values.length - 4] === 5 &&\n      values[values.length - 3] === 4 &&\n      values[values.length - 2] === 3 &&\n      values[values.length - 1] === 2\n    ) {\n      return 5;\n    }\n\n    return null;\n  }\n\n  static groupByRank(cards) {\n    const groups = {};\n    for (const card of cards) {\n      if (!groups[card.value]) {\n        groups[card.value] = [];\n      }\n      groups[card.value].push(card);\n    }\n    return groups;\n  }\n\n  static getRankOfSize(groups, size) {\n    for (const [rank, cards] of Object.entries(groups)) {\n      if (cards.length === size) {\n        return parseInt(rank);\n      }\n    }\n    return null;\n  }\n\n  static getRanksOfSize(groups, size) {\n    const ranks = [];\n    for (const [rank, cards] of Object.entries(groups)) {\n      if (cards.length === size) {\n        ranks.push(parseInt(rank));\n      }\n    }\n    return ranks;\n  }\n\n  static getKickers(groups, usedRanks, count) {\n    const kickers = [];\n    const sortedRanks = Object.keys(groups)\n      .map((r) => parseInt(r))\n      .filter((r) => !usedRanks.includes(r))\n      .sort((a, b) => b - a);\n\n    for (let i = 0; i < count && i < sortedRanks.length; i++) {\n      kickers.push(sortedRanks[i]);\n    }\n\n    return kickers;\n  }\n\n  static compareTiebreakers(a, b) {\n    for (let i = 0; i < Math.min(a.length, b.length); i++) {\n      if (a[i] > b[i]) return 1;\n      if (a[i] < b[i]) return -1;\n    }\n    return 0;\n  }\n\n  static getCardName(value) {\n    const names = {\n      2: 'Two',\n      3: 'Three',\n      4: 'Four',\n      5: 'Five',\n      6: 'Six',\n      7: 'Seven',\n      8: 'Eight',\n      9: 'Nine',\n      10: 'Ten',\n      11: 'Jack',\n      12: 'Queen',\n      13: 'King',\n      14: 'Ace',\n    };\n    return names[value] || value.toString();\n  }\n\n  static getCombinations(arr, size) {\n    const combinations = [];\n\n    function backtrack(start, current) {\n      if (current.length === size) {\n        combinations.push([...current]);\n        return;\n      }\n\n      for (let i = start; i < arr.length; i++) {\n        current.push(arr[i]);\n        backtrack(i + 1, current);\n        current.pop();\n      }\n    }\n\n    backtrack(0, []);\n    return combinations;\n  }\n\n  /**\n   * Compares two evaluated poker hands to determine which is stronger.\n   *\n   * @static\n   * @param {Object} hand1 - First hand evaluation result\n   * @param {Object} hand2 - Second hand evaluation result\n   * @returns {number} 1 if hand1 wins, -1 if hand2 wins, 0 if tie\n   * @example\n   * const result = HandEvaluator.compareHands(straightHand, flushHand);\n   * // Returns: -1 (flush beats straight)\n   */\n  static compareHands(hand1, hand2) {\n    if (hand1.rank > hand2.rank) return 1;\n    if (hand1.rank < hand2.rank) return -1;\n\n    return this.compareTiebreakers(hand1.tiebreakers, hand2.tiebreakers);\n  }\n\n  /**\n   * Determines the winning player(s) from a collection of player hands.\n   * Handles ties by returning multiple winners when hands are equal.\n   *\n   * @static\n   * @param {Object[]} playerHands - Array of {player, cards} objects\n   * @returns {Object[]} Array of {player, hand} objects for winning player(s)\n   * @example\n   * const winners = HandEvaluator.findWinners([\n   *   {player: player1, cards: [...]},\n   *   {player: player2, cards: [...]}\n   * ]);\n   * console.log(`${winners[0].player.name} wins with ${winners[0].hand.description}`);\n   */\n  static findWinners(playerHands) {\n    const evaluatedHands = playerHands.map(({ player, cards }) => ({\n      player,\n      hand: this.evaluateHand(cards),\n    }));\n\n    evaluatedHands.sort((a, b) => this.compareHands(b.hand, a.hand));\n\n    const winners = [evaluatedHands[0]];\n    for (let i = 1; i < evaluatedHands.length; i++) {\n      if (this.compareHands(evaluatedHands[0].hand, evaluatedHands[i].hand) === 0) {\n        winners.push(evaluatedHands[i]);\n      } else {\n        break;\n      }\n    }\n\n    return winners;\n  }\n}\n\nexport default HandEvaluator;\n","import { GAME_PHASES } from '../../constants/game-constants';\nimport Deck from '../entities/Deck';\nimport GameState from '../entities/GameState';\nimport HandEvaluator from '../utils/HandEvaluator';\n\nimport BettingLogic from './BettingLogic';\n\n/**\n * Core poker game engine that orchestrates Texas Hold'em gameplay.\n * Manages game state, player actions, betting rounds, and hand progression.\n *\n * @class GameEngine\n * @example\n * const gameEngine = new GameEngine();\n * gameEngine.addPlayer(new Player('player1', 'Alice', 1000, 0));\n * gameEngine.addPlayer(new Player('player2', 'Bob', 1000, 1));\n * gameEngine.setBlinds(10, 20);\n * gameEngine.startNewHand();\n */\nclass GameEngine {\n  /**\n   * Creates a new GameEngine instance.\n   * Initializes the game state, deck, and event callbacks.\n   *\n   * @constructor\n   */\n  constructor() {\n    this.gameState = new GameState();\n    this.deck = new Deck();\n    this.gameState.deck = this.deck;\n    this._isRestarting = false;\n    this._isInitialized = false;\n    this.callbacks = {\n      onStateChange: null,\n      onHandComplete: null,\n      onPlayerAction: null,\n      onPhaseChange: null,\n      onShowdown: null,\n    };\n  }\n\n  /**\n   * Sets a callback function for a specific game event.\n   *\n   * @param {string} event - The event name ('onStateChange', 'onHandComplete', 'onPlayerAction', 'onPhaseChange', 'onShowdown')\n   * @param {Function} callback - The callback function to execute when the event occurs\n   * @example\n   * gameEngine.setCallback('onStateChange', (gameState) => {\n   *   console.log('Game state updated:', gameState);\n   * });\n   */\n  setCallback(event, callback) {\n    if (Object.prototype.hasOwnProperty.call(this.callbacks, event)) {\n      this.callbacks[event] = callback;\n    }\n  }\n\n  /**\n   * Adds a player to the game.\n   *\n   * @param {Player} player - The player object to add to the game\n   * @throws {Error} If player is invalid or game is full\n   * @example\n   * const player = new Player('player1', 'Alice', 1000, 0);\n   * gameEngine.addPlayer(player);\n   */\n  addPlayer(player) {\n    this.gameState.addPlayer(player);\n    this.notifyStateChange();\n  }\n\n  /**\n   * Removes a player from the game.\n   *\n   * @param {string} playerId - The unique identifier of the player to remove\n   * @example\n   * gameEngine.removePlayer('player1');\n   */\n  removePlayer(playerId) {\n    this.gameState.removePlayer(playerId);\n    this.notifyStateChange();\n  }\n\n  /**\n   * Starts a new poker hand.\n   * Resets players, moves the dealer button, posts blinds, and deals hole cards.\n   *\n   * @throws {Error} If fewer than 2 players are available or deck has insufficient cards\n   * @example\n   * gameEngine.startNewHand();\n   */\n  startNewHand() {\n    try {\n      if (this._isRestarting) {\n        return;\n      }\n\n      // Reset players for new hand first (sets status to ACTIVE)\n      this.gameState.resetForNewHand();\n\n      if (this.gameState.getActivePlayers().length < 2) {\n        throw new Error('Need at least 2 players to start a hand');\n      }\n\n      this.gameState.moveButton();\n\n      // Ensure deck is properly reset and has cards\n      this.deck.reset();\n      if (this.deck.cardsRemaining() < 20) {\n        throw new Error('Deck has insufficient cards');\n      }\n\n      this.postBlinds();\n      this.dealHoleCards();\n\n      this.gameState.currentPlayerIndex = this.gameState.getUTGPosition();\n\n      this.notifyStateChange();\n      this.notifyPhaseChange();\n    } catch (error) {\n      this._isRestarting = false; // Reset the flag on error\n      throw error; // Re-throw to be caught by ErrorBoundary\n    }\n  }\n\n  postBlinds() {\n    const smallBlindPosition = this.gameState.getSmallBlindPosition();\n    const bigBlindPosition = this.gameState.getBigBlindPosition();\n\n    const smallBlindPlayer = this.gameState.getPlayerByPosition(smallBlindPosition);\n    const bigBlindPlayer = this.gameState.getPlayerByPosition(bigBlindPosition);\n\n    if (smallBlindPlayer && smallBlindPlayer.chips > 0) {\n      const sbAmount = Math.min(this.gameState.blinds.small, smallBlindPlayer.chips);\n      smallBlindPlayer.placeBet(sbAmount);\n      this.gameState._internalPot.main += sbAmount;\n\n      this.gameState.addToHistory({\n        playerId: smallBlindPlayer.id,\n        playerName: smallBlindPlayer.name,\n        _action: 'small-blind',\n        amount: sbAmount,\n      });\n    }\n\n    if (bigBlindPlayer && bigBlindPlayer.chips > 0) {\n      const bbAmount = Math.min(this.gameState.blinds.big, bigBlindPlayer.chips);\n      bigBlindPlayer.placeBet(bbAmount);\n      this.gameState._internalPot.main += bbAmount;\n      this.gameState.currentBet = bbAmount;\n\n      this.gameState.addToHistory({\n        playerId: bigBlindPlayer.id,\n        playerName: bigBlindPlayer.name,\n        _action: 'big-blind',\n        amount: bbAmount,\n      });\n    }\n  }\n\n  dealHoleCards() {\n    const activePlayers = this.gameState.getActivePlayers();\n\n    for (let i = 0; i < 2; i++) {\n      for (const player of activePlayers) {\n        const card = this.deck.dealCard();\n        player.holeCards.push(card);\n      }\n    }\n  }\n\n  dealCommunityCards(count) {\n    const cards = this.deck.dealCards(count);\n    this.gameState.communityCards.push(...cards);\n    this.notifyStateChange();\n  }\n\n  /**\n   * Executes a player action (fold, call, raise, check, all-in).\n   * Validates the action, updates game state, and advances the game.\n   *\n   * @param {string} playerId - The unique identifier of the acting player\n   * @param {string} _action - The action to execute ('fold', 'call', 'raise', 'check', 'all-in')\n   * @param {number} [amount=0] - The amount for betting actions (required for 'raise')\n   * @throws {Error} If player not found, cannot act, or action is invalid\n   * @example\n   * gameEngine.executePlayerAction('player1', 'raise', 100);\n   * gameEngine.executePlayerAction('player2', 'fold');\n   * gameEngine.executePlayerAction('player3', 'call');\n   */\n  executePlayerAction(playerId, _action, amount = 0) {\n    try {\n      // Enhanced validation\n      if (!this.gameState || !this.gameState.players) {\n        throw new Error('Game state not initialized');\n      }\n\n      const player = this.gameState.players.find((p) => p && p.id === playerId);\n      if (!player) {\n        // eslint-disable-next-line no-console\n        console.error(\n          'Available players:',\n          this.gameState.players.map((p) => (p ? p.id : 'null'))\n        );\n        throw new Error(`Player with ID '${playerId}' not found in game`);\n      }\n\n      // Check player can act\n      if (!player.canAct()) {\n        throw new Error(`Player '${player.name}' cannot act (status: ${player.status})`);\n      }\n\n      // Enhanced turn validation\n      const currentPlayer = this.gameState.players[this.gameState.currentPlayerIndex];\n      if (!currentPlayer) {\n        throw new Error(`No current player at index ${this.gameState.currentPlayerIndex}`);\n      }\n\n      if (currentPlayer.id !== playerId) {\n        throw new Error(`Not ${player.name}'s turn (current: ${currentPlayer.name})`);\n      }\n\n      BettingLogic.executeAction(this.gameState, player, _action, amount);\n\n      if (this.callbacks.onPlayerAction) {\n        this.callbacks.onPlayerAction(player, _action, amount);\n      }\n\n      // Immediately check for single player wins after any action\n      this.checkAndAdvanceGame();\n\n      // Return success result\n      return {\n        success: true,\n        action: _action,\n        amount,\n        playerId,\n      };\n    } catch (error) {\n      // Enhanced error logging\n      // eslint-disable-next-line no-console\n      console.error('GameEngine executePlayerAction error:', {\n        playerId,\n        _action,\n        amount,\n        gameStateExists: !!this.gameState,\n        playersCount: this.gameState?.players?.length || 0,\n        currentPlayerIndex: this.gameState?.currentPlayerIndex,\n        error: error.message,\n      });\n\n      // Return error result instead of throwing\n      return {\n        success: false,\n        error: error.message,\n        action: _action,\n        amount,\n        playerId,\n      };\n    }\n  }\n\n  checkAndAdvanceGame() {\n    // Get active players (not folded, not sitting out, includes all-in)\n    const activePlayers = this.gameState.getActivePlayers();\n\n    // Single player win: only one active player remaining\n    if (activePlayers.length === 1) {\n      this.handleSinglePlayerWin();\n      return;\n    }\n\n    // Check if all players have folded except one\n    const playersInHand = this.gameState.getPlayersInHand();\n    if (playersInHand.length === 1) {\n      this.handleSinglePlayerWin();\n      return;\n    }\n\n    if (playersInHand.length === 0) {\n      // Edge case: no players in hand (shouldn't happen)\n      this.gameState.phase = 'waiting';\n      this.notifyStateChange();\n      return;\n    }\n\n    // Count players who can still act (not folded, not all-in)\n    const playersWhoCanAct = this.gameState.players.filter((p) => p.canAct());\n\n    // If no one can act but multiple players in hand, all remaining are all-in\n    // Skip directly to showdown\n    if (playersWhoCanAct.length === 0 && playersInHand.length >= 2) {\n      while (this.gameState.phase !== GAME_PHASES.SHOWDOWN) {\n        this.advanceToNextPhase();\n      }\n      return;\n    }\n\n    // Continue normal betting flow\n    if (BettingLogic.isBettingRoundComplete(this.gameState)) {\n      this.advanceToNextPhase();\n    } else {\n      this.moveToNextPlayer();\n    }\n\n    this.notifyStateChange();\n  }\n\n  moveToNextPlayer() {\n    // Count players who can still act (using canAct() method)\n    const playersWhoCanAct = this.gameState.players.filter((p) => p.canAct());\n\n    // If no one can act, check if we should go to showdown\n    if (playersWhoCanAct.length === 0) {\n      const playersInHand = this.gameState.getPlayersInHand();\n      if (playersInHand.length >= 2) {\n        // Multiple players but no one can act - all are all-in, skip to showdown\n        while (this.gameState.phase !== GAME_PHASES.SHOWDOWN) {\n          this.advanceToNextPhase();\n        }\n      }\n      return;\n    }\n\n    // If only 1 player can act, they might need to check/bet but can't be raised\n    // Continue normal flow but check for betting round completion\n\n    this.gameState.currentPlayerIndex = this.gameState.getNextActivePlayerIndex(\n      this.gameState.currentPlayerIndex\n    );\n\n    // If no active player found, advance to next phase\n    if (this.gameState.currentPlayerIndex === -1) {\n      this.advanceToNextPhase();\n      return;\n    }\n\n    // Safety check: verify the current player can actually act\n    const currentPlayer = this.gameState.players[this.gameState.currentPlayerIndex];\n    if (!currentPlayer || !currentPlayer.canAct()) {\n      // Current player can't act, try to find next one or advance phase\n      const nextIndex = this.gameState.getNextActivePlayerIndex(this.gameState.currentPlayerIndex);\n      if (nextIndex === -1) {\n        this.advanceToNextPhase();\n      } else {\n        this.gameState.currentPlayerIndex = nextIndex;\n      }\n    }\n  }\n\n  advanceToNextPhase() {\n    this.resetBettingRound();\n\n    switch (this.gameState.phase) {\n      case GAME_PHASES.PREFLOP:\n        this.gameState.phase = GAME_PHASES.FLOP;\n        this.dealCommunityCards(3);\n        break;\n\n      case GAME_PHASES.FLOP:\n        this.gameState.phase = GAME_PHASES.TURN;\n        this.dealCommunityCards(1);\n        break;\n\n      case GAME_PHASES.TURN:\n        this.gameState.phase = GAME_PHASES.RIVER;\n        this.dealCommunityCards(1);\n        break;\n\n      case GAME_PHASES.RIVER:\n        this.handleShowdown();\n        return;\n    }\n\n    // Find next player who can act\n    const dealerPosition = this.gameState.dealerPosition;\n    this.gameState.currentPlayerIndex = this.gameState.getNextActivePlayerIndex(dealerPosition);\n\n    // If no one can act (everyone is all-in or folded), advance to next phase\n    // This handles the case where all remaining players are all-in\n    if (this.gameState.currentPlayerIndex === -1) {\n      // Check if we should go to showdown (multiple players in hand but none can act)\n      const playersInHand = this.gameState.getPlayersInHand();\n      if (playersInHand.length >= 2) {\n        // Multiple players but no one can act - skip to showdown\n        this.advanceToNextPhase();\n        return;\n      }\n    }\n\n    this.notifyPhaseChange();\n    this.notifyStateChange();\n  }\n\n  resetBettingRound() {\n    this.gameState.currentBet = 0;\n    this.gameState.minimumRaise = this.gameState.blinds.big;\n    this.gameState.lastRaiserIndex = null;\n\n    this.gameState.players.forEach((player) => {\n      player._currentBet = 0;\n      player.lastAction = null;\n    });\n  }\n\n  handleSinglePlayerWin() {\n    const playersInHand = this.gameState.getPlayersInHand();\n    if (playersInHand.length !== 1) {\n      // Invalid state - multiple players in hand\n      return;\n    }\n\n    const winner = playersInHand[0];\n    this.gameState.calculateSidePots();\n\n    const totalPot = this.gameState.getTotalPot();\n    winner.winPot(totalPot);\n\n    this.gameState.winners = [\n      {\n        player: winner,\n        amount: totalPot,\n        handDescription: 'Won by default (others folded)',\n      },\n    ];\n\n    // eslint-disable-next-line no-console\n    // Winner determined by fold\n    this.completeHand();\n  }\n\n  handleShowdown() {\n    this.gameState.phase = GAME_PHASES.SHOWDOWN;\n    this.gameState.calculateSidePots();\n\n    const playerHands = this.gameState.getPlayersInHand().map((player) => ({\n      player,\n      cards: [...player.holeCards, ...this.gameState.communityCards],\n    }));\n\n    const mainPotWinners = HandEvaluator.findWinners(playerHands);\n    const mainPotAmount = this.gameState._internalPot.main;\n    const mainPotShare = Math.floor(mainPotAmount / mainPotWinners.length);\n\n    this.gameState.winners = [];\n\n    mainPotWinners.forEach(({ player, hand }) => {\n      player.winPot(mainPotShare);\n      this.gameState.winners.push({\n        player,\n        amount: mainPotShare,\n        hand,\n        handDescription: hand.description,\n      });\n    });\n\n    for (const sidePot of this.gameState._internalPot.side) {\n      const eligibleHands = playerHands.filter(({ player }) =>\n        sidePot.eligiblePlayers.includes(player)\n      );\n\n      const sidePotWinners = HandEvaluator.findWinners(eligibleHands);\n      const sidePotShare = Math.floor(sidePot.amount / sidePotWinners.length);\n\n      sidePotWinners.forEach(({ player, hand }) => {\n        player.winPot(sidePotShare);\n\n        const existingWinner = this.gameState.winners.find((w) => w.player === player);\n        if (existingWinner) {\n          existingWinner.amount += sidePotShare;\n        } else {\n          this.gameState.winners.push({\n            player,\n            amount: sidePotShare,\n            hand,\n            handDescription: hand.description,\n          });\n        }\n      });\n    }\n\n    if (this.callbacks.onShowdown) {\n      this.callbacks.onShowdown(this.gameState.winners);\n    }\n\n    this.completeHand();\n  }\n\n  completeHand() {\n    if (this.callbacks.onHandComplete) {\n      this.callbacks.onHandComplete(this.gameState.winners);\n    }\n\n    // Store winners before resetting\n    const winners = this.gameState.winners;\n\n    // Reset phase to waiting after hand completion\n    this.gameState.phase = 'waiting';\n    this.notifyStateChange();\n\n    // Auto-progress to next hand after 3 seconds\n    setTimeout(() => {\n      try {\n        // Check if we still have enough players with chips\n        const playersWithChips = this.gameState.players.filter((p) => p.isActive && p.chips > 0);\n\n        if (playersWithChips.length >= 2 && !this._isRestarting) {\n          this.startNewHand();\n        }\n      } catch (error) {\n        // eslint-disable-next-line no-console\n        console.error('Failed to auto-start new hand:', error);\n        this._isRestarting = false;\n      }\n    }, 3000);\n\n    // Return the winners info\n    return {\n      winners,\n    };\n  }\n\n  /**\n   * Gets the list of valid actions for a specific player.\n   *\n   * @param {string} playerId - The unique identifier of the player\n   * @returns {string[]} Array of valid action names ('fold', 'call', 'raise', 'check', 'all-in')\n   * @example\n   * const actions = gameEngine.getValidActions('player1');\n   * // Returns: ['fold', 'call', 'raise']\n   */\n  getValidActions(playerId) {\n    // Enhanced validation for getting valid actions\n    if (!this.gameState || !this.gameState.players) {\n      // eslint-disable-next-line no-console\n      console.warn('getValidActions: No game state or players');\n      return [];\n    }\n\n    const player = this.gameState.players.find((p) => p && p.id === playerId);\n    if (!player) {\n      // eslint-disable-next-line no-console\n      console.warn(`getValidActions: Player '${playerId}' not found`);\n      return [];\n    }\n\n    const currentPlayer = this.getCurrentPlayer();\n    if (!currentPlayer) {\n      // eslint-disable-next-line no-console\n      console.warn('getValidActions: No current player');\n      return [];\n    }\n\n    if (currentPlayer.id !== playerId) {\n      // This is normal - player is not currently acting\n      return [];\n    }\n\n    // Player can act - get valid actions from betting logic\n    try {\n      return BettingLogic.getValidActions(this.gameState, player);\n    } catch (error) {\n      // eslint-disable-next-line no-console\n      console.error('getValidActions: Error getting valid actions:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Gets the current serialized game state.\n   * Returns a snapshot of the game state suitable for UI rendering.\n   *\n   * @returns {Object} Serialized game state object containing players, pot, cards, phase, etc.\n   * @example\n   * const state = gameEngine.getGameState();\n   * console.log(`Current phase: ${state.phase}, Pot: ${state.pot.main}`);\n   */\n  getGameState() {\n    return this.gameState.serialize();\n  }\n\n  notifyStateChange() {\n    if (this.callbacks.onStateChange) {\n      this.callbacks.onStateChange(this.getGameState());\n    }\n  }\n\n  notifyPhaseChange() {\n    if (this.callbacks.onPhaseChange) {\n      this.callbacks.onPhaseChange(this.gameState.phase);\n    }\n  }\n\n  /**\n   * Sets the blind amounts for the game.\n   *\n   * @param {number} small - The small blind amount\n   * @param {number} big - The big blind amount\n   * @example\n   * gameEngine.setBlinds(10, 20); // Sets small blind to 10, big blind to 20\n   */\n  setBlinds(small, big) {\n    this.gameState.blinds = { small, big };\n    this.gameState.minimumRaise = big;\n  }\n\n  /**\n   * Gets the hole cards for a specific player.\n   *\n   * @param {string} playerId - The unique identifier of the player\n   * @returns {Card[]} Array of the player's hole cards (empty array if player not found)\n   * @example\n   * const cards = gameEngine.getPlayerCards('player1');\n   * // Returns: [Card{rank: 'A', suit: 's'}, Card{rank: 'K', suit: 'h'}]\n   */\n  getPlayerCards(playerId) {\n    const player = this.gameState.players.find((p) => p.id === playerId);\n    return player ? player.holeCards : [];\n  }\n\n  /**\n   * Gets the hole cards for all players in the game.\n   *\n   * @returns {Object[]} Array of objects containing playerId and cards\n   * @example\n   * const allCards = gameEngine.getAllPlayerCards();\n   * // Returns: [{playerId: 'player1', cards: [Card, Card]}, ...]\n   */\n  getAllPlayerCards() {\n    return this.gameState.players.map((player) => ({\n      playerId: player.id,\n      cards: player.holeCards,\n    }));\n  }\n\n  /**\n   * Gets a copy of the community cards currently on the board.\n   *\n   * @returns {Card[]} Array of community cards (0-5 cards depending on game phase)\n   * @example\n   * const board = gameEngine.getCommunityCards();\n   * // Returns: [Card, Card, Card] on the flop\n   */\n  getCommunityCards() {\n    return [...this.gameState.communityCards];\n  }\n\n  /**\n   * Gets the player who is currently acting.\n   *\n   * @returns {Player|undefined} The current player object, or undefined if no current player\n   * @example\n   * const currentPlayer = gameEngine.getCurrentPlayer();\n   * console.log(`${currentPlayer.name} is up to act`);\n   */\n  getCurrentPlayer() {\n    // Enhanced safety checks for current player access\n    if (!this.gameState || !this.gameState.players || this.gameState.players.length === 0) {\n      return undefined;\n    }\n\n    const index = this.gameState.currentPlayerIndex;\n    if (index < 0 || index >= this.gameState.players.length) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `Invalid currentPlayerIndex: ${index}, players length: ${this.gameState.players.length}`\n      );\n      return undefined;\n    }\n\n    const player = this.gameState.players[index];\n    if (!player) {\n      // eslint-disable-next-line no-console\n      console.warn(`No player found at index: ${index}`);\n      return undefined;\n    }\n\n    return player;\n  }\n\n  /**\n   * Calculates pot odds for a specific player's current situation.\n   *\n   * @param {string} playerId - The unique identifier of the player\n   * @returns {number} Pot odds as a percentage (0-100), or 0 if player not found\n   * @example\n   * const odds = gameEngine.getPotOdds('player1');\n   * console.log(`Pot odds: ${odds.toFixed(1)}%`);\n   */\n  getPotOdds(playerId) {\n    const player = this.gameState.players.find((p) => p.id === playerId);\n    if (!player) return 0;\n\n    return BettingLogic.calculatePotOdds(this.gameState, player);\n  }\n}\n\nexport default GameEngine;\n","import { PLAYER_STATUS } from '../../constants/game-constants';\n\nclass Player {\n  constructor(id, name, chips, position = null, isAI = false, aiType = null) {\n    this.id = id;\n    this.name = name;\n    this.chips = chips;\n    this.position = position;\n    this._position = position; // Alias for compatibility\n\n    // Handle AI type parameter - if aiType is passed as 3rd parameter (old style)\n    if (typeof isAI === 'string') {\n      this.aiType = isAI;\n      this.isAI = true;\n    } else {\n      this.isAI = isAI;\n      this.aiType = aiType || undefined;\n    }\n\n    this.holeCards = [];\n    this.cards = this.holeCards; // Alias for compatibility\n    this.status = PLAYER_STATUS.WAITING;\n    this._currentBet = 0;\n    this.totalBetThisRound = 0; // Alias for currentBet\n    this.totalPotContribution = 0;\n    this.lastAction = null;\n\n    // Boolean properties for compatibility\n    this.isActive = true;\n    this.isFolded = false;\n    this.isAllIn = false;\n    this.isDealer = false;\n\n    this.stats = {\n      handsPlayed: 0,\n      handsWon: 0,\n      biggestPotWon: 0,\n      totalWinnings: 0,\n      vpip: 0,\n      pfr: 0,\n      aggression: 0,\n    };\n  }\n\n  setHoleCards(cards) {\n    this.holeCards = cards;\n    this.cards = this.holeCards; // Keep alias in sync\n  }\n\n  receiveCards(cards) {\n    this.setHoleCards(cards);\n  }\n\n  clearHoleCards() {\n    this.holeCards = [];\n    this.cards = this.holeCards; // Keep alias in sync\n  }\n\n  placeBet(amount) {\n    if (amount < 0) {\n      throw new Error('Bet amount cannot be negative');\n    }\n\n    if (amount > this.chips) {\n      throw new Error('Insufficient chips');\n    }\n\n    const betAmount = Math.min(amount, this.chips);\n    this.chips -= betAmount;\n    this._currentBet += betAmount;\n    this.totalBetThisRound += betAmount;\n    this.totalPotContribution += betAmount;\n\n    if (this.chips === 0) {\n      this.status = PLAYER_STATUS.ALL_IN;\n      this.isAllIn = true;\n    }\n\n    return betAmount;\n  }\n\n  fold() {\n    this.status = PLAYER_STATUS.FOLDED;\n    this.lastAction = 'fold';\n    this.isFolded = true;\n    this.clearHoleCards();\n  }\n\n  check() {\n    this.lastAction = 'check';\n    this.status = PLAYER_STATUS.CHECKED;\n  }\n\n  call(amount) {\n    // Handle all-in case - call with all remaining chips if not enough\n    const callAmount = amount > this.chips ? this.chips : amount;\n    const actualAmount = this.placeBet(callAmount);\n    this.lastAction = 'call';\n\n    // If player used all chips, they're all-in, otherwise they called\n    if (this.chips === 0) {\n      this.status = PLAYER_STATUS.ALL_IN;\n    } else {\n      this.status = PLAYER_STATUS.CALLED;\n    }\n\n    return actualAmount;\n  }\n\n  bet(amount) {\n    const betAmount = this.placeBet(amount);\n    this.lastAction = 'bet';\n    return betAmount;\n  }\n\n  raise(amount) {\n    if (amount <= this._currentBet) {\n      throw new Error('Raise amount must be greater than current bet');\n    }\n\n    // Calculate the additional amount to raise to the target\n    const additionalAmount = amount - this._currentBet;\n    const raiseAmount = this.placeBet(additionalAmount);\n    this.lastAction = 'raise';\n    this.status = PLAYER_STATUS.RAISED;\n    return raiseAmount;\n  }\n\n  winPot(amount) {\n    if (amount < 0) {\n      throw new Error('Win amount cannot be negative');\n    }\n\n    this.chips += amount;\n    this.stats.handsWon++;\n    this.stats.totalWinnings += amount;\n\n    if (amount > this.stats.biggestPotWon) {\n      this.stats.biggestPotWon = amount;\n    }\n  }\n\n  resetForNewHand() {\n    this.clearHoleCards();\n    this.status = PLAYER_STATUS.WAITING;\n    this._currentBet = 0;\n    this.totalBetThisRound = 0;\n    this.totalPotContribution = 0;\n    this.lastAction = null;\n    this.isActive = true; // Players should be active and ready to act\n    this.isFolded = false;\n    this.isAllIn = false;\n    this.stats.handsPlayed++;\n  }\n\n  resetBettingRound() {\n    this._currentBet = 0;\n    this.totalBetThisRound = 0;\n\n    // Don't reset folded or all-in status\n    if (this.status !== PLAYER_STATUS.FOLDED && this.status !== PLAYER_STATUS.ALL_IN) {\n      this.status = PLAYER_STATUS.WAITING;\n    }\n  }\n\n  checkIfActive() {\n    return this.status === PLAYER_STATUS.ACTIVE || this.status === PLAYER_STATUS.ALL_IN;\n  }\n\n  canAct() {\n    return (\n      this.isActive &&\n      this.chips > 0 &&\n      this.status !== PLAYER_STATUS.FOLDED &&\n      this.status !== PLAYER_STATUS.ALL_IN\n    );\n  }\n\n  isInHand() {\n    return (\n      this.isActive &&\n      this.status !== PLAYER_STATUS.FOLDED &&\n      this.status !== PLAYER_STATUS.SITTING_OUT\n    );\n  }\n\n  decideAction(gameState) {\n    // This method should only be called for AI players\n    if (!this.isAI) {\n      throw new Error('decideAction can only be called on AI players');\n    }\n\n    // Import AIPlayer service dynamically to avoid circular dependencies\n    const AIPlayer = require('../engine/AIPlayer').default;\n    const BettingLogic = require('../engine/BettingLogic').default;\n\n    // Get valid actions for this player\n    const validActions = BettingLogic.getValidActions(gameState, this);\n\n    // Get AI decision\n    return AIPlayer.getAction(this, gameState, validActions, {\n      getPlayerCards: () => this.holeCards,\n      getCommunityCards: () => gameState.communityCards,\n    });\n  }\n\n  toJSON() {\n    return {\n      id: this.id,\n      name: this.name,\n      chips: this.chips,\n      _currentBet: this._currentBet,\n      _position: this._position,\n      cards: this.cards,\n      isAI: this.isAI,\n      aiType: this.aiType,\n      status: this.status,\n      isActive: this.isActive,\n      isFolded: this.isFolded,\n      isAllIn: this.isAllIn,\n      isDealer: this.isDealer,\n      totalBetThisRound: this.totalBetThisRound,\n    };\n  }\n\n  getNetPosition() {\n    return this.chips - this.totalPotContribution;\n  }\n\n  updateStats(_action, phase) {\n    if (phase === 'preflop' && _action !== 'fold') {\n      this.stats.vpip++;\n    }\n\n    if (phase === 'preflop' && (_action === 'bet' || _action === 'raise')) {\n      this.stats.pfr++;\n    }\n\n    if (_action === 'bet' || _action === 'raise') {\n      this.stats.aggression++;\n    }\n  }\n\n  serialize() {\n    return {\n      id: this.id,\n      name: this.name,\n      chips: this.chips,\n      position: this.position,\n      isAI: this.isAI,\n      aiType: this.aiType,\n      status: this.status,\n      currentBet: this._currentBet,\n      lastAction: this.lastAction,\n      hasCards: this.holeCards.length > 0,\n      holeCards: this.isAI\n        ? null\n        : this.holeCards.map((card) => ({ rank: card.rank, suit: card.suit })),\n    };\n  }\n\n  get currentBet() {\n    return this._currentBet;\n  }\n\n  set currentBet(value) {\n    this._currentBet = value;\n  }\n}\n\nexport default Player;\n","import { useState, useEffect, useCallback, useMemo, useRef } from 'react';\n\nimport { GAME_PHASES } from '../constants/game-constants';\nimport AIPlayer from '../game/engine/AIPlayer';\nimport GameEngine from '../game/engine/GameEngine';\nimport Player from '../game/entities/Player';\n\nimport useHandHistory from './useHandHistory';\n\n/**\n * Custom hook for managing poker game state and logic\n * @param {string} humanPlayerId - ID of the human player\n * @param {Object} options - Configuration options\n * @returns {Object} Game state and control functions\n */\nconst usePokerGame = (humanPlayerId, options = {}) => {\n  const {\n    initialChips = 10000,\n    smallBlind = 50,\n    bigBlind = 100,\n    aiPlayers = [\n      { name: 'Alex (TAG)', type: 'tight-aggressive' },\n      { name: 'Sarah (LAG)', type: 'loose-aggressive' },\n      { name: 'Mike (TP)', type: 'tight-passive' },\n      { name: 'Lisa (LP)', type: 'loose-passive' },\n      { name: 'John (TAG)', type: 'tight-aggressive' },\n    ],\n    onStateChange,\n    onShowdown,\n    onPhaseChange,\n    onPlayerAction,\n  } = options;\n\n  const [gameEngine] = useState(() => new GameEngine());\n  const [gameState, setGameState] = useState(null);\n  const [showControls, setShowControls] = useState(false);\n  const [validActions, setValidActions] = useState([]);\n  const [showdown, setShowdown] = useState(false);\n  const [isProcessingAI, setIsProcessingAI] = useState(false);\n  const [error, setError] = useState(null);\n  const [isGameActive, setIsGameActive] = useState(false);\n\n  // Use ref to track processing state to avoid stale closure issues\n  const isProcessingRef = useRef(false);\n  const gameEngineRef = useRef(gameEngine);\n\n  // Initialize hand history tracking\n  const handHistory = useHandHistory();\n\n  // Process a single AI turn and return whether to continue\n  const processSingleAITurn = useCallback(() => {\n    const engine = gameEngineRef.current;\n\n    // Check game phase - don't process during waiting or showdown\n    const currentGameState = engine.getGameState();\n    if (currentGameState.phase === 'waiting' || currentGameState.phase === 'showdown') {\n      return false;\n    }\n\n    const currentPlayer = engine.getCurrentPlayer();\n\n    // Check if we should process this player\n    if (!currentPlayer || !currentPlayer.isAI) {\n      return false;\n    }\n\n    // Use canAct() method to check if player can act (not folded, not all-in, has chips)\n    if (!currentPlayer.canAct()) {\n      return false;\n    }\n\n    // Get valid actions for this AI\n    const actions = engine.getValidActions(currentPlayer.id);\n\n    // If no valid actions, player can't act\n    if (!actions || actions.length === 0) {\n      return false;\n    }\n\n    const aiAction = AIPlayer.getAction(currentPlayer, currentGameState, actions, engine);\n\n    const result = engine.executePlayerAction(currentPlayer.id, aiAction.action, aiAction.amount);\n\n    if (!result.success) {\n      // eslint-disable-next-line no-console\n      console.error('AI action failed:', result.error);\n      return false;\n    }\n\n    // Check if game ended (e.g., everyone else folded)\n    const updatedState = engine.getGameState();\n    if (updatedState.phase === 'waiting' || updatedState.phase === 'showdown') {\n      return false;\n    }\n\n    // Check if next player is also AI and can act\n    const nextPlayer = engine.getCurrentPlayer();\n    return nextPlayer && nextPlayer.isAI && nextPlayer.canAct();\n  }, []);\n\n  // Process all AI turns in sequence\n  const processAITurns = useCallback(() => {\n    // Strict guard - only one processing chain at a time\n    if (isProcessingRef.current) {\n      return;\n    }\n\n    const engine = gameEngineRef.current;\n\n    // Check game phase - don't process during waiting or showdown\n    const currentGameState = engine.getGameState();\n    if (currentGameState.phase === 'waiting' || currentGameState.phase === 'showdown') {\n      return;\n    }\n\n    const currentPlayer = engine.getCurrentPlayer();\n\n    // Only start if it's actually an AI's turn and they can act\n    if (!currentPlayer || !currentPlayer.isAI || !currentPlayer.canAct()) {\n      return;\n    }\n\n    // Lock processing\n    isProcessingRef.current = true;\n    setIsProcessingAI(true);\n\n    // Process AI turns with delays between each\n    const processNext = () => {\n      try {\n        const shouldContinue = processSingleAITurn();\n\n        if (shouldContinue) {\n          // More AI to process - continue after delay\n          setTimeout(processNext, 800);\n        } else {\n          // Done processing - unlock\n          isProcessingRef.current = false;\n          setIsProcessingAI(false);\n        }\n      } catch (err) {\n        // eslint-disable-next-line no-console\n        console.error('AI processing error:', err);\n        setError(`AI action failed: ${err.message}`);\n        isProcessingRef.current = false;\n        setIsProcessingAI(false);\n      }\n    };\n\n    // Start processing after initial delay\n    setTimeout(processNext, 800);\n  }, [processSingleAITurn]);\n\n  // Initialize game with players\n  const initializeGame = useCallback(() => {\n    try {\n      const engine = gameEngineRef.current;\n\n      // Prevent multiple initializations\n      if (engine._isInitialized) {\n        return;\n      }\n\n      engine._isInitialized = true;\n\n      // Add human player\n      const humanPlayer = new Player(humanPlayerId, 'You', initialChips, 0, false);\n      engine.addPlayer(humanPlayer);\n\n      // Add AI players\n      aiPlayers.forEach((aiConfig, idx) => {\n        const aiPlayer = new Player(\n          `ai-${idx + 1}`,\n          aiConfig.name,\n          initialChips,\n          idx + 1,\n          true,\n          aiConfig.type\n        );\n        engine.addPlayer(aiPlayer);\n      });\n\n      engine.setBlinds(smallBlind, bigBlind);\n\n      // Start first hand after a delay\n      setTimeout(() => {\n        try {\n          setIsGameActive(true);\n          engine.startNewHand();\n        } catch (err) {\n          setError(`Failed to start new hand: ${err.message}`);\n          engine._isInitialized = false;\n          setIsGameActive(false);\n        }\n      }, 1000);\n    } catch (err) {\n      setError(`Failed to initialize game: ${err.message}`);\n      gameEngineRef.current._isInitialized = false;\n    }\n  }, [humanPlayerId, initialChips, smallBlind, bigBlind, aiPlayers]);\n\n  // Initialize game callbacks\n  useEffect(() => {\n    const engine = gameEngineRef.current;\n\n    // Prevent duplicate callback setup\n    if (engine._callbacksInitialized) {\n      return;\n    }\n    engine._callbacksInitialized = true;\n\n    engine.setCallback('onStateChange', (newState) => {\n      // Add timestamp to ensure React sees a new object reference\n      const stateWithTimestamp = {\n        ...newState,\n        _updateTimestamp: Date.now(),\n      };\n      setGameState(stateWithTimestamp);\n      setError(null);\n\n      // Use getCurrentPlayer() from engine for most up-to-date info\n      const currentPlayer = engine.getCurrentPlayer();\n      if (currentPlayer && currentPlayer.id === humanPlayerId) {\n        const actions = engine.getValidActions(humanPlayerId);\n        setValidActions(actions);\n        setShowControls(true);\n      } else {\n        setShowControls(false);\n        setValidActions([]);\n      }\n\n      if (onStateChange) {\n        onStateChange(newState);\n      }\n    });\n\n    engine.setCallback('onShowdown', (winners) => {\n      setShowdown(true);\n      setTimeout(() => setShowdown(false), 5000);\n\n      if (onShowdown) {\n        onShowdown(winners);\n      }\n    });\n\n    engine.setCallback('onPhaseChange', (phase) => {\n      if (phase !== GAME_PHASES.SHOWDOWN) {\n        setShowdown(false);\n      }\n\n      if (onPhaseChange) {\n        onPhaseChange(phase);\n      }\n    });\n\n    engine.setCallback('onPlayerAction', (player, action, amount) => {\n      // Capture action in hand history\n      if (isGameActive && handHistory.isSessionActive) {\n        handHistory.captureAction(player.id, action, amount);\n      }\n\n      if (onPlayerAction) {\n        onPlayerAction(player, action, amount);\n      }\n    });\n\n    initializeGame();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [humanPlayerId, initializeGame]);\n\n  // Handle human player action\n  const executeAction = useCallback(\n    (action, amount) => {\n      try {\n        setError(null);\n        const engine = gameEngineRef.current;\n        const result = engine.executePlayerAction(humanPlayerId, action, amount);\n\n        // Check if action succeeded\n        if (!result.success) {\n          setError(`Action failed: ${result.error}`);\n          return;\n        }\n\n        // Reset processing flag to ensure fresh start for AI turns\n        isProcessingRef.current = false;\n\n        // Process AI turns after human action (with delay)\n        // Using a longer delay to ensure state has propagated\n        setTimeout(() => {\n          // Double-check current player is AI before processing\n          const currentPlayer = engine.getCurrentPlayer();\n          if (currentPlayer && currentPlayer.isAI && currentPlayer.canAct()) {\n            processAITurns();\n          }\n        }, 600);\n      } catch (err) {\n        setError(`Action failed: ${err.message}`);\n      }\n    },\n    [humanPlayerId, processAITurns]\n  );\n\n  // Get current player info (memoized for performance)\n  const getCurrentPlayerInfo = useMemo(() => {\n    if (!gameState || !gameState.players || gameState.players.length === 0) {\n      return { humanPlayer: null, currentPlayer: null, isHumanTurn: false };\n    }\n\n    const humanPlayer = gameState.players.find((p) => p && p.id === humanPlayerId);\n\n    // Safe player access with bounds checking\n    const currentPlayer =\n      gameState.currentPlayerIndex >= 0 && gameState.currentPlayerIndex < gameState.players.length\n        ? gameState.players[gameState.currentPlayerIndex]\n        : null;\n\n    const isHumanTurn = currentPlayer && humanPlayer && currentPlayer.id === humanPlayer.id;\n\n    return {\n      humanPlayer,\n      currentPlayer,\n      isHumanTurn,\n    };\n  }, [gameState, humanPlayerId]);\n\n  // Auto-process AI turns when it's their turn (with debounce)\n  useEffect(() => {\n    if (!gameState) return;\n\n    // Don't start if already processing\n    if (isProcessingRef.current) {\n      return;\n    }\n\n    // Skip if in waiting or showdown phase\n    if (gameState.phase === 'waiting' || gameState.phase === 'showdown') {\n      return;\n    }\n\n    const engine = gameEngineRef.current;\n    const currentPlayer = engine.getCurrentPlayer();\n\n    // If no current player, something is wrong - skip\n    if (!currentPlayer) {\n      return;\n    }\n\n    // Check if current player is AI and can act\n    if (currentPlayer.isAI && currentPlayer.canAct()) {\n      // Use timeout to debounce and prevent race conditions\n      const timeoutId = setTimeout(() => {\n        // Double-check conditions before processing\n        if (!isProcessingRef.current) {\n          const stillCurrentPlayer = engine.getCurrentPlayer();\n          if (stillCurrentPlayer && stillCurrentPlayer.isAI && stillCurrentPlayer.canAct()) {\n            processAITurns();\n          }\n        }\n      }, 150);\n\n      return () => clearTimeout(timeoutId);\n    }\n\n    // DEFENSIVE FIX: If current player can't act (all-in, folded, etc.),\n    // trigger game advancement. This handles edge cases where the game engine\n    // didn't properly advance past a non-acting player.\n    if (!currentPlayer.canAct() && currentPlayer.isAI) {\n      const timeoutId = setTimeout(() => {\n        // Force the game engine to advance to next player or phase\n        const checkEngine = gameEngineRef.current;\n        const checkPlayer = checkEngine.getCurrentPlayer();\n\n        // Only trigger if still stuck on a non-acting player\n        if (checkPlayer && !checkPlayer.canAct()) {\n          // Call checkAndAdvanceGame to force game progression\n          checkEngine.checkAndAdvanceGame();\n        }\n      }, 200);\n\n      return () => clearTimeout(timeoutId);\n    }\n  }, [gameState, processAITurns]);\n\n  return {\n    // State\n    gameState,\n    showControls,\n    validActions,\n    showdown,\n    isProcessingAI,\n    error,\n    isGameActive,\n\n    // Functions\n    executeAction,\n    getCurrentPlayerInfo,\n\n    // Engine reference (for advanced features)\n    gameEngine,\n\n    // Human player ID\n    humanPlayerId,\n\n    // Hand history\n    handHistory,\n  };\n};\n\nexport default usePokerGame;\n","import React, { useState, useEffect, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport './BettingControls.css';\n\nconst BettingControls = React.memo(\n  ({ validActions, _currentBet, playerChips, playerBet, _pot, onAction, minBet, minRaise }) => {\n    const callAmount = Math.max(0, (_currentBet || 0) - (playerBet || 0));\n    const [betAmount, setBetAmount] = useState(minBet || minRaise || 0);\n\n    useEffect(() => {\n      if (validActions.includes('bet')) {\n        setBetAmount(minBet);\n      } else if (validActions.includes('raise')) {\n        setBetAmount(minRaise);\n      }\n    }, [validActions, minBet, minRaise]);\n\n    const handleSliderChange = useCallback((e) => {\n      setBetAmount(parseInt(e.target.value));\n    }, []);\n\n    const handleInputChange = useCallback(\n      (e) => {\n        const value = parseInt(e.target.value) || 0;\n        setBetAmount(Math.min(value, playerChips));\n      },\n      [playerChips]\n    );\n\n    const setPresetBet = useCallback(\n      (fraction) => {\n        let amount;\n        if (fraction === 'all') {\n          amount = playerChips || 0;\n        } else {\n          amount = Math.floor((_pot || 0) * fraction);\n        }\n\n        if (validActions.includes('bet')) {\n          amount = Math.max(amount, minBet || 0);\n        } else if (validActions.includes('raise')) {\n          amount = Math.max(amount, minRaise || 0);\n        }\n\n        setBetAmount(Math.min(amount, playerChips || 0));\n      },\n      [_pot, playerChips, minBet, minRaise, validActions]\n    );\n\n    const getPotOdds = () => {\n      if (callAmount === 0) return null;\n      const potAfterCall = (_pot || 0) + callAmount;\n      if (potAfterCall === 0) return null;\n      const odds = ((callAmount / potAfterCall) * 100).toFixed(1);\n      return odds;\n    };\n\n    const potOdds = getPotOdds();\n\n    return (\n      <div\n        className=\"betting-controls\"\n        role=\"region\"\n        aria-label=\"Betting controls\"\n        aria-describedby=\"betting-info pot-odds\"\n      >\n        <div className=\"betting-info\" id=\"betting-info\" role=\"group\" aria-label=\"Game information\">\n          <div className=\"betting-info-item\">\n            <span className=\"betting-info-label\">Pot</span>\n            <span className=\"betting-info-value\">${_pot || 0}</span>\n          </div>\n          <div className=\"betting-info-item\">\n            <span className=\"betting-info-label\">To Call</span>\n            <span className=\"betting-info-value\">${callAmount || 0}</span>\n          </div>\n          <div className=\"betting-info-item\">\n            <span className=\"betting-info-label\">Your Stack</span>\n            <span className=\"betting-info-value\">${playerChips || 0}</span>\n          </div>\n        </div>\n\n        {(validActions.includes('bet') || validActions.includes('raise')) && (\n          <div className=\"betting-slider-container\" role=\"group\" aria-label=\"Bet amount controls\">\n            <div className=\"bet-amount-display\">\n              <label htmlFor=\"bet-amount-input\" className=\"bet-amount-label\">\n                {validActions.includes('bet') ? 'Bet Amount:' : 'Raise To:'}\n              </label>\n              <input\n                id=\"bet-amount-input\"\n                type=\"number\"\n                className=\"bet-amount-input\"\n                value={betAmount}\n                onChange={handleInputChange}\n                min={validActions.includes('bet') ? minBet : minRaise}\n                max={playerChips}\n                aria-describedby=\"bet-range-slider\"\n                aria-label={`${validActions.includes('bet') ? 'Bet' : 'Raise'} amount in dollars`}\n              />\n            </div>\n\n            <input\n              id=\"bet-range-slider\"\n              type=\"range\"\n              className=\"betting-slider\"\n              min={validActions.includes('bet') ? minBet : minRaise}\n              max={playerChips}\n              value={betAmount}\n              onChange={handleSliderChange}\n              aria-label={`Adjust ${validActions.includes('bet') ? 'bet' : 'raise'} amount with slider`}\n              aria-valuemin={validActions.includes('bet') ? minBet : minRaise}\n              aria-valuemax={playerChips}\n              aria-valuenow={betAmount}\n              aria-valuetext={`$${betAmount}`}\n            />\n\n            <div className=\"preset-buttons\" role=\"group\" aria-label=\"Preset bet amounts\">\n              <button\n                className=\"preset-button\"\n                onClick={() => setPresetBet(1 / 3)}\n                aria-label={`Set bet to one third of pot: $${Math.floor((_pot || 0) / 3)}`}\n              >\n                1/3 Pot\n              </button>\n              <button\n                className=\"preset-button\"\n                onClick={() => setPresetBet(1 / 2)}\n                aria-label={`Set bet to half of pot: $${Math.floor((_pot || 0) / 2)}`}\n              >\n                1/2 Pot\n              </button>\n              <button\n                className=\"preset-button\"\n                onClick={() => setPresetBet(1)}\n                aria-label={`Set bet to full pot: $${_pot || 0}`}\n              >\n                Pot\n              </button>\n              <button\n                className=\"preset-button\"\n                onClick={() => setPresetBet('all')}\n                aria-label={`Go all in with all chips: $${playerChips}`}\n              >\n                All In\n              </button>\n            </div>\n          </div>\n        )}\n\n        <div className=\"action-buttons\" role=\"group\" aria-label=\"Poker action buttons\">\n          {validActions.includes('fold') && (\n            <button\n              className=\"action-button fold\"\n              onClick={() => onAction('fold')}\n              aria-label=\"Fold your hand and forfeit this round\"\n              aria-describedby=\"betting-info\"\n            >\n              Fold\n            </button>\n          )}\n\n          {validActions.includes('check') && (\n            <button\n              className=\"action-button check\"\n              onClick={() => onAction('check')}\n              aria-label=\"Check - no bet required\"\n              aria-describedby=\"betting-info\"\n            >\n              Check\n            </button>\n          )}\n\n          {validActions.includes('call') && (\n            <button\n              className=\"action-button call\"\n              onClick={() => onAction('call', callAmount)}\n              aria-label={`Call the current bet of $${callAmount || 0}`}\n              aria-describedby=\"betting-info\"\n            >\n              Call ${callAmount || 0}\n            </button>\n          )}\n\n          {validActions.includes('bet') && (\n            <button\n              className=\"action-button bet\"\n              onClick={() => onAction('bet', betAmount)}\n              disabled={betAmount < minBet || betAmount > playerChips}\n              aria-label={`Bet $${betAmount}`}\n              aria-describedby=\"betting-info bet-amount-input\"\n              aria-disabled={betAmount < minBet || betAmount > playerChips}\n            >\n              Bet ${betAmount}\n            </button>\n          )}\n\n          {validActions.includes('raise') && (\n            <button\n              className=\"action-button raise\"\n              onClick={() => onAction('raise', betAmount)}\n              disabled={betAmount < minRaise || betAmount > playerChips}\n              aria-label={`Raise the bet to $${betAmount}`}\n              aria-describedby=\"betting-info bet-amount-input\"\n              aria-disabled={betAmount < minRaise || betAmount > playerChips}\n            >\n              Raise to ${betAmount}\n            </button>\n          )}\n\n          {validActions.includes('all-in') && (\n            <button\n              className=\"action-button all-in\"\n              onClick={() => onAction('all-in', playerChips)}\n              aria-label={`Go all in with all your chips: $${playerChips}`}\n              aria-describedby=\"betting-info\"\n            >\n              All In ${playerChips}\n            </button>\n          )}\n        </div>\n\n        {potOdds && (\n          <div\n            className=\"pot-odds-display\"\n            id=\"pot-odds\"\n            role=\"status\"\n            aria-live=\"polite\"\n            aria-label={`Pot odds: ${potOdds}% ${parseFloat(potOdds) < 30 ? 'This is a good betting opportunity' : ''}`}\n          >\n            Pot Odds: {potOdds}%\n            {parseFloat(potOdds) < 30 && (\n              <span className=\"pot-odds-good\" aria-label=\"Good betting odds\">\n                {' '}\n                (Good)\n              </span>\n            )}\n          </div>\n        )}\n      </div>\n    );\n  },\n  (prevProps, nextProps) => {\n    // Custom comparison for performance optimization\n    return (\n      JSON.stringify(prevProps.validActions) === JSON.stringify(nextProps.validActions) &&\n      prevProps._currentBet === nextProps._currentBet &&\n      prevProps.playerChips === nextProps.playerChips &&\n      prevProps.playerBet === nextProps.playerBet &&\n      prevProps._pot === nextProps._pot &&\n      prevProps.minBet === nextProps.minBet &&\n      prevProps.minRaise === nextProps.minRaise &&\n      prevProps.onAction === nextProps.onAction\n    );\n  }\n);\n\nBettingControls.displayName = 'BettingControls';\n\nBettingControls.propTypes = {\n  validActions: PropTypes.arrayOf(PropTypes.string).isRequired,\n  _currentBet: PropTypes.number,\n  playerChips: PropTypes.number.isRequired,\n  playerBet: PropTypes.number,\n  _pot: PropTypes.number,\n  onAction: PropTypes.func.isRequired,\n  minBet: PropTypes.number,\n  minRaise: PropTypes.number,\n};\n\nexport default BettingControls;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport './Card.css';\n\nconst Card = React.memo(\n  ({ card, size = 'normal', faceDown = false }) => {\n    if (!card && !faceDown) {\n      return <div className=\"card-placeholder\" aria-label=\"Empty card slot\" role=\"img\" />;\n    }\n\n    const getSuitSymbol = (suit) => {\n      const symbols = {\n        s: '',\n        h: '',\n        d: '',\n        c: '',\n      };\n      return symbols[suit] || '';\n    };\n\n    const getSuitClass = (suit) => {\n      const classes = {\n        s: 'spades',\n        h: 'hearts',\n        d: 'diamonds',\n        c: 'clubs',\n      };\n      return classes[suit] || '';\n    };\n\n    if (faceDown) {\n      return (\n        <div\n          className={`playing-card back ${size}`}\n          role=\"img\"\n          aria-label=\"Face-down playing card\"\n        />\n      );\n    }\n\n    const suitClass = getSuitClass(card.suit);\n    const suitSymbol = getSuitSymbol(card.suit);\n\n    const getSuitName = (suit) => {\n      const names = {\n        s: 'spades',\n        h: 'hearts',\n        d: 'diamonds',\n        c: 'clubs',\n      };\n      return names[suit] || '';\n    };\n\n    const getCardDescription = () => {\n      const suitName = getSuitName(card.suit);\n      return `${card.rank} of ${suitName}`;\n    };\n\n    return (\n      <div\n        className={`playing-card ${suitClass} ${size}`}\n        role=\"img\"\n        aria-label={getCardDescription()}\n      >\n        <div className=\"card-corner top-left\">\n          <span>{card.rank}</span>\n          <span className=\"card-corner-suit\">{suitSymbol}</span>\n        </div>\n\n        <div className=\"card-center\">\n          <div className=\"card-rank\">{card.rank}</div>\n          <div className=\"card-suit\">{suitSymbol}</div>\n        </div>\n\n        <div className=\"card-corner bottom-right\">\n          <span>{card.rank}</span>\n          <span className=\"card-corner-suit\">{suitSymbol}</span>\n        </div>\n      </div>\n    );\n  },\n  (prevProps, nextProps) =>\n    // Custom comparison function for better performance\n    prevProps.size === nextProps.size &&\n    prevProps.faceDown === nextProps.faceDown &&\n    prevProps.card?.rank === nextProps.card?.rank &&\n    prevProps.card?.suit === nextProps.card?.suit\n);\n\nCard.displayName = 'Card';\n\nCard.propTypes = {\n  card: PropTypes.shape({\n    rank: PropTypes.string.isRequired,\n    suit: PropTypes.string.isRequired,\n  }),\n  size: PropTypes.oneOf(['small', 'normal', 'large']),\n  faceDown: PropTypes.bool,\n};\n\nexport default Card;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport Card from './Card';\nimport './PlayerSeat.css';\n\nconst PlayerSeat = React.memo(\n  ({ player, isActive, isDealer, position, showCards }) => {\n    if (!player) {\n      return null;\n    }\n\n    const getPositionLabel = () => {\n      if (isDealer) return 'BTN';\n\n      const labels = {\n        'small-blind': 'SB',\n        'big-blind': 'BB',\n        'under-the-gun': 'UTG',\n        'middle-position': 'MP',\n        'cut-off': 'CO',\n      };\n\n      return labels[position] || '';\n    };\n\n    const formatChips = (amount) => {\n      if (amount >= 1000000) {\n        return `${(amount / 1000000).toFixed(1)}M`;\n      } else if (amount >= 1000) {\n        return `${(amount / 1000).toFixed(1)}K`;\n      }\n      return amount.toString();\n    };\n\n    const positionLabel = getPositionLabel();\n    const seatClasses = [\n      'player-seat',\n      `position-${player.position}`,\n      isActive ? 'active' : '',\n      player.status === 'folded' ? 'folded' : '',\n    ]\n      .filter(Boolean)\n      .join(' ');\n\n    return (\n      <div className={seatClasses}>\n        {positionLabel && <div className=\"position-label\">{positionLabel}</div>}\n\n        {player.status === 'all-in' && <div className=\"player-status-icon\">AI</div>}\n\n        <div className=\"player-info\">\n          <span className=\"player-name\">{player.name}</span>\n          <span className=\"player-chips\">${formatChips(player.chips)}</span>\n        </div>\n\n        <div className=\"player-cards\">\n          {player.holeCards && player.holeCards.length > 0 && player.status !== 'folded' ? (\n            <>\n              {showCards && player.holeCards ? (\n                player.holeCards.map((card, _index) => (\n                  <Card key={_index} card={card} size=\"small\" />\n                ))\n              ) : (\n                <>\n                  <Card faceDown size=\"small\" />\n                  <Card faceDown size=\"small\" />\n                </>\n              )}\n            </>\n          ) : null}\n        </div>\n\n        {player.currentBet > 0 && <div className=\"player-bet\">${player.currentBet}</div>}\n\n        {player.lastAction && (\n          <div className={`player-_action ${player.lastAction}`}>{player.lastAction}</div>\n        )}\n\n        {isActive && (\n          <div className=\"player-timer\">\n            <div className=\"player-timer-bar\" style={{ width: '100%' }} />\n          </div>\n        )}\n      </div>\n    );\n  },\n  (prevProps, nextProps) => {\n    // Custom comparison to prevent unnecessary re-renders\n    const prevPlayer = prevProps.player;\n    const nextPlayer = nextProps.player;\n\n    if (!prevPlayer && !nextPlayer) return true;\n    if (!prevPlayer || !nextPlayer) return false;\n\n    return (\n      prevProps.isActive === nextProps.isActive &&\n      prevProps.isDealer === nextProps.isDealer &&\n      prevProps.position === nextProps.position &&\n      prevProps.showCards === nextProps.showCards &&\n      prevPlayer.id === nextPlayer.id &&\n      prevPlayer.name === nextPlayer.name &&\n      prevPlayer.chips === nextPlayer.chips &&\n      prevPlayer.status === nextPlayer.status &&\n      prevPlayer.currentBet === nextPlayer.currentBet &&\n      prevPlayer.lastAction === nextPlayer.lastAction &&\n      prevPlayer.hasCards === nextPlayer.hasCards &&\n      JSON.stringify(prevPlayer.holeCards) === JSON.stringify(nextPlayer.holeCards)\n    );\n  }\n);\n\nPlayerSeat.displayName = 'PlayerSeat';\n\nPlayerSeat.propTypes = {\n  player: PropTypes.shape({\n    id: PropTypes.string.isRequired,\n    name: PropTypes.string.isRequired,\n    chips: PropTypes.number.isRequired,\n    position: PropTypes.number,\n    status: PropTypes.string,\n    currentBet: PropTypes.number,\n    lastAction: PropTypes.string,\n    holeCards: PropTypes.arrayOf(\n      PropTypes.shape({\n        rank: PropTypes.string,\n        suit: PropTypes.string,\n      })\n    ),\n    hasCards: PropTypes.bool,\n  }),\n  isActive: PropTypes.bool,\n  isDealer: PropTypes.bool,\n  position: PropTypes.string,\n  showCards: PropTypes.bool,\n};\n\nexport default PlayerSeat;\n","import PropTypes from 'prop-types';\nimport { useState, useEffect } from 'react';\n\nimport usePokerGame from '../../hooks/usePokerGame';\n\nimport BettingControls from './BettingControls';\nimport Card from './Card';\nimport PlayerSeat from './PlayerSeat';\nimport './PokerTable.css';\n\n/**\n * Poker Table Component\n * Main poker table component that handles game display and interaction\n */\nconst PokerTable = ({ onGameStateChange, onPlayerAction } = {}) => {\n  const humanPlayerId = 'human-player';\n\n  const {\n    gameState,\n    showControls,\n    validActions,\n    showdown,\n    error,\n    isProcessingAI,\n    executeAction,\n    getCurrentPlayerInfo,\n    gameEngine,\n  } = usePokerGame(humanPlayerId, {\n    onStateChange: onGameStateChange,\n    onPlayerAction,\n  });\n\n  // Countdown for next hand - must be declared before any early returns\n  const [countdown, setCountdown] = useState(3);\n\n  // Determine if waiting phase for countdown effect\n  const isWaitingPhase = gameState?.phase === 'waiting';\n\n  useEffect(() => {\n    if (isWaitingPhase) {\n      setCountdown(3);\n      const timer = setInterval(() => {\n        setCountdown((prev) => {\n          if (prev <= 1) {\n            clearInterval(timer);\n            return 0;\n          }\n          return prev - 1;\n        });\n      }, 1000);\n      return () => clearInterval(timer);\n    }\n  }, [isWaitingPhase]);\n\n  // Handle starting a new hand manually\n  const handleNewHand = () => {\n    try {\n      if (gameEngine) {\n        gameEngine.startNewHand();\n      }\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Failed to start new hand:', err);\n    }\n  };\n\n  if (!gameState) {\n    return (\n      <div className=\"poker-table-container\">\n        <div className=\"loading\">Loading game...</div>\n      </div>\n    );\n  }\n\n  // Debug logging\n  if (process.env.NODE_ENV === 'development') {\n    // eslint-disable-next-line no-console\n    console.log('Game State:', {\n      players: gameState.players?.length,\n      phase: gameState.phase,\n      pot: gameState._pot,\n      currentPlayer: gameState.currentPlayerIndex,\n      communityCards: gameState.communityCards?.length,\n    });\n  }\n\n  const { humanPlayer, isHumanTurn, currentPlayer } = getCurrentPlayerInfo;\n\n  // Determine game status for display\n  const isShowdownPhase = gameState.phase === 'showdown';\n  const canShowControls = showControls && humanPlayer && isHumanTurn && !isWaitingPhase;\n\n  return (\n    <div className=\"poker-table-container\">\n      {error && (\n        <div className=\"error-banner\" role=\"alert\" aria-live=\"assertive\" aria-atomic=\"true\">\n          {error}\n        </div>\n      )}\n\n      <main className=\"poker-table\" role=\"main\" aria-label=\"Poker game table\">\n        <div className=\"table-rail\" />\n\n        <section className=\"player-seats\" aria-label=\"Player seating positions\">\n          {gameState.players &&\n            gameState.players\n              .filter((player) => player != null)\n              .map((player) => (\n                <PlayerSeat\n                  key={player.id}\n                  player={player}\n                  isActive={gameState.currentPlayerIndex === player.position}\n                  isDealer={gameState.dealerPosition === player.position}\n                  showCards={player.id === humanPlayerId || showdown}\n                />\n              ))}\n        </section>\n\n        <section\n          className=\"community-cards\"\n          aria-label=\"Community cards\"\n          aria-describedby=\"game-phase-indicator\"\n        >\n          {gameState.communityCards &&\n            gameState.communityCards.map((card, index) => (\n              <Card key={`card-${card.rank}-${card.suit}-${index}`} card={card} />\n            ))}\n          {(() => {\n            const communityCardCount = gameState.communityCards\n              ? gameState.communityCards.length\n              : 0;\n            const placeholderCount = Math.max(0, 5 - communityCardCount);\n            return [...Array(placeholderCount)].map((_, index) => (\n              <Card key={`placeholder-${index}`} />\n            ));\n          })()}\n        </section>\n\n        <div\n          className=\"pot-display\"\n          role=\"status\"\n          aria-live=\"polite\"\n          aria-label={`Current pot amount: $${gameState._pot || 0}`}\n        >\n          Pot: ${gameState._pot || 0}\n        </div>\n\n        <aside className=\"game-info\" aria-label=\"Game information\">\n          <h3>Game Info</h3>\n          <div className=\"game-info-item\">\n            <span>Hand #</span>\n            <span aria-label={`Hand number ${gameState.handNumber}`}>{gameState.handNumber}</span>\n          </div>\n          <div className=\"game-info-item\">\n            <span>Blinds</span>\n            <span\n              aria-label={`Small blind $${gameState.blinds.small}, big blind $${gameState.blinds.big}`}\n            >\n              ${gameState.blinds.small}/${gameState.blinds.big}\n            </span>\n          </div>\n          <div className=\"game-info-item\">\n            <span>Players</span>\n            <span\n              aria-label={`${gameState.getPlayersInHand ? gameState.getPlayersInHand().length : gameState.players.length} players in game`}\n            >\n              {gameState.getPlayersInHand\n                ? gameState.getPlayersInHand().length\n                : gameState.players.length}\n            </span>\n          </div>\n        </aside>\n\n        <div\n          id=\"game-phase-indicator\"\n          className=\"phase-indicator\"\n          role=\"status\"\n          aria-live=\"polite\"\n          aria-label={`Current game phase: ${gameState.phase}`}\n        >\n          {gameState.phase}\n        </div>\n\n        {showdown && gameState.winners && gameState.winners.length > 0 && (\n          <section\n            className=\"winners-display\"\n            role=\"status\"\n            aria-live=\"assertive\"\n            aria-label=\"Hand results\"\n          >\n            <h2>Winner{gameState.winners.length > 1 ? 's' : ''}!</h2>\n            {gameState.winners.map((winner, _index) => (\n              <div\n                key={_index}\n                className=\"winner-item\"\n                aria-label={`${winner.player.name} wins $${winner.amount} with ${winner.handDescription}`}\n              >\n                <div>\n                  {winner.player.name} wins ${winner.amount}\n                </div>\n                <div className=\"winner-hand\">{winner.handDescription}</div>\n              </div>\n            ))}\n          </section>\n        )}\n\n        <div\n          className=\"dealer-button\"\n          style={{\n            transform: `translate(-50%, -50%)\n                     rotate(${gameState.dealerPosition * (360 / gameState.players.length)}deg)\n                     translateX(200px)`,\n          }}\n          role=\"img\"\n          aria-label={`Dealer button at position ${gameState.dealerPosition + 1}`}\n        >\n          D\n        </div>\n      </main>\n\n      {/* Game Status Panel - Always visible */}\n      <div className=\"game-status-panel\" role=\"status\" aria-live=\"polite\">\n        {isWaitingPhase && (\n          <div className=\"status-waiting\">\n            <p>Hand complete. Next hand in {countdown}...</p>\n            <button className=\"new-hand-button\" onClick={handleNewHand}>\n              Start Now\n            </button>\n          </div>\n        )}\n\n        {isProcessingAI && !isWaitingPhase && !isShowdownPhase && (\n          <div className=\"status-ai-thinking\">\n            <div className=\"thinking-indicator\">\n              <span className=\"dot\"></span>\n              <span className=\"dot\"></span>\n              <span className=\"dot\"></span>\n            </div>\n            <p>{currentPlayer?.name || 'AI'} is thinking...</p>\n          </div>\n        )}\n\n        {!isWaitingPhase &&\n          !isProcessingAI &&\n          !isHumanTurn &&\n          !isShowdownPhase &&\n          currentPlayer && (\n            <div className=\"status-other-turn\">\n              <p>Waiting for {currentPlayer.name}...</p>\n            </div>\n          )}\n\n        {isHumanTurn && !isWaitingPhase && !isShowdownPhase && (\n          <div className=\"status-your-turn\">\n            <p>Your turn to act!</p>\n          </div>\n        )}\n      </div>\n\n      {/* Betting Controls - Show when it's human's turn */}\n      {canShowControls && (\n        <BettingControls\n          validActions={validActions}\n          _currentBet={gameState.currentBet}\n          playerChips={humanPlayer.chips}\n          playerBet={humanPlayer.currentBet}\n          _pot={gameState._pot || 0}\n          minBet={gameState.blinds.big}\n          minRaise={gameState.currentBet + gameState.minimumRaise}\n          onAction={executeAction}\n        />\n      )}\n    </div>\n  );\n};\n\nPokerTable.propTypes = {\n  onGameStateChange: PropTypes.func,\n  onPlayerAction: PropTypes.func,\n};\n\nexport default PokerTable;\n","import { PLAYER_ACTIONS } from '../../constants/game-constants';\n\nclass BettingLogic {\n  static validateAction(gameState, player, _action, amount = 0) {\n    if (!player.canAct()) {\n      return { valid: false, reason: 'Player cannot act' };\n    }\n\n    const callAmount = gameState.currentBet - player.currentBet;\n\n    switch (_action) {\n      case PLAYER_ACTIONS.FOLD:\n        return { valid: true };\n\n      case PLAYER_ACTIONS.CHECK:\n        if (callAmount > 0) {\n          return {\n            valid: false,\n            reason: 'Cannot check when there is a bet to call',\n          };\n        }\n        return { valid: true };\n\n      case PLAYER_ACTIONS.CALL:\n        if (callAmount === 0) {\n          return { valid: false, reason: 'Nothing to call' };\n        }\n        // Allow calling even if player doesn't have enough chips (all-in for less)\n        return { valid: true, amount: Math.min(callAmount, player.chips) };\n\n      case PLAYER_ACTIONS.BET:\n        if (gameState.currentBet > 0) {\n          return {\n            valid: false,\n            reason: 'Cannot bet when there is already a bet',\n          };\n        }\n        if (amount < gameState.blinds.big) {\n          return { valid: false, reason: 'Bet must be at least the big blind' };\n        }\n        if (amount > player.chips) {\n          return { valid: false, reason: 'Not enough chips' };\n        }\n        return { valid: true, amount };\n\n      case PLAYER_ACTIONS.RAISE: {\n        if (gameState.currentBet === 0) {\n          return { valid: false, reason: 'Cannot raise when there is no bet' };\n        }\n        const minRaise = gameState.currentBet + gameState.minimumRaise;\n        if (amount < minRaise && amount < player.chips) {\n          return { valid: false, reason: `Raise must be at least ${minRaise}` };\n        }\n        if (amount > player.chips) {\n          return { valid: false, reason: 'Not enough chips' };\n        }\n        return { valid: true, amount: Math.min(amount, player.chips) };\n      }\n\n      case PLAYER_ACTIONS.ALL_IN:\n        return { valid: true, amount: player.chips };\n\n      default:\n        return { valid: false, reason: 'Invalid _action' };\n    }\n  }\n\n  static getValidActions(gameState, player) {\n    if (!player.canAct()) {\n      return [];\n    }\n\n    const validActions = [];\n    const callAmount = gameState.currentBet - player.currentBet;\n\n    validActions.push(PLAYER_ACTIONS.FOLD);\n\n    if (callAmount === 0) {\n      validActions.push(PLAYER_ACTIONS.CHECK);\n\n      if (player.chips >= gameState.blinds.big) {\n        validActions.push(PLAYER_ACTIONS.BET);\n      }\n    } else {\n      if (player.chips >= callAmount) {\n        validActions.push(PLAYER_ACTIONS.CALL);\n      }\n\n      const minRaise = gameState.currentBet + gameState.minimumRaise;\n      if (player.chips >= minRaise) {\n        validActions.push(PLAYER_ACTIONS.RAISE);\n      }\n    }\n\n    if (\n      player.chips > 0 &&\n      (callAmount > 0 || gameState.currentBet === 0) &&\n      !validActions.includes(PLAYER_ACTIONS.CALL) &&\n      !validActions.includes(PLAYER_ACTIONS.RAISE)\n    ) {\n      validActions.push(PLAYER_ACTIONS.ALL_IN);\n    }\n\n    return validActions;\n  }\n\n  static executeAction(gameState, player, _action, amount = 0) {\n    const validation = this.validateAction(gameState, player, _action, amount);\n    if (!validation.valid) {\n      throw new Error(validation.reason);\n    }\n\n    const previousBet = player.currentBet;\n\n    switch (_action) {\n      case PLAYER_ACTIONS.FOLD:\n        player.fold();\n        break;\n\n      case PLAYER_ACTIONS.CHECK:\n        player.check();\n        break;\n\n      case PLAYER_ACTIONS.CALL: {\n        const callAmount = validation.amount || gameState.currentBet - player.currentBet;\n        const actualCall = Math.min(callAmount, player.chips);\n        player.call(actualCall);\n        gameState.potObject.main += actualCall;\n        break;\n      }\n\n      case PLAYER_ACTIONS.BET:\n        player.bet(validation.amount);\n        gameState.currentBet = validation.amount;\n        gameState.minimumRaise = validation.amount;\n        gameState.potObject.main += validation.amount;\n        gameState.lastRaiserIndex = player.position;\n        break;\n\n      case PLAYER_ACTIONS.RAISE: {\n        const raiseAmount = validation.amount;\n        const actualRaise = raiseAmount - player.currentBet;\n        player.raise(raiseAmount); // Pass total target amount, not additional\n\n        gameState.minimumRaise = raiseAmount - gameState.currentBet;\n        gameState.currentBet = raiseAmount;\n        gameState.potObject.main += actualRaise;\n        gameState.lastRaiserIndex = player.position;\n        break;\n      }\n\n      case PLAYER_ACTIONS.ALL_IN: {\n        const allInAmount = player.chips;\n\n        if (gameState.currentBet === 0) {\n          player.bet(allInAmount);\n          if (allInAmount >= gameState.blinds.big) {\n            gameState.currentBet = allInAmount;\n            gameState.minimumRaise = allInAmount;\n            gameState.lastRaiserIndex = player.position;\n          }\n        } else if (player.currentBet + allInAmount > gameState.currentBet) {\n          player.raise(allInAmount);\n          const totalBet = previousBet + allInAmount;\n\n          if (totalBet >= gameState.currentBet + gameState.minimumRaise) {\n            gameState.minimumRaise = totalBet - gameState.currentBet;\n            gameState.currentBet = totalBet;\n            gameState.lastRaiserIndex = player.position;\n          }\n        } else {\n          player.call(allInAmount);\n        }\n\n        // Ensure all-in players have correct status\n        player.status = 'all-in';\n        player.lastAction = 'all-in';\n        gameState.potObject.main += allInAmount;\n        break;\n      }\n    }\n\n    gameState.handHistory.push({\n      playerId: player.id,\n      playerName: player.name,\n      _action,\n      amount: validation.amount || 0,\n      potAfter: gameState.getTotalPot(),\n      phase: gameState.phase,\n      handNumber: gameState.handNumber,\n      timestamp: Date.now(),\n    });\n  }\n\n  static isBettingRoundComplete(gameState) {\n    const activePlayers = gameState.players.filter((p) => p.canAct());\n\n    if (activePlayers.length <= 1) {\n      return true;\n    }\n\n    // Check if all active players have acted\n    const allPlayersActed = activePlayers.every((p) => p.lastAction !== null);\n\n    // Check if all active players have matched the current bet\n    const allBetsMatched = activePlayers.every((p) => p.currentBet === gameState.currentBet);\n\n    // Special case: Big blind option in preflop\n    if (\n      gameState.phase === 'preflop' &&\n      gameState.lastRaiserIndex === null &&\n      gameState.currentBet === gameState.blinds.big\n    ) {\n      const bigBlindPosition = gameState.getBigBlindPosition();\n      const bigBlindPlayer = gameState.getPlayerByPosition(bigBlindPosition);\n\n      // If big blind hasn't acted yet and all others have called/folded, betting round is not complete\n      if (bigBlindPlayer && bigBlindPlayer.canAct() && !bigBlindPlayer.lastAction) {\n        return false;\n      }\n    }\n\n    // If there was a raise, check if all players have acted since the raise\n    if (gameState.lastRaiserIndex !== null) {\n      for (const player of activePlayers) {\n        if (player.position === gameState.lastRaiserIndex) {\n          continue; // The raiser doesn't need to act again\n        }\n\n        if (!this.hasActedSinceLastRaise(gameState, player)) {\n          return false;\n        }\n      }\n    }\n\n    // Betting round is complete if all players have acted and matched the bet\n    return allPlayersActed && allBetsMatched;\n  }\n\n  static hasActedSinceLastRaise(gameState, player) {\n    const history = gameState.handHistory;\n    // Find last raise index (compatible with all browsers)\n    let lastRaiseIndex = -1;\n    for (let i = history.length - 1; i >= 0; i--) {\n      const actionType = history[i]._action || history[i].action;\n      if (actionType === PLAYER_ACTIONS.RAISE || actionType === PLAYER_ACTIONS.BET) {\n        lastRaiseIndex = i;\n        break;\n      }\n    }\n\n    if (lastRaiseIndex === -1) return true;\n\n    return history.slice(lastRaiseIndex + 1).some((h) => h.playerId === player.id);\n  }\n\n  static calculateMinBet(gameState) {\n    return gameState.blinds.big;\n  }\n\n  static calculateMinRaise(gameState) {\n    return gameState.currentBet + gameState.minimumRaise;\n  }\n\n  static calculatePotOdds(gameState, player) {\n    const callAmount = gameState.currentBet - player.currentBet;\n    if (callAmount <= 0) return 100;\n\n    const potAfterCall = gameState.getTotalPot() + callAmount;\n    return (callAmount / potAfterCall) * 100;\n  }\n\n  static getBettingRoundSummary(gameState) {\n    const activePlayers = gameState.getPlayersInHand();\n    const _pot = gameState.getTotalPot();\n    const toCall = gameState.currentBet;\n\n    return {\n      _pot,\n      toCall,\n      playersRemaining: activePlayers.length,\n      currentPlayer: gameState.players[gameState.currentPlayerIndex]?.name || 'None',\n      phase: gameState.phase,\n    };\n  }\n}\n\nexport default BettingLogic;\n","/**\n * PositionStrategy\n * Position-based hand range adjustments for AI decision making\n */\n\n/**\n * Position-based opening range percentages\n * Represents the top X% of hands that should be played from each position\n */\nconst POSITION_RANGES = {\n  // Early position: Play tight (top 12-15% of hands)\n  early: {\n    openRange: 0.12,\n    threeBetRange: 0.05,\n    callRange: 0.08,\n    premiumThreshold: 0.85,\n    strongThreshold: 0.7,\n    playableThreshold: 0.5,\n  },\n  // Middle position: Slightly looser (top 16-20%)\n  middle: {\n    openRange: 0.18,\n    threeBetRange: 0.07,\n    callRange: 0.12,\n    premiumThreshold: 0.8,\n    strongThreshold: 0.65,\n    playableThreshold: 0.45,\n  },\n  // Late position (cutoff): Much looser (top 25-30%)\n  late: {\n    openRange: 0.28,\n    threeBetRange: 0.1,\n    callRange: 0.18,\n    premiumThreshold: 0.75,\n    strongThreshold: 0.55,\n    playableThreshold: 0.35,\n  },\n  // Button: Widest range (top 35-40%)\n  button: {\n    openRange: 0.38,\n    threeBetRange: 0.12,\n    callRange: 0.25,\n    premiumThreshold: 0.7,\n    strongThreshold: 0.5,\n    playableThreshold: 0.3,\n  },\n  // Blinds: Defensive ranges\n  blinds: {\n    openRange: 0.25,\n    threeBetRange: 0.08,\n    callRange: 0.3, // Wider calling range in blinds due to pot odds\n    premiumThreshold: 0.75,\n    strongThreshold: 0.55,\n    playableThreshold: 0.35,\n    defendRange: 0.4, // Defend against steals with top 40%\n  },\n};\n\n/**\n * Steal and defense percentages\n */\nconst STEAL_FREQUENCIES = {\n  // How often to attempt steals from late position vs blinds\n  button: 0.45, // Steal 45% from button when folded to\n  cutoff: 0.35, // Steal 35% from cutoff\n  hijack: 0.25, // Steal 25% from hijack\n\n  // Defense frequencies against steals\n  bigBlindDefend: 0.4, // Defend BB 40% vs steal attempts\n  smallBlindDefend: 0.25, // Defend SB 25% vs steal attempts\n};\n\nclass PositionStrategy {\n  /**\n   * Get position type for a player\n   * @param {number} position - Player's seat position\n   * @param {number} dealerPosition - Current dealer button position\n   * @param {number} totalPlayers - Total players at table\n   * @returns {string} Position type: 'early', 'middle', 'late', 'button', 'blinds'\n   */\n  static getPosition(position, dealerPosition, totalPlayers) {\n    // Calculate relative position from dealer\n    const relativePosition = (position - dealerPosition + totalPlayers) % totalPlayers;\n\n    // For heads-up, just return 'button' or 'blinds'\n    if (totalPlayers === 2) {\n      return relativePosition === 0 ? 'button' : 'blinds';\n    }\n\n    // Map relative position to position type\n    // Position 0 = dealer (button)\n    // Position 1 = small blind\n    // Position 2 = big blind\n    // Position 3+ = early/middle/late depending on total players\n\n    if (relativePosition === 0) return 'button';\n    if (relativePosition === 1 || relativePosition === 2) return 'blinds';\n\n    // For remaining positions, distribute into early/middle/late\n    const nonBlindPositions = totalPlayers - 3; // Exclude BTN, SB, BB\n\n    if (nonBlindPositions <= 3) {\n      // 5-6 players: mostly late position\n      if (relativePosition === 3) return 'late';\n      return 'middle';\n    }\n\n    // 7+ players: proper distribution\n    const thirdOfPositions = Math.ceil(nonBlindPositions / 3);\n    const adjustedPosition = relativePosition - 3; // Position after BB\n\n    if (adjustedPosition < thirdOfPositions) return 'early';\n    if (adjustedPosition < thirdOfPositions * 2) return 'middle';\n    return 'late';\n  }\n\n  /**\n   * Get range parameters for a position\n   * @param {string} positionType - Position type\n   * @returns {Object} Range parameters\n   */\n  static getRangeForPosition(positionType) {\n    return POSITION_RANGES[positionType] || POSITION_RANGES.middle;\n  }\n\n  /**\n   * Adjust hand strength based on position\n   * @param {number} baseStrength - Base hand strength (0-1)\n   * @param {string} positionType - Position type\n   * @param {boolean} isPreflop - Whether this is preflop\n   * @returns {number} Adjusted hand strength\n   */\n  static adjustStrengthForPosition(baseStrength, positionType, isPreflop = true) {\n    if (!isPreflop) {\n      // Position less important postflop, but still relevant\n      const postflopMultiplier =\n        {\n          early: 0.95,\n          middle: 1.0,\n          late: 1.05,\n          button: 1.1,\n          blinds: 0.95,\n        }[positionType] || 1.0;\n\n      return Math.min(baseStrength * postflopMultiplier, 1.0);\n    }\n\n    // Preflop position adjustments\n    // Better positions allow playing weaker hands more profitably\n    const positionMultiplier =\n      {\n        early: 0.85, // Need stronger hands from early position\n        middle: 0.92,\n        late: 1.05,\n        button: 1.15, // Can play weaker hands profitably from button\n        blinds: 0.95, // Positional disadvantage postflop\n      }[positionType] || 1.0;\n\n    return Math.min(baseStrength * positionMultiplier, 1.0);\n  }\n\n  /**\n   * Check if hand is playable from given position\n   * @param {number} handStrength - Hand strength (0-1)\n   * @param {string} positionType - Position type\n   * @param {boolean} isRaised - Whether there's a raise to call\n   * @returns {boolean} Whether hand should be played\n   */\n  static isPlayableFromPosition(handStrength, positionType, isRaised = false) {\n    const range = this.getRangeForPosition(positionType);\n\n    if (isRaised) {\n      // Need stronger hand to call a raise\n      return handStrength >= range.callRange * 3; // Convert to strength threshold\n    }\n\n    return handStrength >= range.playableThreshold;\n  }\n\n  /**\n   * Check if hand should be opened from position\n   * @param {number} handStrength - Hand strength (0-1)\n   * @param {string} positionType - Position type\n   * @param {string} aiType - AI player type\n   * @returns {boolean} Whether to open raise\n   */\n  static shouldOpenRaise(handStrength, positionType, aiType = 'TAG') {\n    const range = this.getRangeForPosition(positionType);\n\n    // Adjust for AI type\n    const typeMultiplier =\n      {\n        TAG: 1.0, // Standard ranges\n        LAG: 1.3, // 30% wider\n        TP: 0.8, // 20% tighter\n        LP: 1.2, // 20% wider but passive\n      }[aiType] || 1.0;\n\n    const adjustedThreshold = range.strongThreshold / typeMultiplier;\n\n    return handStrength >= adjustedThreshold;\n  }\n\n  /**\n   * Get steal frequency for position\n   * @param {string} positionType - Position type\n   * @returns {number} Steal frequency (0-1)\n   */\n  static getStealFrequency(positionType) {\n    return (\n      {\n        button: STEAL_FREQUENCIES.button,\n        late: STEAL_FREQUENCIES.cutoff,\n        middle: STEAL_FREQUENCIES.hijack,\n      }[positionType] || 0\n    );\n  }\n\n  /**\n   * Get blind defense frequency\n   * @param {boolean} isSmallBlind - Whether player is in small blind\n   * @returns {number} Defense frequency (0-1)\n   */\n  static getBlindDefenseFrequency(isSmallBlind) {\n    return isSmallBlind ? STEAL_FREQUENCIES.smallBlindDefend : STEAL_FREQUENCIES.bigBlindDefend;\n  }\n\n  /**\n   * Calculate bet sizing adjustment based on position\n   * @param {number} baseBetSize - Base bet size\n   * @param {string} positionType - Position type\n   * @returns {number} Adjusted bet size\n   */\n  static adjustBetSizeForPosition(baseBetSize, positionType) {\n    const sizeMultiplier =\n      {\n        early: 1.2, // Larger bets from early position (protection)\n        middle: 1.1,\n        late: 1.0,\n        button: 0.9, // Can bet smaller from position\n        blinds: 1.1, // Larger bets out of position\n      }[positionType] || 1.0;\n\n    return Math.floor(baseBetSize * sizeMultiplier);\n  }\n}\n\nexport default PositionStrategy;\n","import { AI_PLAYER_TYPES } from '../../constants/game-constants';\n\nimport PositionStrategy from './strategies/PositionStrategy';\n\nclass AIPlayer {\n  static getAction(player, gameState, validActions, gameEngine) {\n    const { aiType } = player;\n\n    const holeCards = gameEngine.getPlayerCards(player.id);\n    const communityCards = gameEngine.getCommunityCards();\n    const isPreflop = gameState.phase === 'preflop';\n\n    // Get position information\n    const positionType = PositionStrategy.getPosition(\n      player.position,\n      gameState.dealerPosition,\n      gameState.players.length\n    );\n\n    // Evaluate hand strength with position adjustment\n    const baseStrength = this.evaluateHandStrength(holeCards, communityCards, gameState.phase);\n    const handStrength = PositionStrategy.adjustStrengthForPosition(\n      baseStrength,\n      positionType,\n      isPreflop\n    );\n\n    // Create enhanced context for decision making\n    const context = {\n      handStrength,\n      baseStrength,\n      positionType,\n      isPreflop,\n      isInPosition: positionType === 'button' || positionType === 'late',\n      facingRaise: gameState.currentBet > gameState.blinds.big,\n    };\n\n    switch (aiType) {\n      case AI_PLAYER_TYPES.TAG:\n        return this.getTightAggressiveAction(\n          handStrength,\n          validActions,\n          gameState,\n          player,\n          context\n        );\n      case AI_PLAYER_TYPES.LAG:\n        return this.getLooseAggressiveAction(\n          handStrength,\n          validActions,\n          gameState,\n          player,\n          context\n        );\n      case AI_PLAYER_TYPES.TP:\n        return this.getTightPassiveAction(handStrength, validActions, gameState, player, context);\n      case AI_PLAYER_TYPES.LP:\n        return this.getLoosePassiveAction(handStrength, validActions, gameState, player, context);\n      default:\n        return this.getDefaultAction(validActions, gameState, player);\n    }\n  }\n\n  static evaluateHandStrength(holeCards, communityCards, phase) {\n    if (!holeCards || holeCards.length < 2) return 0;\n\n    const [card1, card2] = holeCards;\n    const isPair = card1.rank === card2.rank;\n    const isSuited = card1.suit === card2.suit;\n    const highCard = Math.max(card1.value, card2.value);\n    const lowCard = Math.min(card1.value, card2.value);\n    const gap = highCard - lowCard;\n\n    if (phase === 'preflop') {\n      if (isPair) {\n        if (highCard >= 12) return 0.9;\n        if (highCard >= 9) return 0.7;\n        return 0.5;\n      }\n\n      if (highCard === 14) {\n        if (lowCard >= 11) return 0.8;\n        if (lowCard >= 9) return 0.6;\n      }\n\n      if (highCard === 13 && lowCard >= 11) return 0.6;\n\n      if (isSuited && gap <= 4) return 0.4;\n\n      if (gap <= 2 && highCard >= 10) return 0.3;\n\n      return 0.2;\n    }\n\n    return this.calculatePostFlopStrength(holeCards, communityCards);\n  }\n\n  static calculatePostFlopStrength(holeCards, communityCards) {\n    if (communityCards.length === 0) return 0.3;\n\n    const allCards = [...holeCards, ...communityCards];\n    const hasTopPair = this.hasTopPair(holeCards, communityCards);\n    const hasTwoPair = this.hasTwoPair(allCards);\n    const hasSet = this.hasSet(holeCards, communityCards);\n    const hasFlushDraw = this.hasFlushDraw(allCards);\n    const hasStraightDraw = this.hasStraightDraw(allCards);\n\n    if (hasSet) return 0.9;\n    if (hasTwoPair) return 0.75;\n    if (hasTopPair) return 0.65;\n    if (hasFlushDraw && hasStraightDraw) return 0.55;\n    if (hasFlushDraw || hasStraightDraw) return 0.45;\n\n    return 0.25;\n  }\n\n  static hasTopPair(holeCards, communityCards) {\n    if (communityCards.length === 0) return false;\n\n    const maxCommunityValue = Math.max(...communityCards.map((c) => c.value));\n    return holeCards.some((card) => card.value === maxCommunityValue);\n  }\n\n  static hasTwoPair(cards) {\n    const ranks = {};\n    cards.forEach((card) => {\n      ranks[card.rank] = (ranks[card.rank] || 0) + 1;\n    });\n\n    const pairs = Object.values(ranks).filter((count) => count >= 2);\n    return pairs.length >= 2;\n  }\n\n  static hasSet(holeCards, communityCards) {\n    if (holeCards[0].rank !== holeCards[1].rank) return false;\n\n    return communityCards.some((card) => card.rank === holeCards[0].rank);\n  }\n\n  static hasFlushDraw(cards) {\n    const suits = {};\n    cards.forEach((card) => {\n      suits[card.suit] = (suits[card.suit] || 0) + 1;\n    });\n\n    return Object.values(suits).some((count) => count >= 4);\n  }\n\n  static hasStraightDraw(cards) {\n    const values = [...new Set(cards.map((c) => c.value))].sort((a, b) => a - b);\n\n    for (let i = 0; i <= values.length - 4; i++) {\n      let consecutive = 1;\n      for (let j = i; j < i + 4 && j < values.length - 1; j++) {\n        if (values[j + 1] - values[j] === 1) {\n          consecutive++;\n        }\n      }\n      if (consecutive >= 4) return true;\n    }\n\n    return false;\n  }\n\n  static getTightAggressiveAction(handStrength, validActions, gameState, player, context = {}) {\n    const callAmount = gameState.currentBet - player.currentBet;\n    const potSize = gameState.totalPot || 0;\n    const stackSize = player.chips;\n    const { positionType = 'middle', isInPosition = false } = context;\n\n    // Position-adjusted thresholds\n    const raiseThreshold = isInPosition ? 0.6 : 0.7;\n    const callThreshold = isInPosition ? 0.35 : 0.4;\n    const callPotRatio = isInPosition ? 0.4 : 0.3;\n\n    // Strong hand: Raise aggressively\n    if (handStrength >= raiseThreshold) {\n      if (validActions.includes('raise')) {\n        const baseBet = gameState.currentBet + gameState.minimumRaise + (potSize || 100) * 0.75;\n        const raiseAmount = PositionStrategy.adjustBetSizeForPosition(\n          Math.min(baseBet, stackSize),\n          positionType\n        );\n        return { action: 'raise', amount: Math.floor(raiseAmount) };\n      }\n      if (validActions.includes('bet')) {\n        const baseBet = Math.max((potSize || 100) * 0.75, gameState.blinds?.big || 20);\n        const betAmount = PositionStrategy.adjustBetSizeForPosition(\n          Math.min(baseBet, stackSize),\n          positionType\n        );\n        return { action: 'bet', amount: Math.floor(betAmount) };\n      }\n    }\n\n    // Medium hand: Call if price is right\n    if (handStrength >= callThreshold) {\n      if (validActions.includes('call') && callAmount <= (potSize || 100) * callPotRatio) {\n        return { action: 'call', amount: callAmount };\n      }\n      if (validActions.includes('check')) {\n        return { action: 'check', amount: 0 };\n      }\n    }\n\n    // Weak hand: Check or fold\n    if (validActions.includes('check')) {\n      return { action: 'check', amount: 0 };\n    }\n\n    return { action: 'fold', amount: 0 };\n  }\n\n  static getLooseAggressiveAction(handStrength, validActions, gameState, player, context = {}) {\n    const callAmount = gameState.currentBet - player.currentBet;\n    const potSize = gameState.totalPot || 0;\n    const stackSize = player.chips;\n    const { positionType = 'middle', isInPosition = false, isPreflop = true } = context;\n\n    // LAG plays more hands from position and bluffs more\n    const baseBluffFrequency = 0.3;\n    const bluffFrequency = isInPosition ? baseBluffFrequency * 1.4 : baseBluffFrequency;\n    const stealFrequency = PositionStrategy.getStealFrequency(positionType);\n\n    // Position-adjusted thresholds - LAG is looser from late position\n    const raiseThreshold = isInPosition ? 0.35 : 0.5;\n    const callThreshold = isInPosition ? 0.15 : 0.25;\n\n    // Steal attempt from late position\n    if (isPreflop && isInPosition && gameState.currentBet === gameState.blinds?.big) {\n      if (Math.random() < stealFrequency && validActions.includes('raise')) {\n        const raiseAmount = Math.min(gameState.currentBet * 3, stackSize);\n        return { action: 'raise', amount: Math.floor(raiseAmount) };\n      }\n    }\n\n    if (handStrength >= raiseThreshold || Math.random() < bluffFrequency) {\n      if (validActions.includes('raise')) {\n        const baseBet = gameState.currentBet + gameState.minimumRaise + (potSize || 100) * 0.5;\n        const raiseAmount = PositionStrategy.adjustBetSizeForPosition(\n          Math.min(baseBet, stackSize),\n          positionType\n        );\n        return { action: 'raise', amount: Math.floor(raiseAmount) };\n      }\n      if (validActions.includes('bet')) {\n        const baseBet = Math.max((potSize || 100) * 0.6, gameState.blinds?.big || 20);\n        const betAmount = PositionStrategy.adjustBetSizeForPosition(\n          Math.min(baseBet, stackSize),\n          positionType\n        );\n        return { action: 'bet', amount: Math.floor(betAmount) };\n      }\n    }\n\n    if (handStrength >= callThreshold) {\n      if (validActions.includes('call') && callAmount <= (potSize || 100) * 0.5) {\n        return { action: 'call', amount: callAmount };\n      }\n      if (validActions.includes('check')) {\n        return { action: 'check', amount: 0 };\n      }\n    }\n\n    if (validActions.includes('check')) {\n      return { action: 'check', amount: 0 };\n    }\n\n    return { action: 'fold', amount: 0 };\n  }\n\n  static getTightPassiveAction(handStrength, validActions, gameState, player, context = {}) {\n    const callAmount = gameState.currentBet - player.currentBet;\n    const potSize = gameState.totalPot || 0;\n    const stackSize = player.chips;\n    const { isInPosition = false } = context;\n\n    // TP plays fewer hands and prefers calling to raising\n    // Position adjustments are smaller for passive players\n    const betThreshold = isInPosition ? 0.75 : 0.8;\n    const callThreshold = isInPosition ? 0.45 : 0.5;\n    const callPotRatio = isInPosition ? 0.25 : 0.2;\n\n    if (handStrength >= betThreshold) {\n      if (validActions.includes('bet')) {\n        // TP bets small with strong hands\n        const betAmount = Math.min(\n          Math.max((potSize || 100) * 0.3, gameState.blinds?.big || 20),\n          stackSize\n        );\n        return { action: 'bet', amount: Math.floor(betAmount) };\n      }\n      if (validActions.includes('call')) {\n        return { action: 'call', amount: callAmount };\n      }\n    }\n\n    if (handStrength >= callThreshold) {\n      if (validActions.includes('call') && callAmount <= (potSize || 100) * callPotRatio) {\n        return { action: 'call', amount: callAmount };\n      }\n      if (validActions.includes('check')) {\n        return { action: 'check', amount: 0 };\n      }\n    }\n\n    if (validActions.includes('check')) {\n      return { action: 'check', amount: 0 };\n    }\n\n    return { action: 'fold', amount: 0 };\n  }\n\n  static getLoosePassiveAction(handStrength, validActions, gameState, player, context = {}) {\n    const callAmount = gameState.currentBet - player.currentBet;\n    const potSize = gameState.totalPot || 0;\n    const stackSize = player.chips;\n    const { isInPosition = false } = context;\n\n    // LP plays many hands but rarely raises - the classic \"calling station\"\n    // Position slightly affects their calling range\n    const betThreshold = isInPosition ? 0.65 : 0.7;\n    const callThreshold = isInPosition ? 0.15 : 0.2;\n    const callPotRatio = isInPosition ? 0.5 : 0.4;\n\n    if (handStrength >= betThreshold) {\n      if (validActions.includes('bet')) {\n        // LP bets small even with strong hands\n        const betAmount = Math.min(\n          Math.max((potSize || 100) * 0.25, gameState.blinds?.big || 20),\n          stackSize\n        );\n        return { action: 'bet', amount: Math.floor(betAmount) };\n      }\n    }\n\n    // LP has wide calling range - they like to see flops and showdowns\n    if (handStrength >= callThreshold) {\n      if (validActions.includes('call') && callAmount <= (potSize || 100) * callPotRatio) {\n        return { action: 'call', amount: callAmount };\n      }\n      if (validActions.includes('check')) {\n        return { action: 'check', amount: 0 };\n      }\n    }\n\n    if (validActions.includes('check')) {\n      return { action: 'check', amount: 0 };\n    }\n\n    return { action: 'fold', amount: 0 };\n  }\n\n  static getDefaultAction(validActions, gameState, player) {\n    if (validActions.includes('check')) {\n      return { action: 'check', amount: 0 };\n    }\n\n    const callAmount = gameState.currentBet - player.currentBet;\n    const _potOdds = gameState.totalPot / callAmount;\n\n    if (validActions.includes('call') && _potOdds > 3) {\n      return { action: 'call', amount: callAmount };\n    }\n\n    return { action: 'fold', amount: 0 };\n  }\n}\n\nexport default AIPlayer;\n"],"names":["constructor","this","cards","dealtCards","reset","suit","Object","values","SUITS","rank","RANKS","push","Card","shuffle","getRandomIndex","max","crypto","getRandomValues","array","Uint32Array","Math","floor","random","i","length","j","dealCard","Error","card","shift","dealOne","dealCards","count","deal","cardsRemaining","getRemainingCards","getDealtCards","removeSpecificCards","cardsToRemove","filter","some","removeCard","players","deck","communityCards","_internalPot","main","side","potHistory","currentBet","_currentBet","minimumRaise","minRaise","dealerPosition","smallBlindPosition","bigBlindPosition","currentPlayerIndex","phase","GAME_PHASES","WAITING","handNumber","blinds","small","big","lastRaiserIndex","bettingRoundComplete","handHistory","winners","initialize","PREFLOP","validateState","addPlayer","player","position","removePlayer","playerId","p","id","updatePlayerPositions","forEach","index","getActivePlayers","isActive","chips","status","PLAYER_STATUS","ALL_IN","FOLDED","SITTING_OUT","getPlayersInHand","isInHand","getNextActivePlayerIndex","startIndex","numPlayers","canAct","moveButton","getSmallBlindPosition","getBigBlindPosition","getUTGPosition","resetForNewHand","calculateSidePots","activePlayers","contributions","totalPotContribution","amount","sort","a","b","previousAmount","currentAmount","potAmount","eligiblePlayers","slice","map","c","getTotalPot","total","sidePot","addToHistory","_action","timestamp","Date","now","getPlayerByPosition","find","serialize","pot","_pot","totalPot","playersInHand","self","potValue","valueOf","toString","Symbol","toPrimitive","_hint","value","potObject","nextDealer","addToPot","setCurrentBet","arguments","undefined","nextPhase","phases","FLOP","TURN","RIVER","SHOWDOWN","currentIndex","indexOf","setCommunityCards","nextPlayer","getCurrentPlayer","isHandComplete","createSidePots","contribution","sidePots","isBettingRoundComplete","playersWhoCanAct","bets","every","bet","lastAction","toJSON","evaluateHand","allCombinations","getCombinations","bestHand","bestRank","bestTiebreakers","combination","evaluation","evaluateFiveCardHand","compareTiebreakers","tiebreakers","rankName","description","sortedCards","isFlush","checkFlush","straightHighCard","checkStraight","groups","groupByRank","groupSizes","group","HAND_RANKINGS","ROYAL_FLUSH","STRAIGHT_FLUSH","concat","getCardName","fourOfAKindRank","getRankOfSize","kicker","FOUR_OF_A_KIND","threeOfAKindRank","pairRank","FULL_HOUSE","flushCards","FLUSH","STRAIGHT","kickers","getKickers","THREE_OF_A_KIND","pairs","getRanksOfSize","TWO_PAIR","PAIR","highCards","HIGH_CARD","suits","isStraight","size","entries","parseInt","ranks","usedRanks","sortedRanks","keys","r","includes","min","arr","combinations","backtrack","start","current","pop","compareHands","hand1","hand2","findWinners","playerHands","evaluatedHands","_ref","hand","gameState","GameState","Deck","_isRestarting","_isInitialized","callbacks","onStateChange","onHandComplete","onPlayerAction","onPhaseChange","onShowdown","setCallback","event","callback","prototype","hasOwnProperty","call","notifyStateChange","startNewHand","postBlinds","dealHoleCards","notifyPhaseChange","error","smallBlindPlayer","bigBlindPlayer","sbAmount","placeBet","playerName","name","bbAmount","holeCards","dealCommunityCards","executePlayerAction","console","currentPlayer","BettingLogic","executeAction","checkAndAdvanceGame","success","action","_this$gameState","_this$gameState$playe","_this$gameState2","gameStateExists","playersCount","message","handleSinglePlayerWin","advanceToNextPhase","moveToNextPlayer","nextIndex","resetBettingRound","handleShowdown","winner","winPot","handDescription","completeHand","mainPotWinners","HandEvaluator","mainPotAmount","mainPotShare","eligibleHands","_ref2","sidePotWinners","sidePotShare","_ref3","existingWinner","w","setTimeout","getValidActions","warn","getGameState","setBlinds","getPlayerCards","getAllPlayerCards","getCommunityCards","getPotOdds","calculatePotOdds","isAI","aiType","_position","totalBetThisRound","isFolded","isAllIn","isDealer","stats","handsPlayed","handsWon","biggestPotWon","totalWinnings","vpip","pfr","aggression","setHoleCards","receiveCards","clearHoleCards","betAmount","fold","check","CHECKED","callAmount","actualAmount","CALLED","raise","additionalAmount","raiseAmount","RAISED","checkIfActive","ACTIVE","decideAction","AIPlayer","require","validActions","getAction","getNetPosition","updateStats","hasCards","humanPlayerId","options","initialChips","smallBlind","bigBlind","aiPlayers","type","gameEngine","useState","GameEngine","setGameState","showControls","setShowControls","setValidActions","showdown","setShowdown","isProcessingAI","setIsProcessingAI","setError","isGameActive","setIsGameActive","isProcessingRef","useRef","gameEngineRef","useHandHistory","processSingleAITurn","useCallback","engine","currentGameState","actions","aiAction","result","updatedState","processAITurns","processNext","err","initializeGame","humanPlayer","Player","aiConfig","idx","aiPlayer","useEffect","_callbacksInitialized","newState","stateWithTimestamp","_objectSpread","_updateTimestamp","isSessionActive","captureAction","getCurrentPlayerInfo","useMemo","isHumanTurn","timeoutId","stillCurrentPlayer","clearTimeout","checkEngine","checkPlayer","BettingControls","React","playerChips","playerBet","onAction","minBet","setBetAmount","handleSliderChange","e","target","handleInputChange","setPresetBet","fraction","potOdds","potAfterCall","toFixed","_jsxs","className","role","children","_jsx","htmlFor","onChange","onClick","disabled","parseFloat","prevProps","nextProps","JSON","stringify","displayName","faceDown","suitClass","s","h","d","suitSymbol","getSuitSymbol","getCardDescription","suitName","getSuitName","_prevProps$card","_nextProps$card","_prevProps$card2","_nextProps$card2","PlayerSeat","showCards","positionLabel","getPositionLabel","seatClasses","Boolean","join","_Fragment","_index","style","width","prevPlayer","onGameStateChange","usePokerGame","countdown","setCountdown","isWaitingPhase","timer","setInterval","prev","clearInterval","isShowdownPhase","canShowControls","communityCardCount","placeholderCount","Array","_","transform","handleNewHand","validateAction","valid","reason","PLAYER_ACTIONS","FOLD","CHECK","CALL","BET","RAISE","validation","previousBet","actualCall","actualRaise","allInAmount","totalBet","potAfter","allPlayersActed","allBetsMatched","hasActedSinceLastRaise","history","lastRaiseIndex","actionType","calculateMinBet","calculateMinRaise","getBettingRoundSummary","_gameState$players$ga","toCall","playersRemaining","POSITION_RANGES","early","openRange","threeBetRange","callRange","premiumThreshold","strongThreshold","playableThreshold","middle","late","button","defendRange","STEAL_FREQUENCIES","getPosition","totalPlayers","relativePosition","nonBlindPositions","thirdOfPositions","ceil","adjustedPosition","getRangeForPosition","positionType","adjustStrengthForPosition","baseStrength","postflopMultiplier","positionMultiplier","isPlayableFromPosition","handStrength","isRaised","range","shouldOpenRaise","typeMultiplier","TAG","LAG","TP","LP","getStealFrequency","getBlindDefenseFrequency","isSmallBlind","adjustBetSizeForPosition","baseBetSize","sizeMultiplier","isPreflop","PositionStrategy","evaluateHandStrength","context","isInPosition","facingRaise","AI_PLAYER_TYPES","getTightAggressiveAction","getLooseAggressiveAction","getTightPassiveAction","getLoosePassiveAction","getDefaultAction","card1","card2","isPair","isSuited","highCard","lowCard","gap","calculatePostFlopStrength","allCards","hasTopPair","hasTwoPair","hasSet","hasFlushDraw","hasStraightDraw","maxCommunityValue","Set","consecutive","potSize","stackSize","callThreshold","callPotRatio","baseBet","_gameState$blinds","_gameState$blinds2","bluffFrequency","baseBluffFrequency","stealFrequency","raiseThreshold","_gameState$blinds3","_gameState$blinds4","_gameState$blinds5","_potOdds"],"ignoreList":[],"sourceRoot":""}